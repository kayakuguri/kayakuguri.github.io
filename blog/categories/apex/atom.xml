<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apex | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/apex/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2014-12-12T16:03:02+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apexのテストで変数部分にテストが通ってくれない時]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/12/02/apex-json-class-test/"/>
    <updated>2014-12-02T18:41:35+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/12/02/apex-json-class-test</id>
    <content type="html"><![CDATA[<p>きっと基本を理解してないんだと思いますが、単純な話でした。</p>

<!-- more -->


<p>JsonをGETで引き渡して、それをApexクラスにしてapex内で使用するべく、<br/>
apex2Jsonとして以下のようなクラスを作成していた。</p>

<pre><code>public class Json2Apex{
    public String user_id;
    public String dummy;

    public static Json2Apex parse(String json){
        return (Json2Apex) System.JSON.deserialize(json, Json2Apex.class);
    }
}
</code></pre>

<p>ちゃんとJSONには、<code>user_id</code>と<code>dummy</code>の値を持たせて変換させ、<br/>
その変数にもきっちりアクセスした状態でも、テストを走らせてみると、<br/>
<code>parse</code>メソッド部分しか通ってない。<br/>
全体の行数が少ないので、パーセンテージとしては、<strong>50%</strong>。<br/>
これでは他のリリースに影響が大なので、調べてみると、単純な事で、<br/>
<code>{get; set;}</code>をつけろ、ってだけだった。<br/>
以下のようにつける。</p>

<pre><code>public String user_id{get; set;}
public String dummy{get; set;}
</code></pre>

<p>これだけでテストコードも変更することなく通り、無事、100%を達成できました。</p>

<p>参考：<a href="http://salesforce.stackexchange.com/questions/10018/testing-apex-classes-created-by-jsontoapex">http://salesforce.stackexchange.com/questions/10018/testing-apex-classes-created-by-jsontoapex</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文字列をDatetime型に変換する時の注意点]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/12/01/apex-datetime-gmt/"/>
    <updated>2014-12-01T12:53:59+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/12/01/apex-datetime-gmt</id>
    <content type="html"><![CDATA[<p>apexにて、文字列からDatetime型に変更した際の注意点。</p>

<!-- more -->


<p>例えば、日本で作業してる場合は、<code>GMT+9</code>となり、標準時より9時間プラス、となる。<br/>
文字列からdatetime型に変更する際にはいくつか方法があるが、<code>valueOf</code>が簡単。<br/>
しかし例えば以下のようにすると意図しない時間が帰って来てしまう</p>

<pre><code>String test_str = '2014-12-1 05:30:18';
Datetime test_dt = Datetime.valueOf(test_str);
System.debug(test_dt);

//出力
// 2014-11-30 20:30:18
</code></pre>

<p>特に顕著な例だけど、月が変わってしまっている。<br/>
なぜかというと、Datetime型に変換する際に、(なぜか)GMTが考慮されて、標準時に戻して出力されるよう。<br/>
日本は+9時間なので、標準時は-9時間。<br/>
なので、指定した時間よりも９時間マイナスされた日時が返却される仕様。<br/>
このため、日付が変わり、その結果、月も変わってしまったという現象が起こる。<br/>
それを回避するにはちゃんとメソッドが用意されていて、<code>valueOfGmt</code>を使う。<br/>
これだと、設定しているGMTを使って(要するに入力された時間そのまま)、Datetimeを作成してくれる。</p>

<pre><code>String test_str = '2014-12-1 05:30:18';
Datetime test_dt = Datetime.valueOfGmt(test_str);
System.debug(test_dt);

//出力
// 2014-12-1 05:30:18
</code></pre>

<p>月まで変わると結構クリティカルだと思うので、要注意。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]apex Rest APIでPOSTでデータを送信する]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/10/27/apex-rest-post/"/>
    <updated>2014-10-27T18:49:51+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/10/27/apex-rest-post</id>
    <content type="html"><![CDATA[<p>getでは送信したデータはすぐに取得できたのですが、<br/>
postでの送信方法とデータ取得方法がわからずに迷走しまいした。<br/>
結論は、送信側の話、だったのですが。</p>

<!-- more -->


<p>GETの場合は以下のコードで取得可能でした。<br/>
簡単。</p>

<p>送信データ</p>

<pre><code>?userid=123&amp;name=hoge
</code></pre>

<p>apex</p>

<pre><code>@RestResource(urlMapping='/GetDataSample/test')

global with sharing class GetDataSampleAPI {
    @HttpGet
    global static String doGet(){
        RestRequest req = RestContext.request;
        String userid = req.params.get('userid');
        String name = req.params.get('hoge');
    }
}
</code></pre>

<p>実は、POSTの場合も、apexのコードは全く同じで取得する事が出来ました。<br/>
以下、取得出来たコードです。</p>

<pre><code>@RestResource(urlMapping='/GetDataSample/test')

global with sharing class GetDataSampleAPI {
    @HttpPost
    global static String doPost(){
        RestRequest req = RestContext.request;
        String userid = req.params.get('userid');
        String name = req.params.get('hoge');
    }
}
</code></pre>

<p>ただし、送信する際にヘッダーを正しく指定してやったり、送信形式に注意してやる必要がありました。<br/>
PHPのcurlで実装していたのですが、大いに迷走していたのは、salesforce側の話ではなく、<br/>
PHPでの送信方法の問題でしたとさ…。</p>

<p>送信出来たコード<br/>
(<a href="https://github.com/nkjm/Force.com-OAuth-Toolkit-for-PHP">このライブラリ</a>を使用して送信する前提)</p>

<pre><code>$url = "$oauth-&gt;instance_url/services/apexrest/GetDataSample/test";
$curl = curl_init($url);

$POST_DATA = array(
    'userid' =&gt; '123',
    'hoge' =&gt; 'fugafuga'
);

curl_setopt($curl, CURLOPT_POST, TRUE);
curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($POST_DATA));
curl_setopt($curl, CURLOPT_HEADER, false);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
curl_setopt($curl, CURLOPT_HTTPHEADER, array('Content-type: application/x-www-form-urlencoded;charset=UTF-8', "Authorization: OAuth " . $oauth-&gt;access_token));

$output= curl_exec($curl);
curl_close($curl);
</code></pre>

<p>ポイントは以下の２つです。</p>

<p>１）<br/>
<code>Content-type</code>を、<code>application/x-www-form-urlencoded</code>という、POSTでデータを送信する際の標準タイプを指定しています。<br/>
通常はデフォルトでこれなのですが、salesforceのAPIにPOSTする場合は明示的に指定してやる必要があるようです。(たぶん)<br/>
ちなみに、apex restは、<code>multipart/form-data</code>タイプはサポートしていないようです。</p>

<p>２）<br/>
１のタイプで指定してやると、送信するデータは<code>userid=123&amp;hoge=fugafuga</code>のように、GETと同じ形で取得できるようになるようです。<br/>
なので送信する際にそのような形に変換してやる必要があるようで、それが以下の記述となります。</p>

<pre><code>curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($POST_DATA));
</code></pre>

<h3>参考</h3>

<p><a href="http://qiita.com/khirose/items/870ffec6ce4562f54c9d">PHP小ネタ &ndash; PHPのcurlでPOST &ndash; Qiita</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apexで割り算をしたら整数になった]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/10/21/apex-decimal/"/>
    <updated>2014-10-21T16:44:39+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/10/21/apex-decimal</id>
    <content type="html"><![CDATA[<p>タイトル通り、apex上で割り算をしたら整数になってしまったんですね。<br/>
単純に型付け言語による仕様だったのですが、ちょっとハマったのでメモ。</p>

<!-- more -->


<p>最初、記述したのが以下のコード</p>

<pre><code>Decimal a = 1 / 2;
System.debug(a);  //0
</code></pre>

<p>これだと、<code>0</code>が出力されます。<br/>
<code>Decimal</code>は小数まで表示できる型なのになんで？？？<br/>
と思ったんですが、計算している、<code>1</code>とか<code>2</code>が、<code>Integer</code>型、ってことなんですね。<br/>
なので、これを<code>Decimal</code>型にしてやると計算できます。</p>

<pre><code>Decimal a = Decimal.valueOf(1) / Decimal.valueOf(2);
System.debug(a);  //0.5
</code></pre>

<p>しかし数字を書きたいだけなのにいちいちキャストするのはめんどう。<br/>
なので、以下でも大丈夫。</p>

<pre><code>Decimal a = 1.0 / 2.0;
System.debug(a);  //0.5
</code></pre>

<p>小数点をつけると<code>Decimal</code>型になるようです。</p>

<p>ちなみにやりたかったことは、<code>Datetime</code>型の現在時間を日本時間(GMT+9)で表示することです。</p>

<pre><code>Datetime.now() + (9.0/24.0)
</code></pre>

<p><code>Datetime</code>型の足し算は1日単位で行われるため、24で割ると時間になります。<br/>
しかし、小数点にしないと<code>0</code>になってしまい計算できませんでした。<br/>
<code>format</code>をつかってフォーマットしてしまうと文字列になってしまうため、足し算で対応しています。</p>

<p>・<code>format</code>を使った場合</p>

<pre><code>Datetime.now().format('yyyy-MM-dd hh:mm', 'JST');
</code></pre>

<p><a href="https://sites.google.com/site/odekakeshimasyo/salesforceapexdatetime">Salesforce Apex 日付 時間 &ndash; おでかけしましょ</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]SOQLで子リレーションの情報を取得する]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/10/15/soql-relation/"/>
    <updated>2014-10-15T17:42:17+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/10/15/soql-relation</id>
    <content type="html"><![CDATA[<p>SOQLにて、あるオブジェクトの子リレーションになっているオブジェクトの情報を取得したい場合の話です。</p>

<!-- more -->


<p>子オブジェクトの参照名は、カスタムオブジェクトの場合は、<code>__r</code>となっていて、<br/>
標準オブジェクトは、お尻に<code>s</code>をつける形となっています。(だいたい)</p>

<p>今回はあまり例で見ることのなかった、<code>campaign</code>、<code>campaignmember</code>で例を示します。</p>

<p>とあるキャンペーンのキャンペーンメンバーのデータを取得する場合、以下のようなSOQLで取得できます。</p>

<pre><code>Select id, (Select cm.id From CampaignMembers cm) From Campaign
</code></pre>

<p>これを開発者コンソールの、Query Editorで実行してみると、以下の様なデータが取得できます。<br/>
(1レコード例)</p>

<pre><code>id: 701O00000007osrIAA
CampaignMembers: [{"Id":"00vO0000002B00XIAS"},{"Id":"00vO0000002B00SIAS"}]
</code></pre>

<p>これをapex上で使用するには、<code>CampaignMmber</code>が配列で入ってくるので、<br/>
for文で回して取得してやる必要があります。<br/>
以下は、３つの<code>campaignID</code>から取得したデータの<code>CampaignMember</code>の<code>status</code>を取得しています。</p>

<pre><code>List&lt;String&gt; campid = new List&lt;String&gt;();
campid.add('701O00000007orzIAA');
campid.add('701O00000007osrIAA');
campid.add('701O00000007l1sIAA');
String soql_c = 'SELECT id,type, (Select Status From CampaignMembers) FROM Campaign WHERE id=:campid';

List&lt;Campaign&gt; campRes;
campRes = Database.query(soql_c);

for(Campaign cdata : campRes){
    for(CampaignMember cmdata : cdata.CampaignMembers){
        System.debug(cmdata.Status);
    }
}
</code></pre>

<h3>参考</h3>

<p><a href="http://blog.flect.co.jp/salesforce/2010/07/soql-3dd0.html">セールスフォースの豆知識: SOQLでのリレーションの辿り方</a></p>
]]></content>
  </entry>
  
</feed>
