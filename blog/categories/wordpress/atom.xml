<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: wordpress | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/wordpress/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2016-07-07T17:51:38+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SalesforceからWP REST APIへOAuth認証を利用して投稿する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/06/30/sf-callout-wp-rest-api-oauth1/"/>
    <updated>2016-06-30T17:36:44+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/06/30/sf-callout-wp-rest-api-oauth1</id>
    <content type="html"><![CDATA[<p>salesforceからWP REST APIのエンドポイントへコールアウトして投稿する。<br/>
投稿の際には、OAuth認証を利用する。</p>

<!-- more -->


<h1>前提</h1>

<p>WordPress側にで、OAuth 1.0a Serverを導入してアプリケーションを作成しておく。<br/>
また、そのアプリケーションを使用して、アクセストークンまで取得しているものとする。</p>

<p>通常は承認のフローなどはユーザー側が行うため、アクセストークンまでもった状態からスタートすることはないと思うが、今回は最後の投稿部分だけに絞って試してみた。</p>

<p>WP REST APIでアクセストークンを取得するには、前回書いたこの記事を参考にどうぞ。<br/>
<a href="http://kayakuguri.github.io/blog/2016/06/30/wp-rest-oauth/">WordPress REST APIにOAuth1.0aで認証して投稿する &ndash; KayaMemo</a></p>

<h1>リモートサイトの登録</h1>

<p>コールアウトする先のドメインを事前に許可しておいてやる必要がある。<br/>
<code>設定 -&gt; セキュリティのコントロール -&gt; リモートサイトの設定</code> から、<code>新規リモートサイト</code>をクリック。</p>

<ul>
<li>リモートサイト名 : 適当な名前</li>
<li>リモートさサイトのURL : 接続先ドメイン</li>
<li>プロトコルセキュリティの無効化 : HTTPでも接続を許可するか</li>
<li>説明 : 適当な説明</li>
<li>有効 : オンに</li>
</ul>


<p>通常では当然だが、HTTPSでの通信が推奨されている。
しかし、リスクを承知、もしくはテストでの接続の場合など、HTTPでも接続させる場合はこの項目にチェックをつけると許可する事が可能。
今回はテストってことでオンにした。</p>

<p><img src="/images/2016/06/sf_wprest01.jpg" alt="" /></p>

<p>ちなみに、このリモートサイトへの登録をせずにコールアウトしようとすると、以下のようなエラーが出力される。</p>

<blockquote><p>Unauthorized endpoint, please check Setup->Security->Remote site settings. endpoint =xxx</p></blockquote>

<h1>OAuth1.0a認証</h1>

<p>今回は、WP REST API + OAuth 1.0a Server　の設定で投稿するため、OAuth1.0aでの認証になる。<br/>
OAuth 1.0a での認証をするためには、アクセストークンやシグネチャなどの情報をヘッダーに付与してやる必要がある。<br/>
参考: <a href="https://syncer.jp/how-to-make-signature-of-oauth-1">OAuth1.0の署名(Signature)を作成する方法</a></p>

<p>これらの処理をするためのクラスがあったのでこちらを参考にさせてもらった。</p>

<p><a href="https://gist.github.com/surjikal/7539745">Apex 2-legged OAuth 1.0</a></p>

<p>ただし、このままでは足りない情報があったため、アクセストークンなどを送信するように修正させてもらったものが以下となる。</p>

<p><a href="https://gist.github.com/k-usk/894760237c73e47ed4c7333c30ce0b91">k-usk/OAuth.cls</a></p>

<h1>コールアウトを実装</h1>

<p>上記のクラスを利用して実際にコールアウトしてやる。</p>

<p>```
public class PostWPCallout {</p>

<pre><code>@Future(callout=true)
public static void wpCalloutOAuth(){
    String WP_URL = 'http://example.com';
    String client_key = 'IdZQC4OG1Ppi';
    String client_secret = 'S14spr4ny50fN4mjlEfvoBl4d9dWmIyqobp60DvWAD6b0j5g';
    String oauth_token = '1IRo5QV2itt7BSeVA9m14yMQ';
    String oauth_token_secret = 'MPDAnRor5Ajxr7z1N7JF2EOr7vCZqqJE48iYjgolQ1cD0Jm9';

    //リクエストを作成
    HttpRequest req = new HttpRequest();
    req.setMethod('POST');
    req.setEndpoint(WP_URL + '/wp-json/wp/v2/posts'); //新規投稿
    req.setHeader('Content-Type','application/json');
    Map&lt;String,String&gt; mapEmp = new Map&lt;String,String&gt;();
    mapEmp.put('title','タイトル');
    mapEmp.put('content', '本文');
    String jsonString = JSON.serialize(mapEmp);
    req.setBody(jsonString);

    //クラスを利用して、OAuth用のヘッダを作る
    req = OAuth.signRequest(req, client_key, client_secret, oauth_token, oauth_token_secret);

    //コールアウト
    Http http = new Http();
    try{
        HttpResponse res = http.send(req);

        System.debug(Logginglevel.INFO, '*** BODY : ' + res.getBody());
        System.debug(Logginglevel.INFO, '*** STATUS : ' + res.getStatus());
        System.debug(Logginglevel.INFO, '*** STATUS_CODE : ' + res.getStatusCode());
    }catch(System.CalloutException e){
        System.debug(Logginglevel.INFO,'*** ERROR_MESSAGE : ' + e.getMessage());
        System.debug(Logginglevel.INFO,'*** ERROR_LINE_NUMBER : ' + e.getLineNumber());
    }
}
</code></pre>

<p>}
```</p>

<p>コールアウトしたレスポンスがJSONで返ってくるので、投稿した記事IDを取得したい場合はここから取得したりも出来る。<br/>
(JSONでの取得はややこしいので、パースすることになるが）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[WordPress REST APIにOAuth1.0aで認証して投稿する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/06/30/wp-rest-oauth/"/>
    <updated>2016-06-30T17:04:32+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/06/30/wp-rest-oauth</id>
    <content type="html"><![CDATA[<p>WordPress REST APIで投稿するには認証が必要となる。<br/>
認証には、クッキーベース、ベーシック認証ベース、OAuth認証ベース、の方法があるが、
その中でも一番セキュアな、OAuthでの認証を行ってみる。</p>

<!-- more -->


<h1>環境情報など</h1>

<p>試した環境など。</p>

<ul>
<li>PHP 5.6</li>
<li>WordPress ver.4.5.3

<ul>
<li>WP REST API ver.2.0-beta13.1</li>
<li>WP REST API &ndash; OAuth 1.0a Server  ver.0.2.1</li>
</ul>
</li>
<li>ドメイン : <code>http://wprest.local</code></li>
</ul>


<h1>WordPressのセットアップ</h1>

<h2>WP REST API</h2>

<p><a href="https://wordpress.org/plugins/rest-api/">WordPress REST API (Version 2) &mdash; WordPress Plugins</a><br/>
プラグインの新規追加から検索すれば出てくる。
そこからインストールして、有効化すればOK。</p>

<h2>WP REST API &ndash; OAuth 1.0a Server</h2>

<p><a href="https://github.com/WP-API/OAuth1">WP-API/OAuth1: OAuth server implementation for WP API</a><br/>
上記からzipをダウンロードし、<code>プラグイン-&gt;新規追加</code>からzipをアップロードし、その後有効化する。</p>

<p>ユーザー項目に、<code>Applicatons</code>が増えていれば正しく有効化出来ている。<br/>
また、WP REST APIを追加していれば、<code>/wp-json/</code>にアクセスした際にOAuth認証するためのURLが表示されるようになる。</p>

<p>```
authentication: {
  oauth1: {</p>

<pre><code>request: "http://wprest.local/oauth1/request",
authorize: "http://wprest.local/oauth1/authorize",
access: "http://wprest.local/oauth1/access",
version: "0.1"
</code></pre>

<p>  }
},
```</p>

<h2>アプリケーションの追加</h2>

<p><code>ユーザー -&gt; Applications</code>を開き、<code>Add Application</code>をクリック。それぞれの項目を適当に入力する。
<code>Callback</code>の値は適当に<code>/test</code>などと入れておいた。<br/>
本来であれば、承認が行われた後にcallbackで指定されたURLへリダイレクトがかかるはずなのだが、不具合なのか動作しなかった。</p>

<p><code>Add Consumer</code>をクリックすると<code>Client Key</code>と<code>Client Secret</code>が生成される。</p>

<p><img src="/images/2016/06/wp_oauth01.jpg" alt="" /></p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> Client Key </td>
<td align="left"> RY5OpVfznCzY </td>
</tr>
<tr>
<td></td>
<td align="left"> Client Secret </td>
<td align="left"> 8HHflSELMukNNE6NxFNFeJDAsoHA7Dhjkb6wXFoxduMykAwo </td>
</tr>
</tbody>
</table>


<h1>PHPで接続</h1>

<h2>環境変数</h2>

<p>環境変数に上記で取得したアプリケーションのキーなどを追加して使用することにする。</p>

<p><code>
WP_CLIENT_KEY=RY5OpVfznCzY
WP_CLIENT_SECRET=8HHflSELMukNNE6NxFNFeJDAsoHA7Dhjkb6wXFoxduMykAwo
</code></p>

<h2>PECL oauth</h2>

<p><code>Oauth 1.0a</code>での認証を行うために、PECL oauthライブラリを使用する。<br/>
公式のマニュアル: <a href="http://php.net/manual/ja/book.oauth.php">PHP: OAuth &ndash; Manual</a></p>

<blockquote><p>PECL::OAuthは、OAuthコンシューマやプロバイダの機能をphpで手軽に実装できるようにする拡張モジュールです。
<a href="http://blog.flatlabs.net/20100611_062745/">http://blog.flatlabs.net/20100611_062745/</a></p></blockquote>

<p>HerokuでPHPの拡張モジュールを利用する場合には、composerで追加する事が出来る。
以下のコマンドで追加が可能。</p>

<p><code>
$ composer require ext-oauth
</code></p>

<p>参考: <a href="https://devcenter.heroku.com/articles/php-support#extensions">Heroku PHP Support | Heroku Dev Center</a></p>

<p>ローカル環境などのサーバに追加する場合は、直接インストールしてやる必要がある。<br/>
参考: <a href="http://blog.unfindable.net/archives/5697">PECL/oauthの導入方法 | 配電盤</a></p>

<p>今回はローカル環境には、<a href="https://box.scotch.io/">Scotchbox</a>を利用しているので、Ubuntuにインストール方法をメモしておく。</p>

<h3>インストールと設定</h3>

<p>上記参考サイトの通りだが、そのまま<code>oauth</code>をインストールしようとするとバージョンでエラーが出る。
<code>oauth</code>の最新版では、PHP7.0以上のみサポートされているようなので、PHP5.6対応のバージョンを明示的に指定してやる必要がある。</p>

<p><code>
$ sudo apt-get install apache2 php5 php5-dev php-pear libpcre3-dev make
$ sudo pecl install oauth-1.2.3
</code></p>

<p>最後に書かれている通り、<code>php.ini</code>に追記する。<br/>
<code>/etc/php5/apache2/php.ini</code></p>

<p><code>
extension=oauth.so
</code></p>

<p>apache再起動。
<code>
$ sudo service apache2 restart
</code></p>

<p><code>phpinfo</code>でOAuthが有効と表示されていれば完了。</p>

<p><img src="/images/2016/06/wp_oauth02.jpg" alt="" /></p>

<h2>トークンの取得</h2>

<p>今回の承認などに必要なPHPファイルは全て同一ドメイン・同一階層に置くものとする。</p>

<p>OAuth1.0aの承認フローなどの動きは以下がとても参考になった。</p>

<p>参考: <a href="http://nskw-style.com/2016/wordpress/wp-api/oauth1.html">WP REST API の OAuth 認証の方法と何が起こっているのかとなぜそんなことをしているのか &#8211; Shinichi Nishikawa&#039;s</a></p>

<h2>コード</h2>

<p>参考 : <a href="http://qiita.com/newton/items/1114e443a90e204746ad">Tumblr API OAuth認証の方法（PHPサンプル付き） &ndash; Qiita</a></p>

<p>こちらのコードをほぼそのまま利用させてもらった。</p>

<p><code>login.php</code></p>

<p>```
&lt;?php
require_once &lsquo;./OAuthSample.php&rsquo;;</p>

<p>$oauth_sample = new OAuthSample();
try {</p>

<pre><code>// リクエストトークンの取得とリダイレクト開始
$oauth_sample-&gt;goToAuthorize();
</code></pre>

<p>} catch (\Exception $e) {</p>

<pre><code>// エラー処理
</code></pre>

<p>}
```</p>

<p><code>OAuthSample.php</code></p>

<p>```
&lt;?php
/<em>*
 * Tumblr OAuth認証実装サンプル
 *
 * @author newton
 </em>/
class OAuthSample
{</p>

<pre><code>const REQUEST_TOKEN_URL  = 'http://wprest.local/oauth1/request';
const AUTHORIZE_URL      = 'http://wprest.local/oauth1/authorize';
const ACCESS_TOKEN_URL   = 'http://wprest.local/oauth1/access';

public $CONSUMER_KEY = '';
public $CONSUMER_SECRET = '';

/**
 * コントストラク
 * セッションの初期化をやる
 */
public function __construct()
{
    $this-&gt;CONSUMER_KEY = getenv('WP_CLIENT_KEY');
    $this-&gt;CONSUMER_SECRET = getenv('WP_CLIENT_SECRET');

    if (!isset($_SESSION)) {
        session_start();
    }
}

/**
 * リクエストトークンの取得～リダイレクト
 */
public function goToAuthorize()
{
    $oauth = new \OAuth($this-&gt;CONSUMER_KEY, $this-&gt;CONSUMER_SECRET);
    // リクエストトークン取得
    $request_token = $oauth-&gt;getRequestToken(self::REQUEST_TOKEN_URL);

    if (!$request_token) {
        throw new Exception('リクエストトークンの取得に失敗');
    }

    // リクエストトークンをセッションに保存する
    $_SESSION['request_token'] = $request_token['oauth_token'];
    $_SESSION['request_token_secret'] = $request_token['oauth_token_secret'];

    $params = ['oauth_token' =&gt; $request_token['oauth_token']];
    $path = self::AUTHORIZE_URL . '?' . http_build_query($params);

    $this-&gt;redirect($path);
}

/**
 * アクセストークンの取得
 * コールバック後にコールされる用
 *
 * @return array アクセストークンのセットされたハッシュ
 */
public function getAccessToken()
{
    $oauth = new \OAuth(self::CONSUMER_KEY, self::CONSUMER_SECRET);
    // アクセストークンの取得
    $oauth-&gt;setToken($_SESSION['request_token'], $_SESSION['request_token_secret']);
    $access_token = $oauth-&gt;getAccessToken(self::ACCESS_TOKEN_URL, $_GET['oauth_verifier']);

    if (!$access_token) {
        throw new \Exception('アクセストークンの取得に失敗');
    }

    return $access_token;
}

/**
 * リダイレクト
 *
 * @param string $path   リダイレクト先URL
 * @param int    $status ステータスコード
 */
private function redirect($path, $status = 302)
{
    header('Cache-Control: no-store, no-cache, must-revalidate');
    header('Expires: Thu, 01 Jan 1970 00:00:00 GMT');
    header("Location: {$path}", true, $status);
    exit;
}
</code></pre>

<p>}
```</p>

<p><code>callback.php</code></p>

<p>```
&lt;?php
require_once &lsquo;./OAuthSample.php&rsquo;;</p>

<p>$oauth_sample = new OAuthSample();
try {</p>

<pre><code>// アクセストークンの取得
$access_token = $oauth_sample-&gt;getAccessToken();
var_dump($access_token);
</code></pre>

<p>} catch (\Exception $e) {</p>

<pre><code>// エラー処理
</code></pre>

<p>}
```</p>

<h2>承認</h2>

<p>作成した<code>login.php</code>へアクセスすると（ログインしていない場合はログイン画面が表示されログイン後に）承認のページが表示される。</p>

<p><img src="/images/2016/06/wp_oauth03.jpg" alt="" /></p>

<p><code>Authorize</code>をクリックすると、許可されて、承認コードが表示される。
(ここでコードが表示されるのではなく、コールバックURLへリダイレクトが行われるのが通常のフローだと思う）</p>

<p><img src="/images/2016/06/wp_oauth04.jpg" alt="" /></p>

<blockquote><p>Your verification token is j0lHiEOe07gOtUOkEA6J1q00</p></blockquote>

<h2>アクセストークンの取得</h2>

<p>コールバックが自動で行われないので、作成した<code>callback.php</code>へ直接アクセスしてやる。</p>

<blockquote><p><a href="http://wprest.local/callback.php?oauth_verifier=j0lHiEOe07gOtUOkEA6J1q00">http://wprest.local/callback.php?oauth_verifier=j0lHiEOe07gOtUOkEA6J1q00</a></p></blockquote>

<p>こうすることで、アクセストークンを取得できた。</p>

<p><code>
array(2) {
  ["oauth_token"]=&amp;gt;
  string(24) "UTriXsugNS1c0ddCc1UBuMPj"
  ["oauth_token_secret"]=&amp;gt;
  string(48) "6GAHfovkjdSPm2LZbtf06vV3ouBML8WaqiwPIfCGsGY0jVHA"
}
</code></p>

<p>実際に投稿などをPOSTするには、アプリケーションのカスタマーキーなども合わせて必要になる。
まとめると以下となる。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> Client Key </td>
<td align="left"> RY5OpVfznCzY </td>
</tr>
<tr>
<td></td>
<td align="left"> Client Secret </td>
<td align="left"> 8HHflSELMukNNE6NxFNFeJDAsoHA7Dhjkb6wXFoxduMykAwo </td>
</tr>
<tr>
<td></td>
<td align="left"> OAuth Token </td>
<td align="left"> UTriXsugNS1c0ddCc1UBuMPj </td>
</tr>
<tr>
<td></td>
<td align="left"> OAuth Token Secret </td>
<td align="left"> 6GAHfovkjdSPm2LZbtf06vV3ouBML8WaqiwPIfCGsGY0jVHA </td>
</tr>
</tbody>
</table>


<h1>投稿</h1>

<p>さて、ここまででアクセストークンなど投稿に必要なものが一通り揃ったので、ようやく新規投稿の準備が整った。
投稿は簡単で、今までと同じようにトークンなどをセットして指定のエンドポイントへパラメータを投げてやるだけでおｙい。<br/>
エンドポイントは、新規投稿となるので、<code>http://wprest.local/wp-json/wp/v2/posts</code>となる。<br/>
これも、先ほどのTumblerへの投稿を書いた記事を参考にさせてもらった。</p>

<p>```
&lt;?php</p>

<p>$consumer_key = &lsquo;RY5OpVfznCzY&rsquo;;
$consumer_secret = &lsquo;8HHflSELMukNNE6NxFNFeJDAsoHA7Dhjkb6wXFoxduMykAwo&rsquo;;
$oauth_token = &lsquo;UTriXsugNS1c0ddCc1UBuMPj&rsquo;;
$oauth_token_secret = &lsquo;6GAHfovkjdSPm2LZbtf06vV3ouBML8WaqiwPIfCGsGY0jVHA&rsquo;;
$response = &lsquo;&rsquo;;</p>

<p>try {</p>

<pre><code>$oauth = new \OAuth($consumer_key, $consumer_secret);
$oauth-&gt;setToken($oauth_token, $oauth_token_secret);
//POST
$params = ['title' =&gt; 'From PHP'];
$oauth-&gt;fetch('http://wprest.local/wp-json/wp/v2/posts', $params, OAUTH_HTTP_METHOD_POST);
$response_info = $oauth-&gt;getLastResponseInfo();
if ($response_info['http_code'] == 201) {
    $response = json_decode($oauth-&gt;getLastResponse(), true);
}else{
    throw new \Exception('記事の投稿に失敗');
}
</code></pre>

<p>} catch (\Exception $e) {</p>

<pre><code>// エラー処理
var_dump($e);
</code></pre>

<p>}
// 結果をダンプ
var_dump($response);
```</p>

<p>これでこのファイルへアクセスすると、無事、新規投稿が行われる。
以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ローカルのWordPressをCloud9の環境へ引っ越す(DB)]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/11/27/cloud9-wordpress-mysqlimport/"/>
    <updated>2015-11-27T15:30:19+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/11/27/cloud9-wordpress-mysqlimport</id>
    <content type="html"><![CDATA[<p>ローカルで開発していたwordpressをCloud9に移動させるべく、DBのインポートをしてみた。</p>

<!-- more -->


<p>まずはCloud9でWordpressプロジェクトを作成する。<br/>
これは順場に選んでくだけで簡単に可能。</p>

<p><img src="/images/2015/11/c9_00.jpg" alt="" /></p>

<h2>MySqlの起動など</h2>

<p>mysqlの起動などは以下で可能。</p>

<p>```</p>

<h1>起動</h1>

<p>$ mysql-ctl start</p>

<h1>停止</h1>

<p>$ mysql-ctl stop
```</p>

<p><code>mysql-ctl</code>コマンドは以下を実行可能。</p>

<pre><code>[start|restart|stop|status|cli|install]
</code></pre>

<p>以下で、mysqlに入る事が出来る。</p>

<pre><code>$ mysql-ctl cli
...
mysql&gt; 
</code></pre>

<p>もしくは、ユーザー指定で普通にログインも出来る。</p>

<pre><code>$ mysql -u kayakuguri
</code></pre>

<p>この中でデータベースやテーブルを作成したり出来る。<br/>
なので、インポートするDBを作成しておく。</p>

<h2>ダンプファイルのアップロード</h2>

<p>ローカルのファイルをアップするのと同じ手順でダンプしたSQLファイルをアップロードする。<br/>
Cloud9のIDE上から、<code>File -&gt; Upload Local Files...</code>を選択。</p>

<p><img src="/images/2015/11/c9_01.jpg" alt="" /></p>

<p>アップしたいファイルをウインドウにドロップして完了。<br/>
直下にアップした。</p>

<p><img src="/images/2015/11/c9_02.jpg" alt="" /></p>

<h2>インポート</h2>

<p>これで準備は整ったのでダンプファイルをインポートする。<br/>
下部のエリアから、<code>bash</code>タブを選択し、そこにコマンドを打ち込んでいく。</p>

<p>mysqlのユーザー名はCloud9のログイン名と同じで、パスワードはかかっていない。<br/>
なので以下のようになる。</p>

<pre><code>$ mysql -u kayakuguri test_wp_db &lt; dump.sql
</code></pre>

<p><img src="/images/2015/11/c9_03.jpg" alt="" /></p>

<h3>サイトURLの変更</h3>

<p>このままだとローカルのサイトURLがwordpressのURLとして引き継がれてしまうので、コマンドで直接DBのデータをいじって変更してみる。</p>

<pre><code>$ mysql -u kayakuguri
</code></pre>

<p>mysqlにログイン。</p>

<pre><code># DBを選択
mysql&gt; use test_wp_db;
# 現状の設定を確認
mysql&gt; SELECT * FROM wpoptions WHERE option_name='siteurl';
# アップデート
mysql&gt; UPDATE wpoptions SET option_value='https://your-project-kayakuguri.c9users.io' where option_name IN ('home', 'siteurl');
</code></pre>

<p>URLはRUNさせてみると確認出来る。<br/>
(<code>https://プロジェクト名.ユーザー名.c9users.io/</code>っぽい)</p>

<h3>wp-configの変更</h3>

<p>wp-configにて、mysqlのユーザー名を指定していると思うので、それをCloud9用に変更しておく。<br/>
パスワードはいらない。</p>

<p>```
/<em>* MySQL データベースのユーザー名 </em>/
define(&lsquo;DB_USER&rsquo;, &lsquo;kayakuguri&rsquo;);</p>

<p>/<em>* MySQL データベースのパスワード </em>/
define(&lsquo;DB_PASSWORD&rsquo;, &lsquo;&rsquo;);
```</p>

<p>完了。</p>

<h2>注意</h2>

<p>wordpressプロジェクトで始めた場合、<code>wp-admin</code>、<code>wp-content</code>、<code>wp-includes</code>の主要なディレクトリを直下以外のディレクトリに移動が出来なかった。<br/>
なので、ドキュメントルート以外でwordpressを稼働させるプロジェクトの場合は注意が必要。</p>

<p>その場合は、PHPのプロジェクトとして作成し、自前で全ファイルをアップロードしてDBの設定などをすればよいかとも思ったが、どうも上手くいかなかった。<br/>
要調査。</p>

<p>ちなみにPHPの環境は今日現在、<code>PHP Version 5.5.9-1ubuntu4.13</code>だった。</p>

<h2>参考</h2>

<p><a href="https://docs.c9.io/docs/setting-up-mysql">Setting Up MySQL · Cloud9</a><br/>
<a href="http://qiita.com/hishigataBOZE/items/bdd6009d3bfc1c7d313b">[WordPress + MySQL] DBからサイトURLを変更 &ndash; Qiita</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[WordPress] 別のユーザーグループが投稿した記事を編集出来ないようにする]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/11/12/wordpress-usergroup-edit/"/>
    <updated>2015-11-12T15:49:20+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/11/12/wordpress-usergroup-edit</id>
    <content type="html"><![CDATA[<p>ユーザーグループを作成し、別のユーザーグループが作成した記事を別のユーザーグループが編集出来ないように設定してみた。</p>

<!-- more -->


<h2>カスタムユーザー権限の作成</h2>

<p>User Role Editorのプラグインを使用する。<br/>
<a href="https://ja.wordpress.org/plugins/user-role-editor/">https://ja.wordpress.org/plugins/user-role-editor/</a></p>

<p>インストール、有効化するとユーザーのメニュー内に、User Role Editorの項目が追加される。</p>

<p><img src="/images/2015/11/user_group01.jpg" alt="" /></p>

<p>右側メニュー内の<code>Add Role</code>をクリックし、新しく権限を追加する。<br/>
Role name(ID)は英数字で設定しておく。<br/>
Display Role Nameはわかりやすいように日本語でも大丈夫。<br/>
Make copy of で、コピー元の権限があれば選択する。<br/>
今回は投稿者の権限を利用する事にする。</p>

<p><img src="/images/2015/11/user_group02.jpg" alt="" /></p>

<p>もう一つ、white(白組)という権限も作成しておく。</p>

<h2>ユーザーグループの設定</h2>

<p>User Access Managerのプラグインを使用する。<br/>
<a href="https://ja.wordpress.org/plugins/user-access-manager/">https://ja.wordpress.org/plugins/user-access-manager/</a></p>

<p>インストール、有効化するとユーザーのメニュー内に、UAMというメニューが追加される。</p>

<p><img src="/images/2015/11/user_group03.jpg" alt="" /></p>

<p>メニューをクリックするとグループが一つもない状態であれば、Add user groupが表示される状態となる。<br/>
なので、ここでユーザーグループを作成する。</p>

<p><code>User group name</code> はグループ名だが、日本語でも問題なかった。<br/>
<code>User group description</code> はグループの説明。<br/>
<code>IP range</code> はこのグループに属するユーザーのアクセスIPを制限する際に使用する。<br/>
<code>Read access</code> は、このグループが投稿した記事をだれが閲覧できるか、を設定する。<br/>
<code>All</code> にすれば誰でも閲覧可能。<br/>
<code>only group users</code> にすればこのユーザーグループのユーザーしか閲覧が出来ない。<br/>
今回は閲覧は全員可能としたかったので、allにした。<br/>
<code>Write access</code> は、この投稿した記事をだれが編集できるか、を設定する。<br/>
内容はReadと同じ。<br/>
今回は正にここが肝で、作成したユーザーグループ以外のユーザーには編集させないので、 <code>only group users</code> とした。<br/>
<code>Role affiliation</code>は、このユーザーグループに属する権限の設定。<br/>
ここを設定するとユーザーを作成する際に選んだ権限に属するユーザーグループは必ず選ばれるようになる。<br/>
要するに、権限を選べば自動でユーザーグループも指定されるので、設定しておいた方が楽。<br/>
ユーザーグループに入れるユーザーを個別に選びたい場合は外しておけばいいと思う。</p>

<p><img src="/images/2015/11/user_group04.jpg" alt="" /></p>

<p>同じく白組も登録しておく。</p>

<p><img src="/images/2015/11/user_group05.jpg" alt="" /></p>

<h2>ユーザーの追加</h2>

<p>ユーザーを追加する。<br/>
今回の環境が色々カスタマイズしているため未確認だけど、どうやら新規登録の際にはユーザーグループを選択する項目はなさそう。<br/>
とはいえ、権限を選べばグループも設定されるようになっているので問題はなし。<br/>
(権限ロールで、作成した「白組」の権限を選択するのを忘れないように）</p>

<p><img src="/images/2015/11/user_group06.jpg" alt="" /></p>

<p>同様に赤組ユーザーも追加する。<br/>
以下のように、権限ロールを設定しただけで、ユーザーグループも設定されていることがわかる。</p>

<p><img src="/images/2015/11/user_group07.jpg" alt="" /></p>

<h2>記事の投稿</h2>

<p>記事を投稿する。<br/>
この時にその記事を編集可能なユーザーグループを選択するのだけど、<br/>
ユーザーグループに所属しているユーザーで記事を作成しようとするとユーザーグループ選択の項目が表示されない。<br/>
なので、User Access Managerの設定画面で以下の項目を <code>Yes</code> に変更する。</p>

<blockquote><p>UAM &ndash;> Setting &ndash;> Authors settings &ndash;> Authors can add content to their own groups</p></blockquote>

<p><img src="/images/2015/11/user_group08.jpg" alt="" /></p>

<p>右側の列に以下のようなボックスが表示される。<br/>
記事作成の際に、チェックを入れるのを忘れないようにする。<br/>
(忘れてしまうとだれでも編集可能な記事となってしまう）</p>

<p><img src="/images/2015/11/user_group09.jpg" alt="" /></p>

<p>管理者権限でログインして一覧を見ると以下のような状況だが、</p>

<p><img src="/images/2015/11/user_group10.jpg" alt="" /></p>

<p>例えば白組のユーザーでログインして見ると以下のように白組に設定した記事のみが表示される。</p>

<p><img src="/images/2015/11/user_group11.jpg" alt="" /></p>

<h2>まとめ</h2>

<p>これで目的は達成出来た。<br/>
記事投稿する際にグループを選択しないといけない、など少し運用がめんどうになりそうな気配はあるが、<br/>
カスタムでここを触るのは現状不可能そうなので、プラグインでの対応しかなさそう。</p>

<h2>参考</h2>

<p><a href="http://ameblo.jp/signum21/entry-11468274679.html">WordPress会員制サイト構築 その7 User Access Manager｜オレオレWebサービス指南書！ 自分のチカラでサーバー世界を自由に創造するから面白い</a><br/>
<a href="http://ameblo.jp/ifl-nagatsuma-noriyuki/entry-11093035839.html">【WordPress】ユーザーごとに投稿ページ・固定ページの閲覧権限を設定する｜長妻紀之のブログ</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[WordPress]新規ユーザー登録時に選べる権限を制限する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/07/01/wordpress-capabilities/"/>
    <updated>2015-07-01T13:24:37+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/07/01/wordpress-capabilities</id>
    <content type="html"><![CDATA[<p>Wordpressにて、自分に設定されている権限レベル以下の権限のみを取得して、<br/>
新規登録画面で登録出来る権限を制御できるようにしてみた。</p>

<!-- more  -->


<h2>権限一覧の取得</h2>

<p>```
function xx(){</p>

<pre><code>global $wp_roles;
$all_roles = $wp_roles-&gt;roles;
</code></pre>

<p>}
```</p>

<p>出力</p>

<p>```
[(権限名-スラッグ)] => Array</p>

<pre><code>    (
        [name] =&gt; 権限名
        [capabilities] =&gt; Array
            (
                [read] =&gt; 1
                [level_0] =&gt; 1
                権限内容                    
            )

    )
</code></pre>

<p>```</p>

<h2>シリアライズ</h2>

<p>自分に設定されている権限を取得する。<br/>
ただし、DBを直接除くとシリアライズされている。</p>

<p>とはいえ、取得は普通にWPの関数で可能。</p>

<pre><code>get_user_meta(ID, 'wp_capabilities', true);
</code></pre>

<p>セットは以下のように</p>

<pre><code>update_user_meta($user_id, 'wp_capabilities', ['staff' =&gt; 1]);
</code></pre>

<h2>取得</h2>

<h3>自分のレベルを取得</h3>

<p><code>
global $current_user;
$mylevel = $current_user-&gt;user_level;
</code></p>

<p>これで一見取れているようにみえたが、なぜかレベルの低いユーザーもレベルが10と取得されてしまった。<br/>
なので、実際に入っているデータの、<code>level_xx</code>を見て一致させていく泥臭い手法をとった。</p>

<p>```
$uid = wp_get_current_user()&ndash;>get(&lsquo;ID&rsquo;);
//自分のロール
$my_role = get_user_meta($uid, &lsquo;wp_capabilities&rsquo;, true);
$my_role = key($my_role);
$myobj = $wp_roles->role_objects[$my_role]&ndash;>capabilities;
$mylevel = 0;
for($i = 10; $i>=0; $i&mdash;){</p>

<pre><code>if(isset($myobj['level_'.$i]) &amp;&amp; $myobj['level_'.$i]){
    $mylevel = $i;
    break;
}
</code></pre>

<p>}
```</p>

<h3>アクセス可能な権限をレベルで判別</h3>

<p>あとは取得したレベルと、権限の一覧のレベルを比べて、自分の方が大きければ取得していけばよい。</p>

<p>```
global $wp_roles;</p>

<p>$aste_user_role = [];
foreach($wp_roles->role_objects as $key=>$role){</p>

<pre><code>$level = 0;
for($i = 10; $i&gt;=0; $i--){
    if(isset($role-&gt;capabilities['level_'.$i]) &amp;&amp; $role-&gt;capabilities['level_'.$i]){
        $level = $i;
        break;
    }
}
if($mylevel &gt;= $level){
    $aste_user_role[] = [$key, $wp_roles-&gt;role_names[$key]];
}
</code></pre>

<p>}
```</p>

<p>結果</p>

<p>```
array (size=8)
  0 =></p>

<pre><code>array (size=2)
  0 =&gt; string 'administrator' (length=13)
  1 =&gt; string 'システム管理者' (length=21)
</code></pre>

<p>  1 =></p>

<pre><code>array (size=2)
  0 =&gt; string 'staff' (length=5)
  1 =&gt; string 'スタッフ' (length=12)
</code></pre>

<p>  2 =></p>

<pre><code>array (size=2)
</code></pre>

<p>&hellip;
&hellip;
```</p>

<h2>表示</h2>

<h3>新規登録</h3>

<p>新規登録画面への表示は、<code>user_new_form</code>のフックで行う。<br/>
フック内でHTMLを直接書いて対応。</p>

<p>```
//ユーザー登録画面
function user_new_form_css() {</p>

<pre><code>?&gt;
&lt;table class="form-table"&gt;
&lt;tr&gt;
    &lt;th scope="row"&gt;権限ロール &lt;span class="description"&gt;(必須)&lt;/span&gt;&lt;/th&gt;
    &lt;td&gt;&lt;select name="user_role"&gt;
            &lt;?php
            $tempo = '';
            foreach ($aste_user_role as $val) {
                $selected = 'selected';
                if($val[0] == 'subscriber'){
                    $tempo .= '&lt;option value="' . $val[0] . '"' . $selected . '&gt;' . $val[1] . '&lt;/option&gt;';
                }else{
                    $tempo .= '&lt;option value="' . $val[0] . '" &gt;' . $val[1] . '&lt;/option&gt;';
                }
            }
            echo $tempo;
            ?&gt;
        &lt;/select&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;?php
</code></pre>

<p>}
add_action( &lsquo;user_new_form&rsquo;, &lsquo;user_new_form_css&rsquo; );
```</p>

<h3>編集</h3>

<p>編集画面は、<code>personal_options</code>のフックで対応。</p>

<p>```
function add_profile_custom ($profileuser) {</p>

<pre><code>//権限
global $aste_user_role; //自身が参照可能な権限リスト
set_aste_role();
$html = '&lt;tr&gt;&lt;th scope="row"&gt;権限ロール &lt;span class="description"&gt;(必須)&lt;/span&gt;&lt;/th&gt;';
$html .= '&lt;td&gt;&lt;select name="user_role"&gt;';
//このユーザーの権現を取得
$current_role = get_user_meta($profileuser-&gt;ID, 'wp_capabilities', true);
$current_role = key($current_role);
foreach ($aste_user_role as $val) {
    $r = $current_role;
    $selected = '';
    if ($r == $val[0]) {
        $selected = ' selected="selected" ';
    }
    $html .= '&lt;option value="' . $val[0] . '"' . $selected . '&gt;' . $val[1] . '&lt;/option&gt;';
}
$html .= '&lt;/select&gt;&lt;/td&gt;&lt;/tr&gt;';
echo $html;
</code></pre>

<p>}
add_action( &lsquo;personal_options&rsquo;, &lsquo;add_profile_custom&rsquo;);
```</p>

<h2>登録処理</h2>

<p>登録は新規は、<code>user_register</code>、更新は、<code>profile_update</code>。<br/>
どちらも処理としては同じ。<br/>
<code>$_POST</code>から取得した値をシリアライズして入れる、のみ。</p>

<p>```
function save_custom_options_fields( $user_id ) {</p>

<pre><code>//権限ロール
$role_name = $_POST['user_role'];
update_user_meta($user_id, 'wp_capabilities', [$role_name =&gt; 1]);
</code></pre>

<p>}
add_action( &lsquo;profile_update&rsquo;, &lsquo;save_custom_options_fields&rsquo; ); //更新
add_action(&lsquo;user_register&rsquo;, &lsquo;save_custom_options_fields&rsquo;);  //新規登録
```</p>

<h2>既存のものを非表示に</h2>

<p>既存で表示されている権限設定のセレクトボックスを非表示に。</p>

<h3>新規登録</h3>

<p>上記、新規登録で項目を追加したフックと同じ関数内で実装する。<br/>
特定のクラスもIDも振られてないので、x番目と指定して非表示とする。<br/>
ただし、これはCSS3となっているので非対応のブラウザだと見えてしまうと思う。<br/>
他にいい方法があれば知りたい。</p>

<p>```
?><style type="text/css"></p>

<pre><code>table.form-table tr.form-field:nth-of-type(9)
</code></pre>

<p></style>&lt;?php
```</p>

<h3>編集</h3>

<p>上記、編集で項目を追加したフックと同じ関数内で実装する。<br/>
こちらはクラスが振ってあるので、それを指定して非表示とする。</p>

<p>```
?><style type="text/css"></p>

<pre><code>.user-role-wrap, /*権限グループ*/
</code></pre>

<p></style>&lt;?php
```</p>

<h2>まとめ</h2>

<p>これにて完成。<br/>
非表示にする箇所がかなり無理矢理だけれども、なんとか見た目は整った。<br/>
プラグインなどを使えばこの辺一発で出来たりするのだろうか。<br/>
ちなみに、権限の編集にはプラグインを使用した。<br/>
<a href="https://ja.wordpress.org/plugins/user-role-editor/">WordPress &#8250; User Role Editor &laquo; WordPress Plugins</a></p>

<h2>参考</h2>

<p><a href="http://wordpress.stackexchange.com/questions/1665/getting-a-list-of-currently-available-roles-on-a-wordpress-site">security &ndash; Getting a List of Currently Available Roles on a WordPress Site? &ndash; WordPress Development Stack Exchange</a><br/>
<a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q12132319417">wordpressのユーザ権限を管理画面以外から変更する必要があり、～ &ndash; Yahoo!知恵袋</a></p>
]]></content>
  </entry>
  
</feed>
