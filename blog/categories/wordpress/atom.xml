<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: wordpress | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/wordpress/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2015-08-25T10:44:02+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[WordPress]新規ユーザー登録時に選べる権限を制限する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/07/01/wordpress-capabilities/"/>
    <updated>2015-07-01T13:24:37+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/07/01/wordpress-capabilities</id>
    <content type="html"><![CDATA[<p>Wordpressにて、自分に設定されている権限レベル以下の権限のみを取得して、<br/>
新規登録画面で登録出来る権限を制御できるようにしてみた。</p>

<!-- more  -->


<h2>権限一覧の取得</h2>

<p>```
function xx(){</p>

<pre><code>global $wp_roles;
$all_roles = $wp_roles-&gt;roles;
</code></pre>

<p>}
```</p>

<p>出力</p>

<p>```
[(権限名-スラッグ)] => Array</p>

<pre><code>    (
        [name] =&gt; 権限名
        [capabilities] =&gt; Array
            (
                [read] =&gt; 1
                [level_0] =&gt; 1
                権限内容                    
            )

    )
</code></pre>

<p>```</p>

<h2>シリアライズ</h2>

<p>自分に設定されている権限を取得する。<br/>
ただし、DBを直接除くとシリアライズされている。</p>

<p>とはいえ、取得は普通にWPの関数で可能。</p>

<pre><code>get_user_meta(ID, 'wp_capabilities', true);
</code></pre>

<p>セットは以下のように</p>

<pre><code>update_user_meta($user_id, 'wp_capabilities', ['staff' =&gt; 1]);
</code></pre>

<h2>取得</h2>

<h3>自分のレベルを取得</h3>

<p><code>
global $current_user;
$mylevel = $current_user-&gt;user_level;
</code></p>

<p>これで一見取れているようにみえたが、なぜかレベルの低いユーザーもレベルが10と取得されてしまった。<br/>
なので、実際に入っているデータの、<code>level_xx</code>を見て一致させていく泥臭い手法をとった。</p>

<p>```
$uid = wp_get_current_user()&ndash;>get(&lsquo;ID&rsquo;);
//自分のロール
$my_role = get_user_meta($uid, &lsquo;wp_capabilities&rsquo;, true);
$my_role = key($my_role);
$myobj = $wp_roles->role_objects[$my_role]&ndash;>capabilities;
$mylevel = 0;
for($i = 10; $i>=0; $i&mdash;){</p>

<pre><code>if(isset($myobj['level_'.$i]) &amp;&amp; $myobj['level_'.$i]){
    $mylevel = $i;
    break;
}
</code></pre>

<p>}
```</p>

<h3>アクセス可能な権限をレベルで判別</h3>

<p>あとは取得したレベルと、権限の一覧のレベルを比べて、自分の方が大きければ取得していけばよい。</p>

<p>```
global $wp_roles;</p>

<p>$aste_user_role = [];
foreach($wp_roles->role_objects as $key=>$role){</p>

<pre><code>$level = 0;
for($i = 10; $i&gt;=0; $i--){
    if(isset($role-&gt;capabilities['level_'.$i]) &amp;&amp; $role-&gt;capabilities['level_'.$i]){
        $level = $i;
        break;
    }
}
if($mylevel &gt;= $level){
    $aste_user_role[] = [$key, $wp_roles-&gt;role_names[$key]];
}
</code></pre>

<p>}
```</p>

<p>結果</p>

<p>```
array (size=8)
  0 =></p>

<pre><code>array (size=2)
  0 =&gt; string 'administrator' (length=13)
  1 =&gt; string 'システム管理者' (length=21)
</code></pre>

<p>  1 =></p>

<pre><code>array (size=2)
  0 =&gt; string 'staff' (length=5)
  1 =&gt; string 'スタッフ' (length=12)
</code></pre>

<p>  2 =></p>

<pre><code>array (size=2)
</code></pre>

<p>&hellip;
&hellip;
```</p>

<h2>表示</h2>

<h3>新規登録</h3>

<p>新規登録画面への表示は、<code>user_new_form</code>のフックで行う。<br/>
フック内でHTMLを直接書いて対応。</p>

<p>```
//ユーザー登録画面
function user_new_form_css() {</p>

<pre><code>?&gt;
&lt;table class="form-table"&gt;
&lt;tr&gt;
    &lt;th scope="row"&gt;権限ロール &lt;span class="description"&gt;(必須)&lt;/span&gt;&lt;/th&gt;
    &lt;td&gt;&lt;select name="user_role"&gt;
            &lt;?php
            $tempo = '';
            foreach ($aste_user_role as $val) {
                $selected = 'selected';
                if($val[0] == 'subscriber'){
                    $tempo .= '&lt;option value="' . $val[0] . '"' . $selected . '&gt;' . $val[1] . '&lt;/option&gt;';
                }else{
                    $tempo .= '&lt;option value="' . $val[0] . '" &gt;' . $val[1] . '&lt;/option&gt;';
                }
            }
            echo $tempo;
            ?&gt;
        &lt;/select&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;?php
</code></pre>

<p>}
add_action( &lsquo;user_new_form&rsquo;, &lsquo;user_new_form_css&rsquo; );
```</p>

<h3>編集</h3>

<p>編集画面は、<code>personal_options</code>のフックで対応。</p>

<p>```
function add_profile_custom ($profileuser) {</p>

<pre><code>//権限
global $aste_user_role; //自身が参照可能な権限リスト
set_aste_role();
$html = '&lt;tr&gt;&lt;th scope="row"&gt;権限ロール &lt;span class="description"&gt;(必須)&lt;/span&gt;&lt;/th&gt;';
$html .= '&lt;td&gt;&lt;select name="user_role"&gt;';
//このユーザーの権現を取得
$current_role = get_user_meta($profileuser-&gt;ID, 'wp_capabilities', true);
$current_role = key($current_role);
foreach ($aste_user_role as $val) {
    $r = $current_role;
    $selected = '';
    if ($r == $val[0]) {
        $selected = ' selected="selected" ';
    }
    $html .= '&lt;option value="' . $val[0] . '"' . $selected . '&gt;' . $val[1] . '&lt;/option&gt;';
}
$html .= '&lt;/select&gt;&lt;/td&gt;&lt;/tr&gt;';
echo $html;
</code></pre>

<p>}
add_action( &lsquo;personal_options&rsquo;, &lsquo;add_profile_custom&rsquo;);
```</p>

<h2>登録処理</h2>

<p>登録は新規は、<code>user_register</code>、更新は、<code>profile_update</code>。<br/>
どちらも処理としては同じ。<br/>
<code>$_POST</code>から取得した値をシリアライズして入れる、のみ。</p>

<p>```
function save_custom_options_fields( $user_id ) {</p>

<pre><code>//権限ロール
$role_name = $_POST['user_role'];
update_user_meta($user_id, 'wp_capabilities', [$role_name =&gt; 1]);
</code></pre>

<p>}
add_action( &lsquo;profile_update&rsquo;, &lsquo;save_custom_options_fields&rsquo; ); //更新
add_action(&lsquo;user_register&rsquo;, &lsquo;save_custom_options_fields&rsquo;);  //新規登録
```</p>

<h2>既存のものを非表示に</h2>

<p>既存で表示されている権限設定のセレクトボックスを非表示に。</p>

<h3>新規登録</h3>

<p>上記、新規登録で項目を追加したフックと同じ関数内で実装する。<br/>
特定のクラスもIDも振られてないので、x番目と指定して非表示とする。<br/>
ただし、これはCSS3となっているので非対応のブラウザだと見えてしまうと思う。<br/>
他にいい方法があれば知りたい。</p>

<p>```
?><style type="text/css"></p>

<pre><code>table.form-table tr.form-field:nth-of-type(9)
</code></pre>

<p></style>&lt;?php
```</p>

<h3>編集</h3>

<p>上記、編集で項目を追加したフックと同じ関数内で実装する。<br/>
こちらはクラスが振ってあるので、それを指定して非表示とする。</p>

<p>```
?><style type="text/css"></p>

<pre><code>.user-role-wrap, /*権限グループ*/
</code></pre>

<p></style>&lt;?php
```</p>

<h2>まとめ</h2>

<p>これにて完成。<br/>
非表示にする箇所がかなり無理矢理だけれども、なんとか見た目は整った。<br/>
プラグインなどを使えばこの辺一発で出来たりするのだろうか。<br/>
ちなみに、権限の編集にはプラグインを使用した。<br/>
<a href="https://ja.wordpress.org/plugins/user-role-editor/">WordPress &#8250; User Role Editor &laquo; WordPress Plugins</a></p>

<h2>参考</h2>

<p><a href="http://wordpress.stackexchange.com/questions/1665/getting-a-list-of-currently-available-roles-on-a-wordpress-site">security &ndash; Getting a List of Currently Available Roles on a WordPress Site? &ndash; WordPress Development Stack Exchange</a><br/>
<a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q12132319417">wordpressのユーザ権限を管理画面以外から変更する必要があり、～ &ndash; Yahoo!知恵袋</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wordpress上のメディアをcloudinaryに自動アップロードして管理する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/06/30/auto-upload-cloudinary-on-heroku/"/>
    <updated>2015-06-30T12:54:33+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/06/30/auto-upload-cloudinary-on-heroku</id>
    <content type="html"><![CDATA[<p>herokuでwordpressを使用した場合、通常ではアップロードした画像は<br/>
heorkuの再起動のタイミングで全て消えてしまいます。</p>

<!-- more -->


<p>なので、そうならないようにクラウド上のストレージサービスである、cloudinaryに保存させたりします。<br/>
cloudinaryには公式でwordpressのプラグインが用意されています。<br/>
<a href="https://ja.wordpress.org/plugins/cloudinary-image-management-and-manipulation-in-the-cloud-cdn/">WordPress &#8250; Cloudinary &ndash; Image management and manipulation in the cloud + CDN &laquo; WordPress Plugins</a></p>

<p>これを利用することでwordpress上の画像をcloudinaryで管理できるようになるのですが、<br/>
アップロードした画像を手動でcloudinaryに反映させてやらねばなりません。<br/>
それをなんとか自動でアップされるようにしてみました。</p>

<h2>cloudinaryへのアップロード手順(通常)</h2>

<p>通常と同じようにメディアライブラリ上から画像をアップロードします。<br/>
一覧表示で、詳細まで表示される、テーブル表示に切り替えます。<br/>
この時の右端に、<code>Upload to Cloudinary</code>というリンクがあるのでそれをクリックします。</p>

<p><img src="/images/2015/06/cloudinary_heroku01.jpg" alt="" /></p>

<p>するとアップロードされ、表記がアップロード済に変わります。</p>

<p><img src="/images/2015/06/cloudinary_heroku02.jpg" alt="" /></p>

<p>この時に内部では何をしているかと言うと、<br/>
cloudinaryにアップロードし、アップ先のURLを使ってメタデータを書き換え、<br/>
cloudinaryへアップした、というフラグを立てています。<br/>
このフラグを立てているところがポイントになります。</p>

<h2>メタデータ</h2>

<p>wordpressでは画像は投稿データとして管理されています。<br/>
データ構造は以下が詳しいのですが、画像部分だけを引用させてもらうとこんな感じです。<br/>
<a href="http://hijiriworld.com/web/wp-data-register/">WordPress データ登録機構を知ってもっと自由で効率的なフローを  |  hijiriworld Web</a></p>

<p><code>wp_posts</code>テーブル</p>

<table>
<thead>
<tr>
<th>post_title </th>
<th> post_status </th>
<th> post_name </th>
<th> guid </th>
<th> post_type </th>
<th> post_mine_type</th>
</tr>
</thead>
<tbody>
<tr>
<td>{$file_name} </td>
<td> inherit </td>
<td> {$file_name} </td>
<td> {$guid} </td>
<td> attachment </td>
<td> {$mine_type}</td>
</tr>
</tbody>
</table>


<p><code>wp_postmeta</code>テーブル</p>

<table>
<thead>
<tr>
<th>post_id </th>
<th> meta_key </th>
<th> meta_value</th>
</tr>
</thead>
<tbody>
<tr>
<td>{$attachment_id} </td>
<td> _wp_attached_file </td>
<td> {$file_name}</td>
</tr>
<tr>
<td>{$attachment_id} </td>
<td> _wp_attachment_metadata </td>
<td> シリアライズされたメタデータ</td>
</tr>
</tbody>
</table>


<p>wp_postsの方は特に変更する必要はありません。<br/>
重要なのはwp_postmetaのメタデータの方です。</p>

<p>今回、変更する具体的な箇所は以下の２箇所です。<br/>
<code>_wp_attached_file</code>をファイル名からcloudinaryのURLへ変更。<br/>
<code>_wp_attachment_metadata</code>の中にcloudinaryフラグを立てる。</p>

<h2>メディア管理とプラグインの仕組み</h2>

<p>wordpressのメディアは都度URLを動的に生成しています。<br/>
メイン画像の場合は以下。</p>

<blockquote><p>ブログのパス + <code>_wp_attached_file</code>の$file_name</p></blockquote>

<p>サムネイルの場合は以下。</p>

<blockquote><p>ブログのパス + <code>_wp_attachment_metadata</code>の指定サイズのファイル名</p></blockquote>

<p>なのでファイル名にcloudinaryの絶対パスを入れてしまうとURLが２重になってしまいます。</p>

<p>で。<br/>
これが、cloudinaryのフラグが立っているものに関しては、cloudinaryのプラグイン側でURLをうまい具合に置き換えて表示してくれます。<br/>
なので、こちらとしてはフラグを立てるだけ、で大丈夫。</p>

<h2>実作業</h2>

<p>処理の流れは以下のように。</p>

<ol>
<li>画像をアップロード</li>
<li>メタデータ作成のフック内で画像URLを取得</li>
<li>取得したURLでcloudinaryにアップロード</li>
<li>cloudinaryのURLでDBのファイル名を更新</li>
<li>メタデータにフラグを立てる</li>
</ol>


<p><code>wp_generate_attachment_metadata</code>で、アップされたファイルのメタデータを作成する処理にフックをかけられるのでそれを使用します。</p>

<p>functions.phpに以下を記述。</p>

<p>```
function cldnry_wp_generate_attachment_metadata($metadata, $postid){</p>

<pre><code>$imgPath = get_attached_file( $postid );

//ファイル形式のチェック
$info = pathinfo($imgPath);
$public_id = $info["filename"];
$mime_types = array("png"=&gt;"image/png", "jpg"=&gt;"image/jpeg", "pdf"=&gt;"application/pdf", "gif"=&gt;"image/gif", "bmp"=&gt;"image/bmp");
$extension = $info["extension"];
$type = @$mime_types[$extension];
//画像以外はcloudinaryにアップしない
if($type === null){
    $stderr = fopen( 'php://stderr', 'w' );
    fwrite( $stderr, 'アップロードされたファイルが画像ではありません。file-type:'.$extension );
    return $metadata;
}

//Cloudinaryへアップ
$cl_upload = new CloudinaryUploader();
$uploaded = $cl_upload-&gt;upload($imgPath, array(
));
$public_id = $uploaded['public_id'];

//DBへ保存
update_attached_file($postid, $uploaded['secure_url']);
$metadata['cloudinary'] = true; //cloudinaryからアップしたことを記録

return $metadata;
</code></pre>

<p>}
add_filter( &ldquo;wp_generate_attachment_metadata&rdquo; , &ldquo;cldnry_wp_generate_attachment_metadata&rdquo;,10 ,2 );
```</p>

<p>※2015/08/21追記<br/>
cloudinaryへアップする際にpublic_idを指定してしまうと画像が次々と上書きされてしまうので、その部分を削除しました。</p>

<p>  &ldquo;public_id&rdquo; => $public_id,</p>

<p>まず、<code>get_attached_file( $postid )</code>でアップされたファイルのURLを取得。<br/>
そのファイルが画像かどうかを一応チェックしている。<br/>
で、cloudinaryへアップロード。<br/>
cloudinaryはプラグインのファイルから利用するので公式で解説されているコードとは少し異なります。<br/>
で、アップされたらURLをファイル名として保存。<br/>
最後にポイントとなる、フラグを立てて終了。</p>

<p>これだけであとの表示周りの処理はcloudinaryがやってくれます。</p>

<h2>結果</h2>

<p>通常と同じように画像をアップすると、アップ完了時点でcloudinaryへ保存されます。<br/>
以下のようにURLがcloudinaryになっている事が確認できるかと思います。</p>

<p><img src="/images/2015/06/cloudinary_heroku03.jpg" alt="" /></p>

<p>一覧でテーブル表示にすると、cloudinaryにはすでにアップロード済の表記となっています。</p>

<h2>まとめ</h2>

<p>herokuでwordpressを扱う場合、この画像問題がネックの一つとなっているのですが、<br/>
herokuにはcloudinaryのアドオンがあるので、これでとりあえずは解消したのではないでしょうか。<br/>
この解消は自分の中ではかなり大きいです。</p>

<p>使用の際の注意点としては、wordpress上でデータを削除してもcloudinary上からは削除されない、という点です。<br/>
cloudinaryのアップロード容量が決まっているため、メンテナンスが必要かもしれません。</p>

<p>あとはアップデートの問題が解決すればすっきり出来るのですが。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wordpressをherokuにインストールする場合はルーティングのhtaccessを自分で設置すること]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/05/22/heroku-wp-htaccess/"/>
    <updated>2015-05-22T16:11:35+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/05/22/heroku-wp-htaccess</id>
    <content type="html"><![CDATA[<p>タイトルママ。<br/>
ちょっとハマったのでメモ。</p>

<!-- more -->


<h2>WordPressのインストール</h2>

<p>以下の手順で通常通りwordpressをインストールした。</p>

<ol>
<li>herokuにインストール用のアプリを作成</li>
<li>gitでローカルにclone</li>
<li>2のディレクトリ内に<a href="https://ja.wordpress.org/">Wordpress日本語版</a>をダウンロードして展開</li>
<li>herokuのアプリにmySQLのアドオン、<a href="https://addons.heroku.com/cleardb">ClearDB</a>を入れる</li>
<li>環境変数から、DBの接続情報を確認。<br/>
<code>mysql://ユーザ名:パスワード@サーバ名/データベース?reconnect=true</code></li>
<li>wp-config.phpにDB情報を反映</li>
<li>PushしてDploy</li>
<li>wp-admin/install.phpにアクセスして、サイト名やユーザー名などを設定してインストール。</li>
<li>完了</li>
</ol>


<h2>固定ページにアクセス</h2>

<p>通常の投稿でもたぶん同じ事が起こると思うが、<br/>
最初から入っているサンプルの固定ページにアクセス。</p>

<blockquote><p><a href="http://YOUR-APP-NAME.herokuapp.com/sample-page/">http://YOUR-APP-NAME.herokuapp.com/sample-page/</a></p></blockquote>

<p>アクセスを確認してから、特にソースは触らずに<a href="http://kayakuguri.github.io/blog/2015/04/21/git-allow-empty/">空でdeploy</a>。</p>

<p>再度上記の固定ページにアクセスすると、<strong>404 Notfound</strong>。</p>

<h2>ルーティング</h2>

<p>ローカルに入れていたWordPressのディレクトとファイルを見比べていると、<br/>
ローカルのものはドキュメントルートに<code>.htaccess</code>がある。</p>

<p>中身を見ていると、リダイレクトしているよう。</p>

<p>どうやら、wordpressのインストール時に、wordpressのルートにルーティング用の<code>.htaccess</code>を自動で作成するよう。<br/>
それがdeployのタイミングで消えてしまい、リダイレクトがかからず、404となっていた。</p>

<p><code>.htaccess</code>の中身は以下。</p>

<p>```</p>

<h1>BEGIN WordPress</h1>

<p><IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
RewriteRule ^index.php$ &ndash; [L]
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . /index.php [L]
</IfModule></p>

<h1>END WordPress</h1>

<p>```</p>

<p>これを<code>.htaccess</code>の名前でwordpressのルートに保存してやり、git管理下においてやればよい。</p>

<p>これを置いた状態であれば、deployかけても問題なくアクセスが出来た。</p>
]]></content>
  </entry>
  
</feed>
