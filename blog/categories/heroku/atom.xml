<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: heroku | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/heroku/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2015-10-06T18:33:24+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[heroku アドオン]keen.ioで簡単にアクセス解析を入れてみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/10/06/try-keen-io/"/>
    <updated>2015-10-06T17:31:01+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/10/06/try-keen-io</id>
    <content type="html"><![CDATA[<p>簡単なアクセス解析を実装するheroku addonとして、keen.ioなるものがあったので、使って見た。</p>

<!-- more -->


<h2>プラン</h2>

<p>プランはイベントの保存数によって決まっており、月5万イベントまでは無料。</p>

<p><a href="https://addons.heroku.com/keen?utm_campaign=category&amp;utm_medium=dashboard&amp;utm_source=addons#developer">Keen IO | Add-ons | Heroku</a></p>

<p>herokuのaddonページには月、と書いてないけど、公式の方では<code>/Month</code>とあった。<br/>
<a href="https://keen.io/plans/self-service">Self-Service | Keen IO &ndash; Analytics for Developers</a></p>

<p><img src="/images/2015/10/keen01.jpg" alt="" /></p>

<h2>インストール</h2>

<p>環境はPHP。<br/>
composerでインストールする。</p>

<pre><code>$ composer require keen-io/keen-io:~2.5 
</code></pre>

<p>もしくは、composer.jsonに直接追加する。</p>

<p>```
{</p>

<pre><code>"require": {
    "keen-io/keen-io": "~2.5"
}
</code></pre>

<p>}
```</p>

<p><code>composer install</code>でインストール。</p>

<h2>herokuに追加</h2>

<p>Herokuには管理画面から、もしくは、以下のコマンドで追加。</p>

<pre><code>$ heroku addons:create keen
</code></pre>

<p>環境変数に必要な情報が格納される。</p>

<ul>
<li><code>KEEN_PROJECT_ID</code></li>
<li><code>KEEN_WRITE_KEY</code></li>
<li><code>KEEN_READ_KEY</code></li>
</ul>


<h2>利用</h2>

<p>公式のまんまだけど、以下で送信。</p>

<p>```
use KeenIO\Client\KeenIOClient;</p>

<p>$client = KeenIOClient::factory([</p>

<pre><code>'projectId' =&gt; getenv('KEEN_PROJECT_ID'),
'writeKey'  =&gt; getenv('KEEN_WRITE_KEY'),
'readKey'   =&gt; getenv('KEEN_READ_KEY')
</code></pre>

<p>]);</p>

<p>$event = [&lsquo;purchase&rsquo; => [&lsquo;item&rsquo; => &lsquo;Golden Elephant&rsquo;]];
$client->addEvent(&lsquo;purchases&rsquo;, $event);
```</p>

<p><code>purchase</code>は自由に変更可能。<br/>
<code>addEvent</code>の<code>purchases</code>は、Event Collectionの名前。<br/>
送信する内容は日本語も可能。</p>

<h2>取得</h2>

<p>APIで取得も出来るようだけれど、とりあえず管理画面から確認。<br/>
送信された生のJSONは以下のようになる。</p>

<p>```
{</p>

<pre><code>"keen": {
    "timestamp": "2015-10-06T08:19:26.564Z",
    "created_at": "2015-10-06T08:19:26.564Z",
    "id": "5613840e672e6c1748501885"
},
"purchase": {
    "item": "Golden Elephant"
}
</code></pre>

<p>}  <br/>
```</p>

<p><code>Exploer</code>から表示方法を選ぶことでグラフ表示などが可能。<br/>
例えば以下は、<code>purchase</code>の<code>item</code>項目ごとに件数でグルーピングした場合。<br/>
(1件しかないのでわかりにくいけれど）</p>

<p><img src="/images/2015/10/keen02.jpg" alt="" /></p>

<p>切り口は以下の様なものがあるよう。<br/>
<a href="https://keen.io/docs/data-analysis/">Data Analysis | Keen IO</a></p>

<h2>まとめ</h2>

<p>送信や取得のデータの基本がJSONになっているのはプログラム的には扱いやすそう。<br/>
また、簡単な表示であれば管理画面からさくっと出来そうでよさげ。<br/>
CSVの出力も出来た。</p>

<p>お手軽に実装し解析する分にはよさそう。</p>

<h2>参考</h2>

<p><a href="https://addons.heroku.com/keen?utm_campaign=category&amp;utm_medium=dashboard&amp;utm_source=addons#developer">Keen IO | Add-ons | Heroku</a><br/>
<a href="https://github.com/keenlabs/KeenClient-PHP">keenlabs/KeenClient-PHP · GitHub</a><br/>
<a href="http://onori.github.io/post/laravel-keenio-heroku/">laravel&#43;Keen.io&#43;herokuで簡易解析 &middot;  MAN.IN.BLOG</a><br/>
<a href="http://factage.com/2014/02/21/growthhack-analytics-by-keen-io/">Keen IOでグロースハックするための分析をする | yujilog</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[herokuでhtaccessを使ってIPアドレスによる制限を設定する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/10/05/heroku-htaccess-allow-ip/"/>
    <updated>2015-10-05T16:25:49+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/10/05/heroku-htaccess-allow-ip</id>
    <content type="html"><![CDATA[<p>herokuにて構築しているapacheアプリにて、特定のIPからしかアクセス出来ないようにするために、<br/>
htaccessにて制限をかけようとしてたのだけど、どうも上手くいかなくてハマったのでメモ。</p>

<!-- more -->


<p>通常だと、以下のようになる。</p>

<p><code>
order deny,allow
deny from all
allow from 124.xx.xxx.xxx
</code></p>

<p>この場合、制御は、拒否→許可、の順番で、<br/>
まず全て拒否して、<code>124.xx.xxx.xxx</code>からのアクセスのみ許可、という流れ。</p>

<p>しかし、herokuではこれでは上手くいかなかった。</p>

<p>というのも、herokuではサーバー側で負荷分散するためにロードバランサが使用されている。<br/>
(dynoが1の場合でも振り分けはされないけれど利用はされているみたい）<br/>
これによって、実際にアプリに到達するIPアドレスが、アクセス元のIPアドレスからロードバランサを経由したものに変わってしまう。<br/>
しかもそのIPは都度、変わってしまうよう。</p>

<p>これだとIPアドレスによる制限がかけられないのだけど、それを解決する仕組みとして、<br/>
<code>X-FORWARDED-FOR</code> という方法があるらしい。<br/>
<a href="https://ja.wikipedia.org/wiki/X-Forwarded-For">X-Forwarded-For &ndash; Wikipedia</a></p>

<p>それを利用する事で、アクセス元のIPアドレスをロードバランサやプロキシを挟んだとしてもそのままアプリに通知する事が出来るようになるよう。</p>

<p>実際のコードは以下。</p>

<p>```
SetEnvIf X-Forwarded-For 124.xx.xxx.xxx allowip</p>

<p>order deny,allow
deny  from all
allow from env=allowip
```</p>

<p><code>allowip</code>は変数名なのでなんでもよい。<br/>
こうやって記述することで、heroku上でも指定のIPアドレスのみ許可してやることが出来た。</p>

<p>指定のIPアドレスのみ拒否する場合も書き方は同じ。</p>

<p>```
SetEnvIf X-Forwarded-For 124.xx.xxx.xxx denyip</p>

<p>order allow,deny
allow from all
deny from env=denyip
```</p>

<p>複数指定する場合は、変数を複数定義してやるだけで大丈夫だった。</p>

<p>```
SetEnvIf X-Forwarded-For 124.xx.xxx.xxx allowip1
SetEnvIf X-Forwarded-For 196.xx.xxx.xxx allowip2</p>

<p>order deny,allow
deny  from all
allow from env=allowip1
allow from env=allowip2
```</p>

<p>また、これはロードバランサ利用に限った話ではないけれど、IPアドレスの範囲指定をした場合には、<br/>
CIDR(サイダー)形式での表記で書いてやると実現可能。<br/>
以下のツールで厳密な範囲指定をしてやることが出来る。</p>

<p><a href="http://ipvx.info/ipv4/twoip2cidr/">２つのIPアドレス範囲を厳密にCIDR化ツール | IPV46</a></p>

<h2>参考</h2>

<p><a href="http://blog.mizoshiri.com/archives/1753">ロードバランサーやプロキシー経由でも.htaccessでのIPアドレスを制限したい場合</a><br/>
<a href="http://ipvx.info/2015/02/strictly-conv-range-to-cidr/">２つのIPアドレスの範囲をCIDRに厳密に変換するってどういう事？ | IPV46</a></p>

<hr />

<p>ちなみに、herokuアプリから外にアクセスする際のIPアドレスの固定方法は以下を参考に。<br/>
<a href="http://kayakuguri.github.io/blog/2014/09/26/static-ip-heroku/">[heroku]QuotaGuard Staticを使ってHerokuでのIP固定を試してみる</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery File Uploadを利用した大容量ファイルのアップロードをChunked uploadで実現する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/10/01/jquery-chunked-upload/"/>
    <updated>2015-10-01T17:57:05+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/10/01/jquery-chunked-upload</id>
    <content type="html"><![CDATA[<p>大容量のファイルをアップする際に、通常の<code>input type=file</code>で送ろうとすると<br/>
herokuだとタイムアウトになったりして上手くいかなかった。<br/>
なので、jQueryのファイルアップロードプラグインにある、<code>chunk upload</code>を利用してアップした。</p>

<!-- more -->


<p>・Github<br/>
<a href="https://github.com/blueimp/jQuery-File-Upload">blueimp/jQuery-File-Upload</a></p>

<p>公式のjQuery File Uploadのデモは以下。<br/>
<a href="https://blueimp.github.io/jQuery-File-Upload/">https://blueimp.github.io/jQuery-File-Upload/</a></p>

<p>セットアップの流れは以下を参考に。<br/>
<a href="https://github.com/blueimp/jQuery-File-Upload/wiki/Setup">https://github.com/blueimp/jQuery-File-Upload/wiki/Setup</a></p>

<h2>通常のアップロード</h2>

<p>以下から最新バージョンをダウンロード。<br/>
<a href="https://github.com/blueimp/jQuery-File-Upload/releases">https://github.com/blueimp/jQuery-File-Upload/releases</a></p>

<p>解凍して、PHPが動作する環境のドキュメントルートにアップロード。<br/>
そのままアクセスすると動作する。</p>

<p>アップしたファイルは、<br/>
<code>/server/php/files/</code>以下にアップされる。</p>

<h2>Chunk File</h2>

<p>このライブラリによるアップロードの容量制限はありますか？という質問には、一応、4GBです、とのこと。<br/>
これはブラウザの制限のよう。<br/>
ただし、Chunked file upload、という方法を使って、とのこと。</p>

<p><a href="https://github.com/blueimp/jQuery-File-Upload/wiki/Frequently-Asked-Questions#what-is-the-maximum-file-size-limitation">requently Asked Questions · blueimp/jQuery-File-Upload Wiki · GitHub</a></p>

<p>この<code>Chunked file upload</code>という方法は、大きいサイズのファイルを指定したサイズに分割して少しづつアップロードし、アップロード後に合体させる方法、とのこと。<br/>
(特にこのライブラリ特有の話ではないよう。)</p>

<p><a href="https://github.com/blueimp/jQuery-File-Upload/wiki/Chunked-file-uploads">Chunked file uploads · blueimp/jQuery-File-Upload Wiki · GitHub</a></p>

<p>使い方はいたって簡単で、通常の<code>fileupload</code>のオプションに、<code>maxChunkSize</code>の指定を追加するだけ。</p>

<p>例）通常</p>

<pre><code>$('#fileupload').fileupload({
    url: url,
    dataType: 'json'
});
</code></pre>

<p>Chunked upload</p>

<pre><code>$('#fileupload').fileupload({
    maxChunkSize: 20000000,
    url: url,
    dataType: 'json'
});
</code></pre>

<h2>Callback Option</h2>

<p>以下で一覧を参照可能。<br/>
<a href="https://github.com/blueimp/jQuery-File-Upload/wiki/Options#callback-options">Options · blueimp/jQuery-File-Upload Wiki · GitHub</a></p>

<p>Chunked Upload関連では以下のオプションがあった。</p>

<ul>
<li>fileuploadchunksend</li>
<li>fileuploadchunkdone</li>
<li>fileuploadchunkfail</li>
<li>fileuploadchunkalways</li>
</ul>


<p>それぞれ分割したファイルがアップロードされる度に呼び出されるので、結構な回数呼ばれる。</p>

<h2>ソース</h2>

<p>一式全部上げておく。<br/>
アップロードやエラーの処理については以下を参考にさせてもらいました。<br/>
<a href="http://qiita.com/mpyw/items/62e6e415f86eb30a5ff4">JavaScript(jQuery)からPHPのAPIを利用する &ndash; Qiita</a></p>

<p>ファイル構造は以下のようになっている。<br/>
htmlファイル以外はダウンロードしてきたまんま。</p>

<pre><code>public(ドキュメントルート)
└─file_upload
  ├─cors/
  ├─css/
  ├─img/
  ├─js/
  ├─server/
  │   ├─php/
  │   └─files/
  └─chunked_upload.html
</code></pre>

<script src="https://gist.github.com/anonymous/2e523356346040f6758a.js"></script>


<h2>まとめ</h2>

<p>herokuではgit管理でアップしたもの以外はデプロイなどでの再起動時に消えてしまいます。<br/>
なので、これでアップしてもそのまま残っているわけではないのでご注意ください。<br/>
じゃあどうするかというと、一旦アップして、ここからどこかに転送する、とかそういうもののために作成した次第です。<br/>
とはいえ、heroku以外でもchunked uploadを使えば、一時停止やリジュームなど、通信が切れても続きから再開したりとかが出来るようなので、普通のサーバー用途でも便利そう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[heroku]HerokuのclearDBとPostgresでのインポートとエクスポートまとめ]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/09/10/mysql-postgres-import-export/"/>
    <updated>2015-09-10T15:38:34+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/09/10/mysql-postgres-import-export</id>
    <content type="html"><![CDATA[<p>herokuのmysqlとpostgresqlのDBのインポートエクスポートメモ。<br/>
heroku上のDBの中身を別のheroku上のDBへ移行するという前提。</p>

<!-- more -->


<h2>入れ替える情報</h2>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
<th align="left"> 例(clearDB) </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> USER_NAME </td>
<td align="left"> ユーザー名 </td>
<td align="left"> b114d7xxxxxxxb |</td>
</tr>
<tr>
<td></td>
<td align="left"> PASSWORD </td>
<td align="left"> パスワード </td>
<td align="left"> d81xxxxb |</td>
</tr>
<tr>
<td></td>
<td align="left"> HOST </td>
<td align="left"> ホスト名 </td>
<td align="left"> us-cdbr-iron-xxxx-xx.cleardb.net |</td>
</tr>
<tr>
<td></td>
<td align="left"> DB_NAME </td>
<td align="left"> DB名 </td>
<td align="left"> heroku_5f996e9xxxxxxxx |</td>
</tr>
</tbody>
</table>


<p>アプリを指定して実行する場合は、すべてのコマンドのお尻に、<code>--app app_name</code>とつける。</p>

<h2>ClearDB(mySql)</h2>

<h3>情報の構成</h3>

<p>環境変数にて取得可能な情報より。</p>

<pre><code>CLEARDB_DATABASE_URL=mysql://ユーザ名:パスワード@サーバ名/データベース?reconnect=true
</code></pre>

<h3>エクスポート</h3>

<pre><code>$ mysqldump -uUSER_NAME -pPASSWORD -h HOST -r backup.sql --single-transaction DB_NAME
</code></pre>

<h3>インポート</h3>

<pre><code>$ mysql --host=HOST --user=USER_NAME --password=PASSWORD --reconnect DB_NAME &lt; backup.sql
</code></pre>

<h3>参考</h3>

<p><a href="http://pronama.azurewebsites.net/2015/05/05/cleardb-to-azure-vm-mysql/">ClearDB から Azure VM 上の MySQL に移行 | プログラミング生放送</a><br/>
<a href="http://stackoverflow.com/questions/11803496/dump-sql-file-to-cleardb-in-heroku">mysql &ndash; Dump sql file to ClearDB in Heroku &ndash; Stack Overflow</a></p>

<h2>Heroku Postgres</h2>

<h3>概要</h3>

<p>Heroku Postgresに標準搭載されている<code>PG Backups</code>を使用します。</p>

<h3>エクスポート</h3>

<p>バックアップを取る</p>

<pre><code>$ heroku pg:backups capture
Use Ctrl-C at any time to stop monitoring progress; the backup
will continue running. Use heroku pg:backups info to check progress.
Stop a running backup with heroku pg:backups cancel.

DATABASE ---backup---&gt; b002
</code></pre>

<p>URLを取得する</p>

<pre><code>$ heroku pg:backups public-url b002
The following URL will expire at 2015-09-10 07:33:23 +0000:
  "https://xfrtu.s3.amazonaws.com/a53f7aa...."
</code></pre>

<p>ここで取得したS3のURLを、<code>S3_URL</code>とする。</p>

<p>（ダウンロードする場合は以下）</p>

<pre><code>$ curl -o latest.dump 'S3_URL'
</code></pre>

<h3>インポート</h3>

<pre><code>$ heroku pg:backups restore 'S3_URL' DATABASE_URL
</code></pre>

<h3>参考</h3>

<p><a href="https://devcenter.heroku.com/articles/heroku-postgres-import-export">Importing and Exporting Heroku Postgres Databases with PG Backups | Heroku Dev Center</a><br/>
<a href="https://devcenter.heroku.com/articles/heroku-postgres-backups">Heroku PGBackups | Heroku Dev Center</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[herokuがcomposer.lock必須になったのでcomposerの入れ方をメモしておく]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/08/25/composer-lock-require/"/>
    <updated>2015-08-25T10:38:40+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/08/25/composer-lock-require</id>
    <content type="html"><![CDATA[<p>herokuにcomposerを使用したプロジェクトをデプロイする場合、今まではwarningは出ていたようだけど、composer.lockはなくてもデプロイ出来ていた。<br/>
それが、2015/8/21にPHPのランタイムがアップデートされ、composer.lockが必須になった、とのこと。<br/>
<a href="https://devcenter.heroku.com/changelog-items/704">PHP versions 5.5.28, 5.6.12, 7.0.0RC1 available; new composer.lock requirements | Heroku Dev Center</a></p>

<!-- more -->


<p>composer.lockがない場合は以下のようなエラーが出る。</p>

<blockquote><p>ERROR: Your &lsquo;composer.json&rsquo; lists dependencies inside &lsquo;require&rsquo;,but no &lsquo;composer.lock&rsquo; was found. Please run &lsquo;composer update&rsquo; to re-generate &lsquo;composer.lock&rsquo; if necessary, and commit it into your repository. For more information, please refer to the docs at <a href="https://devcenter.heroku.com/articles/php-support#activation">https://devcenter.heroku.com/articles/php-support#activation</a></p></blockquote>

<h2>composerのインストール</h2>

<p>環境はmacで、デフォルト等のPHPが入っている前提で。<br/>
以下のコマンドを適当なディレクトリで叩くだけ。</p>

<p><code>
$ curl -sS https://getcomposer.org/installer | php
$ mv composer.phar /usr/local/bin/composer
</code></p>

<p>ターミナルを再起動して、確認。</p>

<p><code>
$ composer -v
Composer version 1.0-dev (f1aa655e6113e0efa979b8b09d7951a762eaa04c) 2015-08-20 11:59:54
</code></p>

<h3>参考</h3>

<p><a href="http://mawatari.jp/archives/install-composer-in-mac">http://mawatari.jp/archives/install-composer-in-mac</a></p>

<h2>composer install</h2>

<p>この状態で、composer.jsonがあるディレクトリに移動し、<code>$ composer install</code>を叩いてみる。<br/>
これでインストール出来れば完了。<br/>
ただし、PCにインストールされているPHPによってはモジュールの関係でエラーが出る場合がある。<br/>
例）</p>

<blockquote><p>Problem 1<br/>
  &ndash; The requested PHP extension ext-mcrypt * is missing from your system.</p></blockquote>

<p>この場合は、全部入りのPHPを入れ直すのが早い。</p>

<h2>PHPのインストール</h2>

<p>以下のサイトに全部入りのものがまとまっているようなので、そこからインストール。<br/>
<a href="http://php-osx.liip.ch/">PHP for OS X as binary package</a></p>

<p>現時点で最新の5.6を入れる。</p>

<pre><code>$ curl -s http://php-osx.liip.ch/install.sh | bash -s 5.6
</code></pre>

<p>このままだと使用するようにはなってないのでパスを通す。<br/>
環境によって違うが、デフォルトでは、<code>.bash_profile</code>に記述すればよいよう。</p>

<p><code>~/</code>ディレクトリ以下の<code>.bash_profile</code>をエディタ等で開いて記述。<br/>
なければ作成する。<br/>
コマンドで実行する場合は、なければ新規作成としてくれる。<br/>
例えば、<code>vi</code>で開く場合は以下。<br/>
<code>sudo</code>をつけてルート権限で実行している。</p>

<pre><code>$ sudo vi ~/.bash_profile
</code></pre>

<p>以下を記述。</p>

<pre><code>export PATH=/usr/local/php5/bin:$PATH
</code></pre>

<p>保存して終了。<br/>
(viの場合は、<code>i</code>で入力モードに、<code>esc</code>で戻って、<code>:x</code>で保存して終了）<br/>
<a href="http://net-newbie.com/linux/commands/vi.html">ｖｉエディタの使い方</a></p>

<p>ターミナルを再起動してphpのバージョンを確認。</p>

<pre><code>$ php -v
PHP 5.6.11 (cli) (built: Jul 10 2015 21:46:48)
</code></pre>

<h2>composer install</h2>

<p>この状態で、<code>$ composer install</code>すれば完了。<br/>
実行後は実行したディレクトリ内に、<code>composer.lock</code>と<code>vendor/</code>が出来上がる。<br/>
<code>vendor</code>ディレクトリ以下はgitで共有しないように、<code>.gitignore</code>に追記しておくこと。</p>

<h2>.lockと.jsonの関係</h2>

<p><code>composer.json</code>には、必要なパッケージとインストールするバージョンの指定があれば記述する。<br/>
その状態で、<code>$ composer install</code>すると、パッケージがインストールされ、インストールされたパッケージのバージョン情報などが記述された、<code>composer.lock</code>ファイルが作成される。<br/>
この状態で、他環境などで同じく<code>$ composer install</code>すると、<code>composer.lock</code>に書かれたバージョンのパッケージがインストールされ、全く同じ環境が構築される。</p>

<p><code>$ copmoser update</code>をすると、再度<code>composer.json</code>の記述を元にパッケージがインストールされ、<code>composer.lock</code>が更新される。</p>

<h2>参考</h2>

<p><a href="http://qiita.com/nbkn/items/01a11392921119fa0153">MacでPATHを通す &ndash; Qiita</a></p>
]]></content>
  </entry>
  
</feed>
