<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: salesforce | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/salesforce/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2016-09-13T18:10:36+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Salesforce] Let’s Encryptの証明書ではSFからのコールアウトを受けられない]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/08/10/sf-lets-encrypt/"/>
    <updated>2016-08-10T11:49:42+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/08/10/sf-lets-encrypt</id>
    <content type="html"><![CDATA[<p>Let’s Encryptで取得した証明書を適用させたサイトへコールアウトしたところエラーが発生し接続出来なかったので、調査してみた。</p>

<!-- more -->


<h1>エラー内容</h1>

<p>エラーは下記の内容。</p>

<blockquote><p>System.CalloutException: sun.security.validator.ValidatorException: <br/>
PKIX path building failed: <br/>
sun.security.provider.certpath.SunCertPathBuilderException: <br/>
unable to find valid certification path to requested target</p></blockquote>

<p>エラー内容で調べてみると、自己証明書、ではSFからのアクセスが出来ない、という情報があり、その中で紹介されているエラーが上記内容と酷似していることがわかった。</p>

<p><a href="http://appirio.co.jp/category/tech-blog/2013/05/apex%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%A2%E3%82%A6%E3%83%88%E3%81%AE%E3%83%99%E3%82%B9%E3%83%88%E3%83%97%E3%83%A9%E3%82%AF%E3%83%86%E3%82%A3%E3%82%B9part-2/">Apexコールアウトのベストプラクティス:Part 2 &ndash; Appirio Japan</a></p>

<p>しかし、Let’s Encryptは自己証明書ではない…。</p>

<h1>SFが許可するCA</h1>

<p>引き続き調べてみると、どうやらsalesforceは接続出来る認証局 (CA) をホワイトリスト方式で設定しているよう。</p>

<p><a href="https://help.salesforce.com/HTViewSolution?id=000007225&amp;language=en_US">Salesforce.com SSL certificates Salesforce supports</a></p>

<p>以下が許可されている認証局のリスト。</p>

<p><a href="https://developer.salesforce.com/page/Outbound_Messaging_SSL_CA_Certificates">Outbound Messaging SSL CA Certificates &ndash; developer.force.com</a></p>

<p>このリストには、Let’s Encryptがない。<br/>
というわけで、SFがLet’s Encrypt認証局が作成した証明書を適用したサイトへの接続は許可していない、ということになり、冒頭のエラーが発生していた、ということになる。</p>

<p>ちなみに、Let’s Encryptの認証局をリストに加えてほしい、という要望は結構前から上がっているよう。</p>

<p><a href="https://success.salesforce.com/ideaView?id=08730000000E28LAAS">Support Let&rsquo;s Encrypt CA Certificate &ndash; Ideas &ndash; Salesforce Success Community</a></p>

<p>対応する気はないのか、まだ手が回ってないだけなのか…。</p>

<h1>参考</h1>

<ul>
<li><a href="https://jp.globalsign.com/service/knowledge/ca/">認証局 （CA：Certification Authority）とは？ | SSL・電子証明書ならGMOグローバルサイン</a></li>
<li><a href="http://qiita.com/kawaz/items/f90810b9ea823b6556a8">認証局を立ててぼろもうけしたいんですが＞無理な理由を理解しよう &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Salesforce]関連リストのインライン編集をVFで作成する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/07/11/vf-inline-edit/"/>
    <updated>2016-07-11T17:56:11+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/07/11/vf-inline-edit</id>
    <content type="html"><![CDATA[<p>オブジェクトの詳細で表示される関連リスト部分、要するにそのレコードを参照しているレコード、を一覧表示からインライン編集出来るようにしたかったので、インライン編集の基本的な部分から調べてみた。</p>

<!-- more -->


<h1>参考</h1>

<ul>
<li><a href="https://developer.salesforce.com/docs/atlas.ja-jp.pages.meta/pages/pages_quick_start_inline_editing.htm">インライン編集の有効化 Visualforce開発者ガイド</a></li>
</ul>


<h1>詳細レコード</h1>

<p>該当のレコードの詳細を表示し、表示している項目をインライン編集出来るようにする。</p>

<p>作成しているVFページのURLにて、IDが指定されている + 指定されている<code>standardController</code>のオブジェクトであれば、Visualforceだけで表示させることが可能。</p>

<blockquote><p><a href="https://Salesforce_instance/apex/myPage?id=001x000xxx3Jsxb">https://Salesforce_instance/apex/myPage?id=001x000xxx3Jsxb</a></p></blockquote>

<p>この場合、IDが<code>001x000xxx3Jsxb</code>の取引先(<code>Account</code>)が表示される。<br/>
<code>apex:detail</code>タグを使うと、このレコードの詳細がそのまま表示される。<br/>
その際に、属性<code>inlineEdit</code>を<code>true</code>で指定するとインライン編集が可能となる。</p>

<p>```
&lt;apex:page standardController=&ldquo;Account&rdquo;></p>

<pre><code>    &lt;apex:detail subject="{!account.Id}" relatedList="false" inlineEdit="true"/&gt; 
</code></pre>

<p>&lt;/apex:page>
```</p>

<p>特定のレコードの詳細をそのまま表示したい時とかには便利。</p>

<h1>一覧表示</h1>

<p>詳細ではなく、一覧表示で複数件いっぺんに編集したい場合。
<code>apex:page</code>の属性で、<code>recordSetVar</code>を指定してやれば、<code>standardController</code>で指定したオブジェクトのリストを表示出来る。</p>

<p><a href="http://qiita.com/tyoshikawa1106/items/4ef3b8e1998609f2c573">standardControllerとrecordSetVar &ndash; Qiita</a></p>

<p>```
&lt;apex:page standardController=&ldquo;Account&rdquo; recordSetVar=&ldquo;records&rdquo; id=&ldquo;thePage&rdquo;></p>

<pre><code>&lt;apex:form id="theForm"&gt; 
    &lt;apex:pageBlock id="thePageBlock"&gt; 
        &lt;apex:pageBlockTable value="{!records}" var="record" id="thePageBlockTable"&gt; 
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!record.Name}" id="AccountNameDOM" /&gt; 
                &lt;apex:facet name="header"&gt;Name&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!record.Type}" id="AccountTypeDOM" /&gt; 
                &lt;apex:facet name="header"&gt;Type&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!record.Industry}" 
                    id="AccountIndustryDOM" /&gt;  
                    &lt;apex:facet name="header"&gt;Industry&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:inlineEditSupport event="ondblClick" 
                    showOnEdit="saveButton,cancelButton" hideOnEdit="editButton" /&gt; 
        &lt;/apex:pageBlockTable&gt; 
        &lt;apex:pageBlockButtons &gt; 
            &lt;apex:commandButton value="Edit" action="{!save}" id="editButton" /&gt;
            &lt;apex:commandButton value="Save" action="{!save}" id="saveButton" /&gt;
            &lt;apex:commandButton value="Cancel" action="{!cancel}" id="cancelButton" /&gt;
        &lt;/apex:pageBlockButtons&gt; 
    &lt;/apex:pageBlock&gt; 
&lt;/apex:form&gt;
</code></pre>

<p>&lt;/apex:page>
```</p>

<p>コードは公式ドキュメントのママ。<br/>
formなど各タグ内のIDは別にあってもなくてもよさそう。</p>

<p>以下のように表示される。</p>

<p><img src="/images/2016/07/sf_inline01.jpg" alt="" /></p>

<p><code>apex:column</code>で囲まれてた部分が1つの項目になっており、<code>&lt;apex:facet name="header"&gt;</code>タグの内容がそれぞれの項目の見出しとなる。</p>

<p>このままページを表示してインライン編集後、saveボタンをクリックすると確かに更新はされるがホームへ遷移してしまう。
(キャンセルをクリックしても同様)</p>

<p>これを解消するために、カスタムコントローラーを割り当ててみた。<br/>
<code>recordSetVar</code>を使っていると、割り当てたカスタムコントローラ側で取得したレコードリストを使用するために、<code>StandardSetController</code>を使う必要がある、とのこと。</p>

<p><a href="http://tyoshikawa1106.hatenablog.com/entry/2013/09/03/232942">SFDC：recordSetVarとextensions &ndash; tyoshikawa1106のブログ</a></p>

<p>これを、<code>StandardController</code>をコントローラ側で使っていると下記のようなエラーがでる。
エラーメッセージだけでは非常にわかりにくそうなので注意。</p>

<blockquote><p>common.apex.runtime.bytecode.BytecodeApexObjectType cannot be cast to common.apex.runtime.impl.ApexType</p></blockquote>

<p>で、カスタムコントローラ内で、ボタンを押された際のアクションを作成し、<code>null</code>を返す事でページ遷移をしないようにする。<br/>
ただし、保存する<code>save</code>ボタンはこれをしてしまうと保存されなくなってしまったので、キャンセルボタンだけにしておいた。</p>

<p>VF</p>

<p><code>
&lt;apex:page standardController="Account" recordSetVar="records" extensions="VfInlineEditSample" id="thePage"&gt;
</code></p>

<p>apex (<code>VfInlineEditSample.apxc</code>)</p>

<p>```
public class VfInlineEditSample {</p>

<pre><code>public VfInlineEditSample(ApexPages.StandardSetController stdController){
    List&lt;Account&gt; lists = (List&lt;Account&gt;)stdController.getRecords();
}

public PageReference cancel(){
    return null;
}
</code></pre>

<p>}
```</p>

<p><a href="http://www.developerforce.com/guides/fr/apex_fr/Content/apex_pages_standardsetcontroller.htm">Classe StandardSetController</a></p>

<h1>関連リスト</h1>

<p>とあるレコードの関連リストを一覧表示からインライン編集したい場合。<br/>
上記の一覧表示と同じようにすればインライン編集出来るテーブルを作る事は可能。</p>

<p>IDはVFページのパラメータから取得する。</p>

<p>例）<br/>
<code>VfInlineEditSamplePage.vfp</code></p>

<p>```
&lt;apex:page standardController=&ldquo;Account&rdquo; extensions=&ldquo;VfInlineEditSample&rdquo; id=&ldquo;thePage&rdquo;></p>

<pre><code>&lt;apex:form id="theForm"&gt; 
    &lt;apex:pageBlock title="商談" &gt;
        &lt;apex:pageBlockTable value="{!opp_records}" var="opp"&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.Name}" /&gt; 
                &lt;apex:facet name="header"&gt;商談名&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.Amount}" /&gt; 
                &lt;apex:facet name="header"&gt;金額&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.StageName}" /&gt; 
                &lt;apex:facet name="header"&gt;フェーズ&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.NextStep}" /&gt; 
                &lt;apex:facet name="header"&gt;次回アクション&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:inlineEditSupport event="ondblClick" /&gt;
        &lt;/apex:pageBlockTable&gt; 
        &lt;apex:pageBlockButtons &gt; 
            &lt;apex:commandButton value="Save" action="{!save}" /&gt;
            &lt;apex:commandButton value="Cancel" action="{!cancel}" /&gt;
        &lt;/apex:pageBlockButtons&gt; 
    &lt;/apex:pageBlock&gt; 
&lt;/apex:form&gt;
</code></pre>

<p>&lt;/apex:page>
```</p>

<p><code>VfInlineEditSample.apxc</code></p>

<p>```
public class VfInlineEditSample {</p>

<pre><code>public List&lt;Opportunity&gt; opp_records{get; set;}

public VfInlineEditSample(ApexPages.StandardController stdController){
    Account acc = (Account)stdController.getRecord();
    Id aid = acc.id;
    Account record = [SELECT id, name, (SELECT id,name,StageName,NextStep,Amount FROM Opportunities) FROM Account WHERE id=:aid];
    opp_records = record.Opportunities;
}

public PageReference cancel(){
    return null;
}
</code></pre>

<p>}
```</p>

<p>以下のようになる。</p>

<p><img src="/images/2016/07/sf_inline02.jpg" alt="" /></p>

<p>このままだとSaveをクリックしても保存はされない。<br/>
なので、cancelと同じようにカスタムコントローラ内でアクションを受け取り、編集した内容はVFへ引き渡している、 <code>opp_records</code>に入っているので、それをupdateすれば更新される。</p>

<p>apexクラスに以下を追加。</p>

<p>```
public PageReference save(){</p>

<pre><code>update opp_records;
return null;
</code></pre>

<p>}
```</p>

<p>しかしこうすると、編集されたされてないにかかわらず、関連リストに並んでいるオブジェクト(この場合は商談)のレコード全てが更新されてしまう。<br/>
ガバナ制限は、1万レコードまで大丈夫なので、問題になることは少ないと思うが、最終更新日付が全て更新されてしまうのが都合が悪いかもしれない。</p>

<p><a href="https://developer.salesforce.com/docs/atlas.ja-jp.salesforce_app_limits_cheatsheet.meta/salesforce_app_limits_cheatsheet/salesforce_app_limits_platform_apexgov.htm">Apex ガバナ制限</a></p>

<h2>更新対象を選ぶ</h2>

<p>ワークフローであれば、<code>ISCHANGED</code>を使えば、その項目が変更されたかどうかをチェック出来るが、apexではそのメソッドはない。<br/>
(機能追加が要望があがってたりする(トリガの機能としてだけど） <a href="https://success.salesforce.com/ideaview?id=087300000007LI2AAM">IsChanged function in Apex</a>)</p>

<p>なので、更新される項目を一つずつ比較して更新があるかどうかを確認する泥臭い方法を取ってみる。<br/>
(他にいいアイデアがあれば教えて欲しい…）</p>

<p>修正後のapex</p>

<p>```
public class VfInlineEditSample {</p>

<pre><code>public List&lt;Opportunity&gt; opp_records{get; set;}
private List&lt;Opportunity&gt; old_records;

public VfInlineEditSample(ApexPages.StandardController stdController){
    Account acc = (Account)stdController.getRecord();
    Id aid = acc.id;
    Account record = [SELECT id, name, (SELECT id,name,StageName,NextStep,Amount FROM Opportunities) FROM Account WHERE id=:aid];
    opp_records = record.Opportunities;
    old_records = opp_records.deepClone();
}

public PageReference cancel(){
    return null;
}

public PageReference save(){
    List&lt;Opportunity&gt; update_lists = new List&lt;Opportunity&gt;();
    for(Integer i = 0; i&lt; opp_records.size(); i++){
        if(opp_records[i].name != old_records[i].name){
            update_lists.add(opp_records[i]);
            continue;
        }else if(opp_records[i].StageName != old_records[i].StageName){
            update_lists.add(opp_records[i]);
            continue;
        }else if(opp_records[i].NextStep != old_records[i].NextStep){
            update_lists.add(opp_records[i]);
            continue;
        }else if(opp_records[i].Amount != old_records[i].Amount){
            update_lists.add(opp_records[i]);
            continue;
        }
    }

    if(update_lists.size() &gt; 0){
        update update_lists;
    }

    return null;
}
</code></pre>

<p>}
```</p>

<p>リストをコピーする際に、<code>deepClone</code>を使わないと<code>clone</code>では浅いコピーとなってしまい、参照しているものが同じになってしまうので注意。
(一方の値を更新するともう一方も同じ値になってしまう）</p>

<h2>汎用的にする</h2>

<p>上記だと、表示する項目を増やす度に比較の条件文を追加しないといけない。<br/>
なので、全項目から取得出来るものだけを比較するようにしてみた。</p>

<p>以下、関数。</p>

<p>```
public List<sObject> isChanged(String object_name, List<sObject> new_records, List<sObject> old_records){</p>

<pre><code>sObject obj = (sObject)Type.forName(object_name).newInstance();
Schema.DescribeSObjectResult descR = obj.getsObjectType().getDescribe();
Set&lt;String&gt; fields = descR.fields.getMap().keySet();
Map&lt;String, Schema.SObjectField&gt; fmap = descR.fields.getMap();

List&lt;sObject&gt; update_records = new List&lt;sObject&gt;();
for(Integer i = 0; i&lt; new_records.size(); i++){
    for(String field : fields){
        try{
            Schema.SObjectField f = fmap.get(field);
            Schema.DescribeFieldResult fr = f.getDescribe();
            if(!fr.isUpdateable()) continue; //更新出来ない項目は飛ばす
            //比較
            if(new_records[i].get(field) != old_records[i].get(field)){
                update_records.add(new_records[i]);
                continue;
            }
        }catch(SObjectException e){
            //取得していない項目
        }
    }
}

return update_records;
</code></pre>

<p>}
```</p>

<ul>
<li><code>getDescribe()</code>で指定したオブジェクトの全項目名を取得出来る</li>
<li>取得した項目名を使ってオブジェクトから<code>get()</code>で取得。例外が発生したものはselectで取得していない項目、となる</li>
<li>更新可能かどうかは、<code>Describe</code>で取得出来る項目の情報内を見れば判定可能<br/>
<code>isUpdateable</code>がtrueなら更新が出来る項目となるので、これがtrueのもののみ比較している</li>
</ul>


<p>使用の際は、第一引数にオブジェクトの参照名、第二引数に更新後のレコードリスト、第三引数に更新前のレコードリストを指定してやる。</p>

<p><code>
List&lt;Opportunity&gt; update_lists = isChanged('Opportunity', opp_records, old_records);
</code></p>

<p>これで項目が増えても安心。</p>

<h3>参考</h3>

<ul>
<li><a href="http://kayakuguri.github.io/blog/2014/04/23/sf-mailtemplate/">[SalesForce]メールテンプレートの項目一覧 &ndash; KayaMemo</a></li>
<li><a href="http://appirio.co.jp/category/tech-blog/2012/07/force-com-apex%E3%81%AE%E3%80%8Cdescribe%E3%80%8D%E3%81%A7%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%EF%BC%88%E3%81%9D%E3%81%AE%EF%BC%91%EF%BC%89/">Force.com Apexの「Describe」でできること（その１） &ndash; Appirio Japan</a></li>
<li><a href="http://appirio.co.jp/category/tech-blog/2012/09/force-com-apex%E3%81%AE%E3%80%8Cdescribe%E3%80%8D%E3%81%A7%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%EF%BC%88%E3%81%9D%E3%81%AE%EF%BC%92%EF%BC%89/">Force.com Apexの「Describe」でできること（その２） &ndash; Appirio Japan</a></li>
<li><a href="http://vaindespair.blogspot.jp/2012/04/blog-post_04.html">memo: Force.com&#12288;&#65306;&#12288;Apex でオブジェクト及び項目の情報を取得する</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[PHP]CurlでのSSL接続をOpenSSL方式に変更する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/07/07/curl-openssl-tls/"/>
    <updated>2016-07-07T17:50:07+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/07/07/curl-openssl-tls</id>
    <content type="html"><![CDATA[<p>curlでsslを接続する際に、opensslを利用した接続になっていなかったために接続出来ない事例があったのだが、curlを入れ替えてopensslを利用するようにしたら接続出来たのでそのメモ。</p>

<!-- more -->


<h1>前提</h1>

<p>接続をしている環境は以下とする。</p>

<ul>
<li>CnetOS 5.6</li>
<li>PHP 5.3</li>
</ul>


<p>この環境で、SalesforceへRestAPIを利用して接続をする。<br/>
接続する際の認証は以下のクラスを利用している。</p>

<ul>
<li><a href="https://github.com/nkjm/Force.com-OAuth-Toolkit-for-PHP">nkjm/Force.com-OAuth-Toolkit-for-PHP: A toolkit to enable OAuth in external Web Services developed in php</a></li>
</ul>


<p>自作の <code>/sample/login</code>のエンドポイントへ接続するものとする。<br/>
接続に利用しているPHP。</p>

<p>```
&lt;?php
require_once(&lsquo;oauth.php&rsquo;);</p>

<p>define(&lsquo;CLIENT_ID&rsquo;, &lsquo;xxx&rsquo;);
define(&lsquo;CLIENT_SECRET&rsquo;, &lsquo;xxx&rsquo;);
define(&lsquo;CALLBACK_URL&rsquo;, &lsquo;<a href="http://localhost/">http://localhost/</a>&rsquo;);
define(&lsquo;LOGIN_URL&rsquo;, &lsquo;<a href="https://test.salesforce.com">https://test.salesforce.com</a>&rsquo;);
define(&lsquo;USERNAME&rsquo;, &lsquo;xxx&rsquo;);
define(&lsquo;PASSWORD&rsquo;, &lsquo;xxx&rsquo;);</p>

<p>$oauth = new oauth(CLIENT_ID, CLIENT_SECRET, CALLBACK_URL, LOGIN_URL);
$oauth->auth_with_password(USERNAME, PASSWORD, 120);
$url = &ldquo;$oauth->instance_url/services/apexrest/sample/login&rdquo;;
$curl = curl_init($url);
$POST_DATA = array(</p>

<pre><code>'email' =&gt; 'sample',
'passwd' =&gt; 'password'
</code></pre>

<p>);</p>

<p>curl_setopt($curl, CURLOPT_POST, TRUE);
curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($POST_DATA));
curl_setopt($curl, CURLOPT_HEADER, false);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
curl_setopt($curl, CURLOPT_HTTPHEADER, array(&lsquo;Content-type: application/x-www-form-urlencoded;charset=UTF-8&rsquo;, &ldquo;Authorization: OAuth &rdquo; . $oauth->access_token));
$output= curl_exec($curl);
curl_close($curl);
$response = json_decode($output, true);</p>

<p>echo $output;
```</p>

<p>この辺詳しくは以下をどうぞ。<br/>
<a href="http://kayakuguri.github.io/blog/2014/10/27/apex-rest-post/">[Salesforce]apex Rest APIでPOSTでデータを送信する</a></p>

<h1>失敗する</h1>

<p>このまま送信をすると、以下のようなエラーが出て失敗する。<br/>
ちなみに、ログイン履歴には残っている。</p>

<p>```
[</p>

<pre><code>{
    message: "この組織では TLS 1.0 が無効になりました。HTTPS を使用して Salesforce に接続するには、TLS 1.1 以降を使用してください。",
    errorCode: "UNSUPPORTED_CLIENT"
}
</code></pre>

<p>]
```</p>

<h1>TLS</h1>

<p>ssl通信をする時の暗号化規格で、TLS1.0は暗号化のレベルが低い、とかで1.1以上が推奨されているよう。<br/>
<a href="http://www.intellilink.co.jp/article/pcidss/18.html">SSL/TLS 1.0 はいつまでに無効化しなければならないか？ | NTTデータ先端技術株式会社</a><br/>
それに伴って、Salesforceでは、TLS1.0での接続を無効に切り替えていっている。<br/>
変更内容など詳しくは公式で。</p>

<ul>
<li><a href="https://help.salesforce.com/apex/HTViewSolution?id=000221207&amp;language=ja">Salesforce による TLS 1.0 の無効化</a></li>
</ul>


<p>組織の設定から明示的に有効にする事も可能だが、強制的に切り替えが行われるタイミングは以下。</p>

<ul>
<li>Sandbox 組織 &ndash; 2016 年 6 月 25 日、午前 9:30 (太平洋夏時間) (16:30 UTC)</li>
<li>本番組織 &ndash; 2017 年 3 月 4 日、午前 9:30 (太平洋標準時) (17:30 UTC)</li>
</ul>


<p>今回は、Sandboxでの設定が適用されたために接続が出来なくなったよう。</p>

<p>ちなみにTLSについて調べていて、現状、SSLと呼んでいるものは全てTLSによる接続になっているらしい。</p>

<blockquote><p>SSLはバージョン1.0と2.0は既に脆弱性で消えていたが、2014(平成26)年10月14日、GoogleのセキュリティチームによりSSL 3.0の深刻な脆弱性「POODLE」が発見されたことでSSLは全バージョンに脆弱性が発覚、これをもってSSLは現役を退いた。<br/>
<a href="http://www.wdic.org/w/WDIC/TLS">http://www.wdic.org/w/WDIC/TLS</a></p></blockquote>

<h1>原因</h1>

<p>上記環境で原因を探ってみると、<code>curl</code>でエンドポイントへ投げる際に<code>NSS</code>という方式が使われている事が原因となっている事がわかった。</p>

<p><img src="/images/2016/07/tls01.jpg" alt="" /></p>

<p><a href="https://developer.mozilla.org/ja/docs/NSS_FAQ">NSS FAQ | MDN</a></p>

<p>NSSのバージョンは3.14だが、このバージョンでは一応TLS1.1には対応しているとリリースノートには書かれていたが…。詳細は不明。<br/>
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/NSS_3.14_release_notes">NSS 3.14 release notes &ndash; Mozilla | MDN</a></p>

<h1>対処</h1>

<p>というわけで、これを<code>NSS</code>ではなく、<code>OpenSSL</code>方式で接続するように変更する。<br/>
といっても、設定変更で済むわけではなく、curlのインストールし直し、となる。</p>

<p>作業内容は以下のサイトをそのまま利用させてもらった。<br/>
<a href="http://www.apollo.jp/blog/?p=2382">wordpressの引っ越し | 紅い夕陽</a></p>

<h2>作業</h2>

<p>サーバー側での作業となる。<br/>
今回はvagrant環境で作業をしたので、<code>$ vagrant ssh</code>でsshログインして作業した。<br/>
また、ルートログインしておく。</p>

<p>・必要なモジュールをインストール</p>

<p>```</p>

<h1>yum install gcc</h1>

<h1>yum -y install openssl-devel</h1>

<h1>yum -y install wget</h1>

<h1>yum -y install lbzip2</h1>

<p>```</p>

<p>・curlを取得して展開(curlは少し前のバージョン)</p>

<p>```</p>

<h1>wget <a href="http://curl.haxx.se/download/curl-7.37.0.tar.bz2">http://curl.haxx.se/download/curl-7.37.0.tar.bz2</a></h1>

<h1>tar xf curl-7.37.0.tar.bz2</h1>

<h1>cd curl-7.37.0</h1>

<h1>./configure &mdash;enable-libcurl-option</h1>

<p>```</p>

<p>・コンパイルしてインストール</p>

<p>```</p>

<h1>make</h1>

<h1>make install</h1>

<p>```</p>

<p>・ライブラリを登録</p>

<p>```</p>

<h1>vi /etc/ld.so.conf.d/curl-x86_64.conf</h1>

<p>```</p>

<p>内容</p>

<p><code>
/usr/local/lib
</code></p>

<p>・ライブラリを更新</p>

<p>```</p>

<h1>ldconfig -v</h1>

<p>```</p>

<p>最後に、apacheを再起動しておく。</p>

<p>```</p>

<h1>service httpd restart</h1>

<p>```</p>

<p>これでOpensslを使うように変更できた。</p>

<p><img src="/images/2016/07/tls02.jpg" alt="" /></p>

<p>この状態で再度冒頭のPHPでアクセスすると、無事、接続することが出来た。</p>

<h1>参考</h1>

<ul>
<li><a href="http://www.apollo.jp/blog/?p=2382">wordpressの引っ越し | 紅い夕陽</a></li>
<li><a href="http://blog.wnotes.net/blog/article/php_curl_error">PHPのcurlで&quot;SSL Connection Error.&quot;のエラーがどうしても出る時の対策 | ブログ :: Web notes.log</a></li>
<li><a href="http://www.wdic.org/w/WDIC/TLS">TLS ‐ 通信用語の基礎知識</a></li>
<li><a href="http://www.intellilink.co.jp/article/pcidss/18.html">SSL/TLS 1.0 はいつまでに無効化しなければならないか？ | NTTデータ先端技術株式会社</a></li>
<li><a href="http://tkengo.github.io/blog/2015/12/01/https-details/">理解してるつもりの SSL/TLS でも、もっと理解したら面白かった話 &middot; けんごのお屋敷</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SalesforceからWP REST APIへOAuth認証を利用して投稿する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/06/30/sf-callout-wp-rest-api-oauth1/"/>
    <updated>2016-06-30T17:36:44+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/06/30/sf-callout-wp-rest-api-oauth1</id>
    <content type="html"><![CDATA[<p>salesforceからWP REST APIのエンドポイントへコールアウトして投稿する。<br/>
投稿の際には、OAuth認証を利用する。</p>

<!-- more -->


<h1>前提</h1>

<p>WordPress側にで、OAuth 1.0a Serverを導入してアプリケーションを作成しておく。<br/>
また、そのアプリケーションを使用して、アクセストークンまで取得しているものとする。</p>

<p>通常は承認のフローなどはユーザー側が行うため、アクセストークンまでもった状態からスタートすることはないと思うが、今回は最後の投稿部分だけに絞って試してみた。</p>

<p>WP REST APIでアクセストークンを取得するには、前回書いたこの記事を参考にどうぞ。<br/>
<a href="http://kayakuguri.github.io/blog/2016/06/30/wp-rest-oauth/">WordPress REST APIにOAuth1.0aで認証して投稿する &ndash; KayaMemo</a></p>

<h1>リモートサイトの登録</h1>

<p>コールアウトする先のドメインを事前に許可しておいてやる必要がある。<br/>
<code>設定 -&gt; セキュリティのコントロール -&gt; リモートサイトの設定</code> から、<code>新規リモートサイト</code>をクリック。</p>

<ul>
<li>リモートサイト名 : 適当な名前</li>
<li>リモートさサイトのURL : 接続先ドメイン</li>
<li>プロトコルセキュリティの無効化 : HTTPでも接続を許可するか</li>
<li>説明 : 適当な説明</li>
<li>有効 : オンに</li>
</ul>


<p>通常では当然だが、HTTPSでの通信が推奨されている。
しかし、リスクを承知、もしくはテストでの接続の場合など、HTTPでも接続させる場合はこの項目にチェックをつけると許可する事が可能。
今回はテストってことでオンにした。</p>

<p><img src="/images/2016/06/sf_wprest01.jpg" alt="" /></p>

<p>ちなみに、このリモートサイトへの登録をせずにコールアウトしようとすると、以下のようなエラーが出力される。</p>

<blockquote><p>Unauthorized endpoint, please check Setup->Security->Remote site settings. endpoint =xxx</p></blockquote>

<h1>OAuth1.0a認証</h1>

<p>今回は、WP REST API + OAuth 1.0a Server　の設定で投稿するため、OAuth1.0aでの認証になる。<br/>
OAuth 1.0a での認証をするためには、アクセストークンやシグネチャなどの情報をヘッダーに付与してやる必要がある。<br/>
参考: <a href="https://syncer.jp/how-to-make-signature-of-oauth-1">OAuth1.0の署名(Signature)を作成する方法</a></p>

<p>これらの処理をするためのクラスがあったのでこちらを参考にさせてもらった。</p>

<p><a href="https://gist.github.com/surjikal/7539745">Apex 2-legged OAuth 1.0</a></p>

<p>ただし、このままでは足りない情報があったため、アクセストークンなどを送信するように修正させてもらったものが以下となる。</p>

<p><a href="https://gist.github.com/k-usk/894760237c73e47ed4c7333c30ce0b91">k-usk/OAuth.cls</a></p>

<h1>コールアウトを実装</h1>

<p>上記のクラスを利用して実際にコールアウトしてやる。</p>

<p>```
public class PostWPCallout {</p>

<pre><code>@Future(callout=true)
public static void wpCalloutOAuth(){
    String WP_URL = 'http://example.com';
    String client_key = 'IdZQC4OG1Ppi';
    String client_secret = 'S14spr4ny50fN4mjlEfvoBl4d9dWmIyqobp60DvWAD6b0j5g';
    String oauth_token = '1IRo5QV2itt7BSeVA9m14yMQ';
    String oauth_token_secret = 'MPDAnRor5Ajxr7z1N7JF2EOr7vCZqqJE48iYjgolQ1cD0Jm9';

    //リクエストを作成
    HttpRequest req = new HttpRequest();
    req.setMethod('POST');
    req.setEndpoint(WP_URL + '/wp-json/wp/v2/posts'); //新規投稿
    req.setHeader('Content-Type','application/json');
    Map&lt;String,String&gt; mapEmp = new Map&lt;String,String&gt;();
    mapEmp.put('title','タイトル');
    mapEmp.put('content', '本文');
    String jsonString = JSON.serialize(mapEmp);
    req.setBody(jsonString);

    //クラスを利用して、OAuth用のヘッダを作る
    req = OAuth.signRequest(req, client_key, client_secret, oauth_token, oauth_token_secret);

    //コールアウト
    Http http = new Http();
    try{
        HttpResponse res = http.send(req);

        System.debug(Logginglevel.INFO, '*** BODY : ' + res.getBody());
        System.debug(Logginglevel.INFO, '*** STATUS : ' + res.getStatus());
        System.debug(Logginglevel.INFO, '*** STATUS_CODE : ' + res.getStatusCode());
    }catch(System.CalloutException e){
        System.debug(Logginglevel.INFO,'*** ERROR_MESSAGE : ' + e.getMessage());
        System.debug(Logginglevel.INFO,'*** ERROR_LINE_NUMBER : ' + e.getLineNumber());
    }
}
</code></pre>

<p>}
```</p>

<p>コールアウトしたレスポンスがJSONで返ってくるので、投稿した記事IDを取得したい場合はここから取得したりも出来る。<br/>
(JSONでの取得はややこしいので、パースすることになるが）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[swift]alamofireとswiftyjsonを使ってAPIからデータを取得する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/05/26/alamofire-swiftyjson/"/>
    <updated>2016-05-26T18:39:28+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/05/26/alamofire-swiftyjson</id>
    <content type="html"><![CDATA[<p><a href="http://kayakuguri.github.io/blog/2016/05/23/swift-sf-restapi/">一つ前の投稿</a>でSalesforceへ接続出来たが、HTTP通信の部分とJSONへのパース部分はライブラリを使うのがデファクトスタンダードになりつつある、という情報を仕入れたので試してみる。</p>

<!-- more -->


<h1>インストール</h1>

<p>インストールするライブラリは以下の２つ。</p>

<ul>
<li>Alamofire</li>
<li>SwiftyJSON</li>
</ul>


<p><code>Alamofire-SwiftyJSON</code>というライブラリも同時に使用している紹介記事が多かったのだが、インストールしてみると以下の様な警告が出た。</p>

<blockquote><p>Alamofire-SwiftyJSON has been deprecated in favor of AlamofireSwiftyJSON</p></blockquote>

<p>気になって調べてみると、以下の様なページが。</p>

<ul>
<li><a href="https://github.com/pdutourgeerling/Alamofire-SwiftyJSON-Podspec">pdutourgeerling/Alamofire-SwiftyJSON-Podspec: Updated Podspec for Alamofire-SwiftyJSON</a></li>
</ul>


<p>機械翻訳にかけてみると、どうやらAlamofire-SwiftyJSONはAlamofireの古いバージョンである、1.3を使うようになっており、1.3はSwift2に対応していいない。なので、Alamofireの新しいバージョンをインストールするためには直接Githubのリポジトリを指定してやる必要がある、とのことのよう。</p>

<p>今回は特に使わなくても大丈夫だったのでインストールはしないでおいた。</p>

<p><code>Podfile</code>には以下を追加。</p>

<p><code>
pod 'Alamofire'
pod 'SwiftyJSON'
</code></p>

<p><code>$ pod update</code>でインストールした。</p>

<h1>利用</h1>

<p>前回のアクセストークン取得の際のコードは以下。</p>

<p>```
let URL = NSURL(string: SF_LOGIN_URL + &ldquo;/services/oauth2/token&rdquo;)
let req = NSMutableURLRequest(URL: URL!)
req.HTTPMethod = &ldquo;POST&rdquo;
let paramString = &ldquo;grant_type=password&amp;client_id=&rdquo; + SF_CLIENT_ID + &ldquo;&amp;client_secret=&rdquo; + SF_CLIENT_SECRET + &ldquo;&amp;username=&rdquo; + SF_USERNAME + &ldquo;&amp;password=&rdquo; + SF_PASSWORD
req.HTTPBody = paramString.dataUsingEncoding(NSUTF8StringEncoding)</p>

<p>let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
let session = NSURLSession(configuration: configuration, delegate: nil, delegateQueue: NSOperationQueue.mainQueue())</p>

<p>let task = session.dataTaskWithRequest(req, completionHandler: {</p>

<pre><code>(let data, let response, let error) -&gt; Void in
do{
    let json = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments) as! NSDictionary
    print(json)
}catch{
    print("error")
}
</code></pre>

<p>})
task.resume()
```</p>

<h2>import</h2>

<p>ライブラリを読み込むために、ファイルの冒頭に<code>import</code>を追加しておくこと。</p>

<p><code>
import Alamofire
import SwiftyJSON
</code></p>

<h2>HTTP通信</h2>

<p>通信は、<code>responseJSON</code>を使う。<br/>
少し前にAlamofireの仕様変更があったらしく、エラーハンドリングの方法が変わったよう。</p>

<ul>
<li>参考 &ndash; <a href="http://ja.stackoverflow.com/questions/16844/alamofire-3-0%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6json%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95">Alamofire 3.0を使用してJSONデータを取得する方法</a></li>
</ul>


<p>通信部分と結果だけ記述するとこんな感じ。</p>

<p>```
Alamofire.request(.POST, URL!, parameters: parameters)</p>

<pre><code>.responseJSON { response in
      print(response.result)
      //SUCCESS or FAILURE
</code></pre>

<p>}
```</p>

<p>エラーハンドリング用に分岐させるとこうなる。</p>

<p>```
Alamofire.request(.POST, URL!, parameters: parameters)</p>

<pre><code>.responseJSON { response in
    switch response.result {
    case .Success(let value):
        print("value: \(value)")
    case .Failure(let error):
        print(error)
    }
</code></pre>

<p>}
```</p>

<p>返ってくるエラーは<code>ErrorType</code>の型になっており、前回の記事と同じ取扱で大丈夫だった。</p>

<h2>JSONへパース</h2>

<p>取得した値をJSONへパースするには、以下だけでいける。</p>

<p><code>
let json = JSON(data)
</code></p>

<p>また、文字列への変換もプロパティで用意されている。</p>

<p><code>
let str:String = json["token"].string
</code></p>

<p>実に簡単。</p>

<h1>完成</h1>

<p>アクセストークンを取得する部分だけ書き換えたものコードは以下のようになる。</p>

<p>```
let URL = SF_LOGIN_URL + &ldquo;/services/oauth2/token&rdquo;
let parameters = [</p>

<pre><code>"grant_type":"password",
"client_id":SF_CLIENT_ID,
"client_secret":SF_CLIENT_SECRET,
"username":SF_USERNAME,
"password":SF_PASSWORD
</code></pre>

<p>]</p>

<p>Alamofire.request(.POST, URL, parameters: parameters)</p>

<pre><code>.responseJSON { response in
    switch response.result {
    case .Success(let value):
        let json = JSON(value)
        print(json)            

        //let access_token = json["access_token"].string
        //let instance_url = json["instance_url"].string
        //let token_type = json["token_type"].string

    case .Failure(let error):
        print("error")
    }
</code></pre>

<p>}
```</p>

<h2>ヘッダ</h2>

<p>ちなみにヘッダの指定は以下のようにしてアクセストークンを送れた。</p>

<p>```
let headers = [</p>

<pre><code>"Authorization": "\(self.token_type) \(self.access_token)"
</code></pre>

<p>]
Alamofire.request(.POST, URL, parameters: parameters, headers: headers)</p>

<pre><code>.responseJSON { response in
    (略)
</code></pre>

<p>```</p>

<h1>まとめ</h1>

<p>コードはそこまで劇的に減るわけではないが、すっきりした。<br/>
なによりパラメータの指定や、JSONの取り扱いがかなり見やすく簡単になったと思う。<br/>
特に理由がなければライブラリを使えば良い気がする。</p>

<h1>参考</h1>

<ul>
<li><a href="http://cocoadocs.org/docsets/Alamofire/3.4.0/">Alamofire Reference</a></li>
<li><a href="http://qiita.com/yutat93/items/1b6dfe34fa8537cf3329">AlamofireとSwiftyJSONでAPIを叩くチュートリアル &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
