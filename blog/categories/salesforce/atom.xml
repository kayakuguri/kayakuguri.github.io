<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: salesforce | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/salesforce/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2016-05-23T20:27:24+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[swiftからsalesforceへOAuth認証してRestAPIへ接続する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/05/23/swift-sf-restapi/"/>
    <updated>2016-05-23T20:18:58+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/05/23/swift-sf-restapi</id>
    <content type="html"><![CDATA[<p>iOSアプリからSalesforceとRestAPIで通信するためにOAuth認証してみた。</p>

<!-- more -->


<h1>認証方法の種類</h1>

<p>Salesforceへ接続するためにはいくつか方法があるが、</p>

<ul>
<li><a href="https://help.salesforce.com/apex/HTViewHelpDoc?id=remoteaccess_oauth_jwt_flow.htm&amp;language=ja">OAuth 2.0 JWT べアラートークンフロー</a></li>
<li><a href="https://help.salesforce.com/apex/HTViewHelpDoc?id=remoteaccess_oauth_SAML_bearer_flow.htm&amp;language=ja">OAuth 2.0 SAML ベアラーアサーションフロー</a></li>
<li><a href="https://help.salesforce.com/apex/HTViewHelpDoc?id=remoteaccess_oauth_web_server_flow.htm&amp;language=ja">OAuth 2.0 Web サーバ認証フロー</a></li>
<li><a href="https://help.salesforce.com/apex/HTViewHelpDoc?id=remoteaccess_oauth_username_password_flow.htm&amp;language=ja">OAuth 2.0 ユーザ名パスワードフロー</a></li>
</ul>


<p>今回はPHPでも利用したことがある、ユーザー名パスワードフロー、を利用してみる。
たぶん、パスワードの保持などが必要など、セキュリティとしては一番低いものっぽいので、JWTなどで認証した方がいいのかもしれない。</p>

<p>SwiftのライブラリとしてCocoapodsで提供されている認証用ライブラリがあるが、このライブラリではWebサーバ認証フローが使われており、不特定多数との接続には向いていない。
(Webサーバ認証フローは、Salesforceのアカウントを取得している前提となる。Facebookログイン、のようなイメージ）</p>

<h1>準備</h1>

<p>Salesforce側へ接続するために必要になる情報は以下。
接続アプリケーションは事前に作成しておく。</p>

<ul>
<li>ログインID</li>
<li>ログインパスワード</li>
<li>セキュリティトークン(IPアドレスを指定している場合は必要なし)</li>
<li>コンシューマ鍵 (クライアントID)</li>
<li>コンシューマの秘密 (クライアントシークレット)</li>
</ul>


<h1>環境変数</h1>

<p>開発中はSandboxへ、リリース時には本番環境へ、と接続先を切り替えたいので、環境変数へ上記の内容を保存する。</p>

<ul>
<li>参考: <a href="http://shibuya-3percent.hatenablog.com/entry/2016/01/18/024948">Swiftでの環境変数を使ってDebug/Releaseで定数を使い分ける</a></li>
</ul>


<p>まず、Build Settingsに値を追加する。</p>

<p><img src="/images/2016/05/sf-swift01.jpg" alt="" /></p>

<p>プロジェクトから、<code>TARGETS</code>ファイルを選択。
<code>Build Setting</code>を選んで、プラスマークをクリックして、<code>Add User-Defined Setting</code>を選ぶ。</p>

<p>左側には設定したい項目名をKeyとして登録。
自動的に、<code>Debug</code>と<code>Release</code>が表示されるので、それぞれの値を入れる。</p>

<p><img src="/images/2016/05/sf-swift02.jpg" alt="" /></p>

<p>次に、<code>Info.plist</code>に定義したキーを呼び出せるように設定する。
<code>Infomation Property List</code>の<code>+</code>をクリックして追加する。</p>

<p><code>Key</code>は実際にコードから呼び出す際に使用する名前となる。
<code>Type</code>は<code>String</code>とする。
<code>Value</code>は定義した値を呼び出すため、<code>${KEY}</code>というように記述する。</p>

<p><img src="/images/2016/05/sf-swift03.jpg" alt="" /></p>

<p>ここまでで設定は完了。
以下のコードで呼び出せる。</p>

<p><code>
let SF_LOGIN_URL = NSBundle.mainBundle().objectForInfoDictionaryKey("SF_LOGIN_URL") as! String
</code></p>

<h1>OAuth認証</h1>

<p>準備した値を使用してアクセストークンを要求する。
アクセストークンの要求は、指定のエンドポイントへPOSTで値を送信する事で行う。</p>

<p>エンドポイント</p>

<ul>
<li>本番 : <a href="https://login.salesforce.com/services/oauth2/token">https://login.salesforce.com/services/oauth2/token</a></li>
<li>sandbox : <a href="https://test.salesforce.com/services/oauth2/token">https://test.salesforce.com/services/oauth2/token</a></li>
</ul>


<p>送信する値</p>

<ul>
<li>grant_type — <code>password</code></li>
<li>client_id — 接続アプリケーション定義のコンシューマ鍵</li>
<li>client_secret — 接続アプリケーション定義のコンシューマの秘密</li>
<li>username — ユーザ名</li>
<li>password — パスワード (+セキュリティトークン)</li>
</ul>


<p>パスワードはIPを指定していない場合は、パスワードの後ろにセキュリティトークンを繋げてやる必要がある。</p>

<h2>POST送信</h2>

<p>POST送信は、<code>NSURLConnection</code>がディスコンになったので、<code>NSURLSession</code>を使用する必要があるとのこと。
非同期での通信が基本になったよう。</p>

<ul>
<li>参考: <a href="http://qiita.com/fmtonakai/items/30d8b9bcc3dd2b8d228b">Sayonara NSURLConnection &ndash; Qiita</a></li>
</ul>


<p>送信し、返ってきた値をJSONに変換して受け取る。
以下を参考にしてコードを記述した。</p>

<ul>
<li><a href="http://swiftdeveloperblog.com/send-http-post-request-example-using-swift-and-php/">Send HTTP POST Request example using Swift and PHP &ndash; Swift Developer Blog</a></li>
<li><a href="http://ohtacky.blogspot.jp/2015/09/swiftios9json.html">&#12304;swift&#12305;iOS9におけるjsonの取得 sendAsynchronousRequestが使えない&#12290; ~ ネットショップの立ち上げから運営までの作業ログ</a></li>
</ul>


<p>```
let SF_LOGIN_URL = NSBundle.mainBundle().objectForInfoDictionaryKey(&ldquo;SF_LOGIN_URL&rdquo;) as! String
let SF_CLIENT_ID = NSBundle.mainBundle().objectForInfoDictionaryKey(&ldquo;SF_CLIENT_ID&rdquo;) as! String
let SF_CLIENT_SECRET = NSBundle.mainBundle().objectForInfoDictionaryKey(&ldquo;SF_CLIENT_SECRET&rdquo;) as! String
let SF_USERNAME = NSBundle.mainBundle().objectForInfoDictionaryKey(&ldquo;SF_USERNAME&rdquo;) as! String
let SF_PASSWORD = NSBundle.mainBundle().objectForInfoDictionaryKey(&ldquo;SF_PASSWORD&rdquo;) as! String</p>

<p>let URL = NSURL(string: SF_LOGIN_URL + &ldquo;/services/oauth2/token&rdquo;)
let req = NSMutableURLRequest(URL: URL!)
req.HTTPMethod = &ldquo;POST&rdquo;
let paramString = &ldquo;grant_type=password&amp;client_id=&rdquo; + SF_CLIENT_ID + &ldquo;&amp;client_secret=&rdquo; + SF_CLIENT_SECRET + &ldquo;&amp;username=&rdquo; + SF_USERNAME + &ldquo;&amp;password=&rdquo; + SF_PASSWORD
req.HTTPBody = paramString.dataUsingEncoding(NSUTF8StringEncoding)</p>

<p>let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
let session = NSURLSession(configuration: configuration, delegate: nil, delegateQueue: NSOperationQueue.mainQueue())</p>

<p>let task = session.dataTaskWithRequest(req, completionHandler: {</p>

<pre><code>(let data, let response, let error) -&gt; Void in
do{
    let json = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments) as! NSDictionary
    print(json)
}catch{
    print("error")
}
</code></pre>

<p>})
task.resume()
```</p>

<h3>参考</h3>

<ul>
<li><a href="http://qiita.com/sushichop/items/ac4ae99b905ce523c2fe">SwiftでHTTPリクエストする &ndash; Qiita</a></li>
<li><a href="http://www.kaleidosblog.com/nsurlsession-in-swift-get-and-post-data">NSURLSession in Swift: get and post data</a></li>
</ul>


<h2>ATS</h2>

<p>しかしこのまま送信するとエラーが返ってくる。</p>

<p><code>
2016-05-23 18:56:48.600 XXX-DEV[30024:28386036] CFNetwork SSLHandshake failed (-9824)
2016-05-23 18:56:48.600 XXX-DEV[30024:28386036] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9824)
</code></p>

<p>これは、iOS9から導入されたATSという機能によるものらしい。
外部への送信はHTTPSかつセキュアな証明書を使用していないと接続しない、というセキュリティ強化のための機能のよう。
本来はサーバー側で証明書を変更するなどの対応が好ましいが、salesforce側の証明書を変更するのは不可能なため、例外ドメインを指定して通信を許可してやる。</p>

<p>通信したいドメインがATSに対応しているかどうかは、<code>nscurl</code>コマンドを使用すると調べる事ができるよう。</p>

<ul>
<li>参考: <a href="http://blog.kishikawakatsumi.com/entry/2015/10/19/121257">接続先がATS (App Transport Security)に対応しているか、または例外の設定をnscurlコマンドで簡単に調べる &ndash; 24/7 twenty-four seven</a></li>
</ul>


<p>このコマンドではATSの設定を変えながらしらみつぶしにチェックしてくれるコマンド、となっている。
なので、この結果をみながら接続がパスする設定を確認する。</p>

<p><code>
$ nscurl --ats-diagnostics https://test.salesforce.com/
</code></p>

<p><code>test.salesforce.com</code>の場合は、
<code>TLS</code>のバージョンを変更しただけでは通信が失敗しているが、
<code>Perfect Forward Secrecy</code>を<code>false</code>とした場合にはパスしていることがわかる。</p>

<h1>```</h1>

<p>Configuring TLS exceptions for test.salesforce.com</p>

<hr />

<p>TLSv1.2
2016-05-23 19:06:14.743 nscurl[30351:28433837] CFNetwork SSLHandshake failed (-9824)
2016-05-23 19:06:14.744 nscurl[30351:28433837] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9824)</p>

<h2>Result : FAIL</h2>

<hr />

<p>TLSv1.1
2016-05-23 19:06:14.814 nscurl[30351:28433837] CFNetwork SSLHandshake failed (-9824)
2016-05-23 19:06:14.815 nscurl[30351:28433837] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9824)</p>

<h2>Result : FAIL</h2>

<hr />

<p>TLSv1.0
2016-05-23 19:06:14.883 nscurl[30351:28433837] CFNetwork SSLHandshake failed (-9824)
2016-05-23 19:06:14.883 nscurl[30351:28433837] NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9824)</p>

<h2>Result : FAIL</h2>

<p>================================================================================</p>

<p>Configuring PFS exceptions for test.salesforce.com</p>

<hr />

<p>Disabling Perfect Forward Secrecy</p>

<h2>Result : PASS</h2>

<p>```</p>

<p>コマンドで<code>--verbose</code>オプションをつけると設定の内容を具体的に表示させる事ができる。</p>

<p><code>
$ nscurl --ats-diagnostics --verbose https://test.salesforce.com/
</code></p>

<p>以下は失敗。
```
{</p>

<pre><code>NSExceptionDomains =     {
    "test.salesforce.com" =         {
        NSExceptionMinimumTLSVersion = "TLSv1.2";
    };
};
</code></pre>

<p>}
```</p>

<p>以下は成功。</p>

<p>```
{</p>

<pre><code>NSExceptionDomains =     {
    "test.salesforce.com" =         {
        NSExceptionRequiresForwardSecrecy = false;
    };
};
</code></pre>

<p>}
```</p>

<p>この結果から<code>info.plist</code>に設定を追加していく。</p>

<ul>
<li><p>参考: <a href="http://shirakiya.hatenablog.com/entry/2015/10/03/234816">iOS9から導入されたATSとは？そして回避する方法は？ &ndash; Be a Engineer.</a></p></li>
<li><p>NSAppTransportSecurity (Dictionary)</p>

<ul>
<li>NSExceptionDomains (Dictionary)

<ul>
<li>test.salesforce.com (Dictionary)

<ul>
<li>NSExceptionRequiresForwardSecrecy (Boolean) &ndash; <code>NO</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p><img src="/images/2016/05/sf-swift04.jpg" alt="" /></p>

<p>これでようやく通信に成功し、アクセストークンを取得することが出来た。</p>

<p><code>
{
  "access_token":"(ACCESS_TOKEN)",
  "instance_url":"https://cs5.salesforce.com",
  "id":"https://test.salesforce.com/id/xxx/xxx",
  "token_type":"Bearer",
  "issued_at":"1463998466487",
  "signature":"(SIGNATURE)"
}
</code></p>

<h1>APIへ接続</h1>

<p>今回は自作したApex Rest APIに接続してみる。
apexの作り方は割愛。エンドポイントはapex内で以下のように指定しているとする。</p>

<p><code>
@RestResource(urlMapping='/user/login')
</code></p>

<p>APIへの接続には、アクセストークンを取得した際に一緒に取得した<code>instance_url</code>へ接続する。
このURLは環境によって変わることがある。
しかしこのドメインもATSによって接続が失敗してしまう。
今回は簡易だが、ATSの機能自体をオフにすることで対応する。</p>

<p><code>NSAppTransportSecurity</code>の下に、<code>NSAllowsArbitraryLoads</code>を追加し、<code>true</code>にしてやることで機能自体をオフにすることができる。</p>

<p><img src="/images/2016/05/sf-swift05.jpg" alt="" /></p>

<p>APIへ接続する際には、ヘッダにさきほど取得したアクセストークンを入れてやる。</p>

<ul>
<li>参考: <a href="http://stackoverflow.com/questions/28526743/how-to-use-alamofire-with-custom-headers-for-post-request">swift &ndash; How to use Alamofire with custom headers for POST request &ndash; Stack Overflow</a></li>
</ul>


<p><code>
req.addValue("Bearer \(self.access_token)", forHTTPHeaderField: "Authorization")
</code></p>

<p>アクセストークンを取得した後からのコードは以下となる。
```
//OAuth認証後に取得する
var access_token = json[&ldquo;access_token&rdquo;] as? String
var instance_url = json[&ldquo;instance_url&rdquo;] as? String
var token_type = json[&ldquo;token_type&rdquo;] as? String</p>

<p>//APIへ接続
let URL = NSURL(string: self.instance_url + &ldquo;/services/apexrest/user/login&rdquo;)
let req = NSMutableURLRequest(URL: URL!)</p>

<p>req.addValue(&ldquo;(self.token_type) (self.access_token)&rdquo;, forHTTPHeaderField: &ldquo;Authorization&rdquo;) //ヘッダ</p>

<p>let user_email = &ldquo;<a href="&#109;&#97;&#x69;&#x6c;&#x74;&#111;&#58;&#x78;&#x78;&#x78;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#99;&#111;&#x6d;">&#120;&#120;&#120;&#64;&#101;&#120;&#97;&#x6d;&#112;&#108;&#x65;&#x2e;&#x63;&#111;&#x6d;</a>&rdquo;
let user_pass = &ldquo;xxx&rdquo;</p>

<p>req.HTTPMethod = &ldquo;POST&rdquo;
let paramString = &ldquo;email=(user_email)@nobel.jp&amp;passwd=(user_pass)&rdquo;
req.HTTPBody = paramString.dataUsingEncoding(NSUTF8StringEncoding)
let configuration = NSURLSessionConfiguration.defaultSessionConfiguration()
let session = NSURLSession(configuration: configuration, delegate: nil, delegateQueue: NSOperationQueue.mainQueue())</p>

<p>let task = session.dataTaskWithRequest(req, completionHandler: {</p>

<pre><code>(let data, let response, let error) -&gt; Void in
do{
    let json = try NSJSONSerialization.JSONObjectWithData(data!, options: NSJSONReadingOptions.AllowFragments) as! NSDictionary
    print(json)
}catch{
    print("error")
}
</code></pre>

<p>})
task.resume()
```</p>

<p>これで指定のエンドポイントへ接続が出来た。</p>

<h1>まとめ</h1>

<p>とりあえず、アクセストークンを取得してRest APIへ接続、まで一通り出来た。
後は必要であれば、認証方式をJWTにしたり出来るといいかもしれない。</p>

<p>もしSFへの接続でいいライブラリなどがあれば教えて下さい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カスタム設定を作成して取得してみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/02/01/custom-setting/"/>
    <updated>2016-02-01T15:15:19+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/02/01/custom-setting</id>
    <content type="html"><![CDATA[<p>カスタム設定、というカスタムオブジェクトの一種でSOQLいらずでもっと手軽に扱える <code>カスタム設定</code> とうものを知ったので、<br/>
作り方から使い方を調べてみた。</p>

<!-- more -->


<blockquote><p>カスタム設定はカスタムオブジェクトと類似しており、アプリケーション開発者は、カスタムデータセットの作成の他に、組織、プロファイル、または特定のユーザに対しカスタムデータを作成して関連付けることができます。<br/>
<a href="https://help.salesforce.com/HTViewHelpDoc?id=cs_about.htm&amp;language=ja">https://help.salesforce.com/HTViewHelpDoc?id=cs_about.htm&amp;language=ja</a></p></blockquote>

<p>今回は全体で使用する、環境変数、としてカスタム設定を作成してみた。</p>

<h2>作成</h2>

<p>[開発] → [カスタム設定] にアクセス。<br/>
まずは新規でカスタム設定、を作る。<br/>
オブジェクトのようなもの。</p>

<p><img src="/images/2016/01/custom_setting02.jpg" alt="" /></p>

<p>今回は以下のように作成した。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> 表示ラベル </td>
<td align="left"> 環境変数</td>
</tr>
<tr>
<td></td>
<td align="left"> オブジェクト名 </td>
<td align="left"> EnvironmentVars</td>
</tr>
<tr>
<td></td>
<td align="left"> 設定種別 </td>
<td align="left"> リスト</td>
</tr>
<tr>
<td></td>
<td align="left"> 表示 </td>
<td align="left"> 公開</td>
</tr>
<tr>
<td></td>
<td align="left"> 説明 </td>
<td align="left"> </td>
</tr>
</tbody>
</table>


<p><img src="/images/2016/01/custom_setting03.jpg" alt="" /></p>

<p>設定種別は、リスト、と、階層、があり、<br/>
階層、は、ユーザーやプロファイルごとに同じ項目で違う値を設定したり出来るよう。<br/>
どのユーザーが使用しているかによって変数の値を変更できるようになるので、<br/>
そういうことを実現したい時に便利っぽい。 <br/>
今回は全員同じにしたいので、リスト、にしておいた。</p>

<p>また、表示、は、公開・保護、とある。<br/>
公開、だとSOAP APIでも取得できるようになったり、とオープンな状態？になるよう。<br/>
特に秘匿する内容でもないので、公開、にしておいた。</p>

<p>次に作成したカスタム設定内にカスタム項目を追加する。<br/>
作成したカスタム設定から、新規、をクリック。</p>

<p><img src="/images/2016/01/custom_setting04.jpg" alt="" /></p>

<p>通常の項目作成と同じ流れで、型を選択し、内容を埋めていく。<br/>
今回は以下のように作成した。<br/>
目的としては、SitesのURLを環境変数として持っておくためのもの。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> 型 </td>
<td align="left"> テキスト</td>
</tr>
<tr>
<td></td>
<td align="left"> 項目の表示ラベル </td>
<td align="left"> Sites</td>
</tr>
<tr>
<td></td>
<td align="left"> 文字数 </td>
<td align="left"> 255</td>
</tr>
<tr>
<td></td>
<td align="left"> 項目名 </td>
<td align="left"> Sites</td>
</tr>
<tr>
<td></td>
<td align="left"> 説明、など </td>
<td align="left"> </td>
</tr>
</tbody>
</table>


<p><img src="/images/2016/01/custom_setting05.jpg" alt="" /></p>

<p>ここまででオブジェクトと項目が作成出来たので、実際にデータを入れていく。<br/>
作成したカスタム設定の<code>Manege</code>をクリック。</p>

<p><img src="/images/2016/01/custom_setting06.jpg" alt="" /></p>

<p>リストが表示されるので、新規、をクリック。</p>

<p><img src="/images/2016/01/custom_setting07.jpg" alt="" /></p>

<p>内容を記入して保存。</p>

<p><img src="/images/2016/01/custom_setting08.jpg" alt="" /></p>

<h2>取得</h2>

<p>作成したデータをApexで取得する。</p>

<p>前述の通り、取得の際にはSOQLを発行する必要がなく、以下のようにメソッドレベルで取得可能。</p>

<p>```
Map&lt;String, EnvironmentVars<strong>c> settingMap = EnvironmentVars</strong>c.getAll();</p>

<p>for (String key : settingMap.keySet()) {</p>

<pre><code>EnvironmentVars__c env = settingMap.get(key);
System.debug('**DEBUG** ' key + ' / ' + env.SitesURL__c);
</code></pre>

<p>}
```</p>

<h2>まとめ</h2>

<p>SOQLを発行しないので、ガバナ的にも優しく、内容はキャッシュされるので動作も高速。<br/>
環境変数のように決まった値であれば便利に使えるかもしれない。</p>

<h2>参考</h2>

<p><a href="https://help.salesforce.com/HTViewHelpDoc?id=cs_accessing.htm&amp;language=ja">カスタム設定へのアクセス</a><br/>
<a href="https://odekakeshimasyo.io/salesforce-apex-customsetting.html">Salesforce Apex カスタム設定 | odekakeshimasyo.io</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[apex]バッチ実行時にカウントデータを引き継ぐ]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/08/05/apex-batch-data/"/>
    <updated>2015-08-05T11:26:58+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/08/05/apex-batch-data</id>
    <content type="html"><![CDATA[<p>apexでバッチを走らせる場合は、デフォルトでの200件ごとに処理を走らせる場合が多いけれれど、<br/>
その時に処理の中でカウントアップしたデータを次の処理に引き継ぎたかった。</p>

<!-- more -->


<p>結論から言うと、 <code>Database.Stateful</code> を使うと、データの内容を保持した状態でバッチが走らせられた。</p>

<p>具体的には以下。</p>

<p>```
public with sharing class Hogehoge_Batch implements Database.Batchable<sObject>, Database.Stateful{</p>

<pre><code>private Integer count {get; set;}

public Hogehoge_Batch(Boolean isLastBatch){
    this.count = 0;
}

public Database.QueryLocator start(Database.BatchableContext BC){
    String query = 'select id from Lead';
     return Database.getQueryLocator(query);
}

public void execute(Database.BatchableContext BC, List&lt;Lead&gt; scope){
    for(Lead user : scope){ 
        user.count__c = this.count;
        this.count++;
    }
    update scope;
}

public void finish(Database.BatchableContext BC){
}
</code></pre>

<p>}
```</p>

<p>クラス定義の1行目の最後にくっついてる。<br/>
これがないと<code>count</code>は毎回リセットされてしまう。</p>

<h2>参考</h2>

<p><a href="http://tyoshikawa1106.hatenablog.com/entry/2015/02/15/182505">SFDC：【大量データ処理】Apex Batchで一括更新処理を確認してみました &ndash; tyoshikawa1106のブログ</a><br/>
<a href="http://salesforceapexcodecorner.blogspot.jp/2011/08/state-management-in-batch-apex-in.html">State Management In Batch Apex in Salesforce</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]apexでレコードをフォローさせる]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/07/02/record-follow/"/>
    <updated>2015-07-02T09:54:50+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/07/02/record-follow</id>
    <content type="html"><![CDATA[<p>レコードを作った段階で自動的にフォローさせたかったので調べてみた。</p>

<!-- more -->


<h2>チャター</h2>

<p>デフォルトでは一部のレコードを除いてレコードのフォロー機能はオフになっている。<br/>
オンにするには、<code>フィード追跡</code>で有効にする。</p>

<p><code>設定 -&gt; カスタマイズ -&gt; Chatter -&gt; フィード追跡</code>を選択。<br/>
有効にしたいオブジェクトを選んで、<code>フィード追跡の有効化</code>にチェックを入れて保存。</p>

<p><img src="/images/2015/07/feed_follow01.jpg" alt="" /></p>

<p>すると、設定したレコード詳細の上部にフォローの表示とチャターコメントが出現する。<br/>
フォローしたい場合はここをクリックしてフォロー出来る。</p>

<p><img src="/images/2015/07/feed_follow02.jpg" alt="" /></p>

<p>フォローすると以下のような表示に変わる。</p>

<p><img src="/images/2015/07/feed_follow03.jpg" alt="" /></p>

<h2>apexでのフォロー</h2>

<p>フォローは、<code>EntitySubscription</code>なるオブジェクトで管理されている。<br/>
現在のフォロー関係一覧を取得するSOQLは以下。</p>

<pre><code>SELECT Id, ParentId, SubscriberId FROM EntitySubscription
</code></pre>

<p><code>ParentId</code>が、フォロー対象のユーザーやオブジェクトのレコードID。<br/>
<code>SubscriberId</code>が、フォローするユーザーのID、となる。</p>

<p>なので、このオブジェクトにフォロー対象とフォローするIDを入れてインサートしてやればよい。</p>

<p>例）</p>

<p><code>
EntitySubscription follow = new EntitySubscription();
follow.ParentId = 'ID'; //対象のレコード
follow.SubscriberId = 'ID'; //ユーザーのID
insert follow;
</code></p>

<p>トリガーで実装する場合は、レコードのIDが必要になるので、<code>after insert</code>で実行すること。</p>

<h2>参考</h2>

<p><a href="http://vaindespair.blogspot.jp/2011/01/blog-post.html">memo: Force.com&#12288;&#65306;&#12288;行動を作成したとき&#12289;自動的にフォローするようにしたい</a></p>

<p>チャター関係は以下のPDFにまとまっていた。<br/>
<a href="http://developerforcejp.s3.amazonaws.com/books/cheatsheets/Chatter-cheatsheet_Ja.pdf">http://developerforcejp.s3.amazonaws.com/books/cheatsheets/Chatter-cheatsheet_Ja.pdf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]指定のユーザーでテスト実行]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/06/11/system-run-as/"/>
    <updated>2015-06-11T14:53:28+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/06/11/system-run-as</id>
    <content type="html"><![CDATA[<p>salesforceのユーザーである、<code>User</code>オブジェクトにカスタム項目を作って、<br/>
それを使ったコードなんかを書いた時にそのユーザーでの実行が必要になる。<br/>
そんな時のメモ。</p>

<!-- more -->


<h2>テスト実行</h2>

<p><code>system.runas(){}</code>を使う。<br/>
引数に使用するユーザーを指定し、<code>{}</code>内で実行する処理を書く。</p>

<h2>ユーザーの作成</h2>

<p>指定するユーザーをテスト内で作成するには以下のようにする。</p>

<p>```
Map&lt;String,ID> profiles = new Map&lt;String,ID>();
Profile ps = [select id, name from Profile where name = &lsquo;標準ユーザ&rsquo; LIMIT 1];
User standard = new User(alias = &lsquo;standt&rsquo;,</p>

<pre><code>email='standarduser@testorg.com', 
emailencodingkey='UTF-8', 
lastname='Testing', languagelocalekey='en_US', 
localesidkey='en_US', 
ProfileId = ps.id,
timezonesidkey='America/Los_Angeles', 
username='standarduser-test@testorg.com'
</code></pre>

<p>);
```</p>

<p>標準ユーザーのプロフィール権限で作成している。<br/>
この時に、<code>email</code>の項目と<code>username</code>を同じにしていると、すでにそのユーザーネームは使われています、とエラーが出た。</p>

<p>で、実行。</p>

<p>```
system.runas(standard){</p>

<pre><code>//実行する内容
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<p><a href="http://blogjp.sforce.com/2013/07/systemrunas-29e3.html">System.runAs()を使う時の注意点 | Salesforce Developers Japan Blog</a><br/>
<a href="view-source:http://developer.force.com/cookbook/recipe/using-system-runas-in-test-methods">Using System.runAs in Test Methods &ndash; null</a></p>
]]></content>
  </entry>
  
</feed>
