<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-10-12T17:01:54+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Heroku] Guzzleを使用してProximo経由で接続する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/10/12/heroku-guzzle-proximo/"/>
    <updated>2017-10-12T16:40:29+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/10/12/heroku-guzzle-proximo</id>
    <content type="html"><![CDATA[<p>Herokuにて、外部APIに接続する際に固定IPにて接続したいことはたまにある。<br/>
<a href="http://kayakuguri.github.io/blog/2014/09/26/static-ip-heroku/">以前、QuotaGuard Staticを使用してのやり方は書いた</a>けれど、今回はProximoを利用した際に少しハマったのでメモ。</p>

<!-- more -->


<h1>Proximo</h1>

<p>Proximoは一番下のプランでも$5/月かかる有料アドオンとなっている。</p>

<ul>
<li><a href="https://elements.heroku.com/addons/proximo">Proximo &ndash; Add-ons &ndash; Heroku Elements</a></li>
<li><a href="https://devcenter.heroku.com/articles/proximo">Proximo | Heroku Dev Center</a></li>
</ul>


<h1>Guzzle</h1>

<p>以前の記事ではCURLで接続していたが、今回はGuzzleを使って接続してみる。</p>

<ul>
<li><a href="https://github.com/guzzle/guzzle">Guzzle, PHP HTTP client</a></li>
<li><a href="http://docs.guzzlephp.org/en/stable/">Guzzle Documentation</a></li>
</ul>


<h1>proxy経由で接続</h1>

<p>ドキュメントを確認すると、以下の方法でプロキシを指定可能、とのこと。<br/>
<a href="http://docs.guzzlephp.org/en/stable/request-options.html#proxy">http://docs.guzzlephp.org/en/stable/request-options.html#proxy</a></p>

<p><code>
$client-&gt;request('GET', '/', ['proxy' =&gt; 'tcp://localhost:8125']);
</code></p>

<p>ProximoをHerokuに追加すると、環境変数に自動的にプロキシのURLが追加される。</p>

<p><code>
PROXIMO_URL=http://proxy:your-password-here@proxy-xx-xxx-x-xxx.proximo.io
</code></p>

<p>上記URL内の、<code>xx-xxx-x-xxx</code>の部分の数字が固定IPとなる。<br/>
(ダッシュボードからも確認可）</p>

<p>これをそのままproxyのURLとして指定してやればOK…だと思ったのだが、エラーが出てしまった。</p>

<blockquote><p>cURL error 56: Proxy CONNECT aborted</p></blockquote>

<p>QuotaGuard Staticのアドオンを追加した際に取得出来るURLを同じように指定してやったところ、問題なくアクセス出来たので、Guzzleは悪くなさそう。<br/>
ProximoだとURLをパースしたりとかが必要なのか…など悩んでいて、URLを見比べていると、ProximoのURLにはポート番号がついてないことに気付く。</p>

<p>改めてドキュメントを確認してみると、ポート番号は<code>80</code>で固定、とのこと。</p>

<blockquote><p>If you’d rather use Proximo as a standard HTTP proxy, use PROXIMO_URL on port 80.<br/>
<a href="https://devcenter.heroku.com/articles/proximo#using-the-proximo-http-proxy">https://devcenter.heroku.com/articles/proximo#using-the-proximo-http-proxy</a></p></blockquote>

<p>よって、環境変数に追加されたURLの最後に <code>:80</code> とポート番号を追加してやると、無事、アクセスすることが出来た。</p>

<p>```
$proxy_url = env(&lsquo;PROXIMO_URL&rsquo;) . &lsquo;:80&rsquo;;
$res = $client->request(&lsquo;GET&rsquo;, &lsquo;<a href="http://ip.jsontest.com/">http://ip.jsontest.com/</a>&rsquo;, [</p>

<pre><code>'proxy' =&gt; $proxy_url
</code></pre>

<p>]);
$res_body = json_decode($res->getBody(), true);
var_dump($res_body);
```</p>

<p>Proximoの固定IPがJSON内に返ってきたらOK。</p>

<p>ポート番号がデフォルトでは入っていないため、少しハマってしまった。</p>

<h1>参考</h1>

<ul>
<li><a href="https://qiita.com/sho7650/items/872b5757e250d4b3eb95">[Heroku]外部接続時に固定IP化する2つの方法[Proximo] &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PhpStormを使用してPHP UnitのテストをVagrantのリモート上で実行する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/22/laravel-phpunit-vagrant-phpstorm/"/>
    <updated>2017-09-22T19:05:58+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/22/laravel-phpunit-vagrant-phpstorm</id>
    <content type="html"><![CDATA[<p>LaravelのUnitテストを実行すべく、ローカルのVagrant環境上でPHP Unitを実行するように設定してみた。</p>

<!-- more -->


<h1>環境</h1>

<ul>
<li>Vagrant

<ul>
<li><a href="https://box.scotch.io/">ScotchBox</a></li>
</ul>
</li>
<li>Laravel 5.5.7</li>
<li>PHP 7.0</li>
</ul>


<h1>PHP Unit</h1>

<p>PHP UnitはCompoerにてプロジェクトディレクトリにインストールする。<br/>
LaravelではデフォルトでComposerに入っているので特に設定はなし。<br/>
(Linuxに入れる必要はない)</p>

<p><code>
"phpunit/phpunit": "~6.0"
</code></p>

<h1>PhpStorm</h1>

<p>PhpStormでの設定方法。<br/>
設定したいプロジェクトのルートディレクトリを開いた状態で設定する。</p>

<h2>PHP Interpreter</h2>

<p><code>Preference</code>を開く。<br/>
<code>Languages &amp; Frameworks -&gt; PHP -&gt; Test Frameworks</code>を選択。<br/>
<code>+</code>マークをクリックし、<code>PHPUnit by Remote Interpreter</code>を選択する。</p>

<p><img src="/images/2017/09/phpunit_01.jpg" alt="" /></p>

<p>Interpreterを選択するウインドウが開くが、interpreterがないので作成する。<br/>
右端の<code>...</code>をクリックする。</p>

<p><img src="/images/2017/09/phpunit_02.jpg" alt="" /></p>

<p>ウインドウが開くので、<code>+</code>をクリックし、<code>From Docker, Vagrant, VM, Remote...</code>を選択。</p>

<p><img src="/images/2017/09/phpunit_03.jpg" alt="" /></p>

<p>開いたウインドウで、<code>Vagrant</code>を選択。すると自動で設定が読み込まれるのでそのままOKする。</p>

<p><img src="/images/2017/09/phpunit_04.jpg" alt="" /></p>

<p>OKをクリックすると、SSH接続が行われ情報が自動で読み込まれる。<br/>
そのままでOKなのでOKをクリックする。</p>

<p><img src="/images/2017/09/phpunit_05.jpg" alt="" /></p>

<p>Interpreterを選択する画面に戻るので、作成したInterpreterを選択し、OKをクリック。</p>

<p><img src="/images/2017/09/phpunit_06.jpg" alt="" /></p>

<p>追加したInterpreterでPHPUnitのライブラリを指定するが、Composer経由でのロードになるので、デフォルトの<code>Use Composer autoloader</code>のままでよい。<br/>
Vagrant内でのautolodのパスを指定するので、<code>...</code>をクリック。</p>

<p><img src="/images/2017/09/phpunit_07.jpg" alt="" /></p>

<p>Scothboxは<code>/var/www</code>がホストと共有しているディレクトリになるので、そこから<code>vendor/autoload.php</code>を選択する。</p>

<p><img src="/images/2017/09/phpunit_08.jpg" alt="" /></p>

<p>選択すると、追加されているPHPUnitのバージョンが表示される。</p>

<p><img src="/images/2017/09/phpunit_09.jpg" alt="" /></p>

<p>これでInterpreterの設定は完了。</p>

<h2>Run/Debug Configurations</h2>

<p>Configurationsの設定を行う。</p>

<p>メニューから、<code>Run -&gt; Edit Configurations</code>を選択。</p>

<p><code>+</code>をクリックし、<code>PHPUnit</code>のConfigurationを追加する。</p>

<p><img src="/images/2017/09/phpunit_10.jpg" alt="" /></p>

<p>Nameは適当に書く。<br/>
Test scopeはテストしたいディレクトリを選択する。<br/>
Laravelのtestsディレクトリを指定しておく。（どこでもよい）<br/>
この設定の下部に、Errorと出ているのでFixをクリック。</p>

<p><img src="/images/2017/09/phpunit_11.jpg" alt="" /></p>

<p>PHPの設定ウインドウが開くので、<code>PHP language level</code>はVagrant環境に合わせて<code>7</code>を選択。<br/>
<code>CLI Interpreter</code>は設定したinterpreterを選択する。</p>

<p><img src="/images/2017/09/phpunit_12.jpg" alt="" /></p>

<p>OKで閉じる。</p>

<h2>実行</h2>

<p>右上のセレクトボックスが、先ほど作成したConfigurationが選択されている状態になっているはずなので、そのまま緑の三角をクリック。</p>

<p><img src="/images/2017/09/phpunit_13.jpg" alt="" /></p>

<p>すると、<code>tests</code>ディレクトリ以下のテストファイルが自動で起動し、テストが実行される。<br/>
デフォルトのサンプルテストは必ず成功するので、無事、テストが通ればOK。</p>

<p><img src="/images/2017/09/phpunit_14.jpg" alt="" /></p>

<p><code>ExampleTest.php</code>の<code>assertTrue</code>を<code>false</code>にしてみて失敗させてみる。</p>

<p>```
public function testBasicTest()
{</p>

<pre><code>$this-&gt;assertTrue(false);
</code></pre>

<p>}
```</p>

<p>ファイルを選択して右クリックすれば、そのファイルのみをテスト実行する事も可能。<br/>
失敗すると以下のようになる。</p>

<p><img src="/images/2017/09/phpunit_15.jpg" alt="" /></p>

<p>これで無事、成功と失敗の動作が確認できた。</p>

<h1>参考</h1>

<ul>
<li><a href="https://confluence.jetbrains.com/display/PhpStorm/Running+PHPUnit+tests+over+SSH+on+a+remote+server+with+PhpStorm">Running PHPUnit tests over SSH on a remote server with PhpStorm &ndash; PhpStorm &ndash; Confluence</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[heroku]PostgresとRedisの環境設定]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/21/heroku-postgres-redis/"/>
    <updated>2017-09-21T15:16:32+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/21/heroku-postgres-redis</id>
    <content type="html"><![CDATA[<p>LaravelをHerokuで使用する際に、Heroku PostgresとHeroku Redisの接続情報を環境変数から取得する設定のメモ。</p>

<!-- more -->


<h1>概要</h1>

<p>改めて。<br/>
Herokuでは標準のadd-onとして<a href="https://elements.heroku.com/addons/heroku-postgresql">Heroku Postgres</a>と<a href="https://elements.heroku.com/addons/heroku-redis">Heroku Redis</a>が用意されている。<br/>
クレジットカードさえ登録していれば無料で使えるので便利。</p>

<p>この接続情報はアドオンを登録した際に自動的に以下のような変数で登録がされる。</p>

<p><strong>Postgres</strong><br/>
<code>DATABASE_URL</code> = <code>postgres://username:password@hostname.amazonaws.com:5432/database</code></p>

<p><strong>Redis</strong><br/>
<code>REDIS_URL</code> = <code>redis://h:password@hostname.amazonaws.com:port_no</code></p>

<p>各種情報がURL形式で組み込まれているのだが、間違ってもこれを自分でバラしてそれぞれ個別に環境変数に入れる、などとしてはいけない。<br/>
というのも、この接続情報はPostgresやRedisにメンテナンスが入った際に前の接続情報は破棄され、新しい情報が同じ環境変数で設定されるため、<br/>
自前でバラして作ってしまうとその変更した情報に対応できなくなり、接続エラーとなってしまう。</p>

<p>よって、必ず自動でセットされる、<code>DATABASE_URL</code>や<code>REDIS_URL</code>を使うこと。<br/>
これはHerokuを使う際には常識として覚えておくこと。</p>

<h1>取得</h1>

<p>というわけで、それぞれの値を取得したURLからパースしてLaravel用に環境変数にセットする。<br/>
以下のように環境変数があればそれをパースして環境変数としてセットしてやるようにするのがスマートっぽい。<br/>
これだとローカルでは個別に<code>.env</code>ファイルで設定した値を使用してやることが出来る。</p>

<p><code>/config/database.php</code> の冒頭に書く。</p>

<p>```
//Postgres
if (getenv(&lsquo;DATABASE_URL&rsquo;)) {</p>

<pre><code>$url = parse_url(getenv('DATABASE_URL'));
putenv('DB_HOST='.$url['host']);
putenv('DB_PORT='.$url['port']);
putenv('DB_DATABASE='.substr($url["path"], 1));
putenv('DB_USERNAME='.$url["user"]);
putenv('DB_PASSWORD='.$url['pass']);
</code></pre>

<p>}</p>

<p>//Redis
if (getenv(&lsquo;REDIS_URL&rsquo;)) {</p>

<pre><code>$url = parse_url(getenv('REDIS_URL'));
putenv('REDIS_HOST='.$url['host']);
putenv('REDIS_PORT='.$url['port']);
putenv('REDIS_PASSWORD='.$url['pass']);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Scotchbox]Ubuntuの環境でのphp.ini]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/01/11/scotchbox-phpini/"/>
    <updated>2017-01-11T18:21:48+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/01/11/scotchbox-phpini</id>
    <content type="html"><![CDATA[<p>ちょっとしたメモ。<br/>
ScotchboxのデフォルトUbuntu環境での<code>php.ini</code>の場所にハマったので、そのメモ。</p>

<!-- more -->


<h2>正解</h2>

<p>結論から書くと、以下のファイルでの設定が有効となっていた。</p>

<p><code>
/etc/php5/apache2/php.ini
</code></p>

<h2>間違い</h2>

<p>実は以下にも<code>php.ini</code>があるのだが、これの内容を変更しても反映されなかった。</p>

<p><code>
/etc/php5/cli/php.ini  //反映されない
</code></p>

<hr />

<p>そもそも何を設定したかというと、<br/>
他のUbuntu環境を知らないので、Scotchbox特有かどうかはわからないけれど、デフォルトではスーパーグローバル変数の環境変数ではる、<code>$_ENV</code> が有効となっていないため、それを有効とすべく、<code>php.ini</code>の設定を触る必要があった。</p>

<ul>
<li><a href="http://kayakuguri.github.io/blog/2015/05/26/vagrant-env/">Vagrant環境での環境変数の設定方法</a></li>
</ul>


<p>以上、メモ。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ScotchboxでのPHPエラーの出力場所]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/12/05/ubuntu-error-log/"/>
    <updated>2016-12-05T17:02:15+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/12/05/ubuntu-error-log</id>
    <content type="html"><![CDATA[<p>自分用メモ。<br/>
<a href="https://box.scotch.io/">Scotchbox</a>のVagrant環境で、PHPの標準エラー出力がどこに吐かれるかをいつも調べるのでメモ。</p>

<!-- more -->


<h1>環境</h1>

<p>環境は以下。</p>

<ul>
<li>Scotchbox 2.5</li>
<li>Ubuntu 14.04 LTS</li>
<li>PHP 5.6</li>
</ul>


<p>純粋なUbuntuでも同じ場所にログが出力されるのかは調査していないので、あくまでもScotchbox環境、とする</p>

<h1>結果</h1>

<p>結論から書くと、以下のパスに保存されていた。</p>

<p><code>
/var/log/apache2/error.log
</code></p>

<p>というわけで、<code>tail</code>する場合は以下。</p>

<p>```</p>

<h1>tail -f /var/log/apache2/error.log</h1>

<p>```</p>

<h1>設定内容</h1>

<p>出力するパスは、以下のファイルで設定されている。<br/>
<code>/etc/apache2/sites-available/000-default.conf</code></p>

<p>内容</p>

<p>```
<VirtualHost *:80></p>

<pre><code>...
ErrorLog ${APACHE_LOG_DIR}/error.log
...
</code></pre>

<p></VirtualHost><br/>
```</p>

<p><code>APACHE_LOG_DIR</code>という環境変数で設定されていることがわかる。<br/>
では、この環境変数はどこで設定しているかというと、以下のファイル。</p>

<p><code>/etc/apache2/envvars</code></p>

<p><code>
...
export APACHE_LOG_DIR=/var/log/apache2$SUFFIX
...
</code></p>

<p>というわけで、冒頭のディレクトリに保存されていた。<br/>
もし変更したい場合は上記<code>envvars</code>にて変更すればよさそう。<br/>
(パーミッションの設定を与えてやる必要はあると思う。)</p>
]]></content>
  </entry>
  
</feed>
