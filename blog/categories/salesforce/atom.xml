<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: salesforce | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/salesforce/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-08-04T18:40:08+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[salesforce] レコードのデータを取得し、CSVにしてS3にアップロードする]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/04/10/put-s3-csv-file/"/>
    <updated>2017-04-10T12:31:25+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/04/10/put-s3-csv-file</id>
    <content type="html"><![CDATA[<p>AWSで利用する事を想定し、レコードの内容をCSVファイルにしてS3にアップロードしてみたメモ。</p>

<!-- more -->


<p>SF内にCSVを生成して、そのファイルをS3にアップロード、すればいいかと思っていたが、直接CSVの内容をBodyに入れて送ってしまうことで、直接CSVファイルをS3に送信してしまう事が出来た。</p>

<h1>参考コード</h1>

<p>参考、というか、以下のコードをそのまま利用させてもらった。</p>

<ul>
<li><a href="https://github.com/darshanfarswan/haymarketCode/blob/6207a11fc072fed6dd4463b1ca4ebbbe991a232f/src/classes/S3Storage.cls">haymarketCode/src/classes/S3Storage.cls</a></li>
</ul>


<h1>CSV送信</h1>

<p>上記サンプルはテキストファイルになるので、CSVを保存するように変更。<br/>
具体的には、Bodyの内容をカンマ区切りにし、ファイルの拡張子を<code>csv</code>にし、Content-Typeを<code>text/csv</code>にする、だけ。</p>

<p>```
public with sharing class SaveCSVSample {</p>

<pre><code>public SaveCSVSample() {
    String csv_body = 'テスト1,テスト2,テスト3\r\nサンプル1,サンプル2,サンプル3';

    String fileName = 'test.csv';

    String accessId = 'xxx';
    String secretKey = 'xxx';
    String bucketName = 'user';
    String S3_Domain = 's3-ap-northeast-1.amazonaws.com';

    String dateString = Datetime.now().formatGmt('EEE, dd MMM yyyy HH:mm:ss Z');
    String stringToSign = 'PUT\n\ntext/csv\n' + dateString +'\n/' + bucketName + '/' + fileName;
    Blob mac = Crypto.generateMac('hmacSHA1',  Blob.valueOf(stringToSign), Blob.valueOf(secretKey));
    String signature = EncodingUtil.base64Encode(mac);

    HttpRequest req = new HttpRequest();
    req.setEndPoint('https://' + bucketName + '.' + S3_Domain + '/' + fileName);
    req.setHeader('Content-Type', 'text/csv');
    req.setHeader('Content-Length', String.valueOf(csv_body.length()));
    req.setHeader('Host', bucketName + '.' + S3_Domain);
    req.setHeader('Date', dateString);
    req.setHeader('Authorization','AWS ' + accessId + ':' + signature);
    req.setBody(csv_body);
    req.setMethod('PUT');

    Http httpConnection = new Http();
    HTTPResponse res = httpConnection.send(req);

    System.debug(res);
}
</code></pre>

<p>}
```</p>

<p>アップされたCSVは、改行コード <code>\r\n</code> 、文字コードは、<code>UTF-8</code>となった。</p>

<p>これでS3側にCSVファイルを作成出来るので、あとはレコードをSOQLで取得し、Bodyをカンマ区切りで作成してやればよいだけ。</p>

<h2>環境情報</h2>

<p>この例では、アクセスキーなどはベタで書いてしまっているが、実際には<a href="https://kayakuguri.github.io/blog/2016/02/01/custom-setting/">カスタム設定などで作成し</a>取得するようにした方がよい。<br/>
それだと、sandboxと本番でS3の投げ先も変更出来る。</p>

<h2>エンドポイント</h2>

<p>送信先に設定している、<code>S3_Domain</code>は現状、日本リージョンのもの。<br/>
各サービスのリージョン別のエンドポイントは以下を参考。<br/>
<a href="http://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html#s3_region">http://docs.aws.amazon.com/ja_jp/general/latest/gr/rande.html#s3_region</a></p>

<h2>ガバナ制限</h2>

<blockquote><p>ファイルサイズが3MBを超えるとApexの実行時ガバナ制限に抵触する<br/>
<a href="http://www30304u.sakura.ne.jp/blog/?p=1808">http://www30304u.sakura.ne.jp/blog/?p=1808</a></p></blockquote>

<h1>参考</h1>

<ul>
<li><a href="http://www.nkjmkzk.net/?p=2638">CORSサポートを利用したAWS S3へのアップロード方法 – Force.comバージョン</a></li>
<li><a href="http://blog.livedoor.jp/volvic_beer/archives/52481242.html">【salesforce】【apex】【aws】apexでs3にアップロードでエラーがでたよ</a></li>
<li><a href="http://dev.classmethod.jp/cloud/aws/s3-cors-upload/">WebブラウザからAmazon S3に直接ファイルをアップロードする</a></li>
<li><a href="http://docs.aws.amazon.com/ja_jp/AmazonS3/latest/dev/RESTAuthentication.html">REST リクエストの署名と認証</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[開発者コンソールで表示させるデバッグログのレベルを変更する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/04/10/change-debug-log-level/"/>
    <updated>2017-04-10T11:45:42+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/04/10/change-debug-log-level</id>
    <content type="html"><![CDATA[<p>開発者コンソールを開いていると、ログインしているユーザーのデバッグログを直接参照する事が出来る。
このログは、ログレベルがデフォルトの設定になっているが、色んなログが大量に出てしまう。</p>

<!-- more -->


<p><code>Debug Only</code>にチェックをつければ自分で出力したログだけを表示してくれたり、<code>Filter</code>機能があるのでみたいログだけに絞って表示させることは比較的容易に出来る。<br/>
しかし、そもそもログの内容が多すぎて、出力出来る最大サイズを越えてしまうことがたまにある。<br/>
そんな時は余計なログは出力させないようにデバッグレベルを調整してやる必要がある。</p>

<p><img src="/images/2017/04/debug_log_level_01.jpg" alt="" /></p>

<p>(匿名実行のログを表示させたところ）</p>

<p>開発者コンソールじゃなくて、SFの設定からデバッグログを設定してやる場合はデバッグレベル名を必須で選択するので、レベルの調整が可能なことはわかっていたが、開発者コンソールでもこのデバッグレベルを変更出来た。</p>

<h1>デバッグレベル</h1>

<p>まず、予めデバッグレベルを作成しておく。<br/>
<code>設定 -&gt; ログ -&gt; デバッグレベル</code> にアクセス。</p>

<p>新規、から作成。</p>

<p>名前は適当に設定し、レベルは欲しい情報に絞ったりして調整する。<br/>
例えば、Apexで<code>System.debug()</code>で出力したものは、Apexコードで、レベルを <code>デバッグ</code> にしておけば出力される。<br/>
(それ以外のカテゴリはなし、で問題ない）</p>

<p><img src="/images/2017/04/debug_log_level_02.jpg" alt="" /></p>

<h1>ログレベルの変更</h1>

<p>開発者コンソールのメニューから、 <code>Debug -&gt; Change Log Levels</code> を選択。<br/>
<img src="/images/2017/04/debug_log_level_03.jpg" alt="" /></p>

<p>ログレベルの選択画面がモーダルで表示される。<br/>
一番上の、<code>General Trace Settings for You</code>が、開発者コンソールで表示されるログのレベルの設定となる。<br/>
現状は、デフォルトのレベルが設定されているはずなので、一番右の項目にある、 <code>Add/Change</code> をクリック。</p>

<p><img src="/images/2017/04/debug_log_level_04.jpg" alt="" /></p>

<p>デフォルトのレベルと、先ほど設定したレベルが表示されるので、設定したレベルを選択し、<code>Done</code>をクリック。</p>

<p><img src="/images/2017/04/debug_log_level_05.jpg" alt="" /></p>

<p>実は、予めレベルをSF側から作成しなくても、ここで、<code>Add</code>して作成する事も可能。<br/>
さらに、各カテゴリのレベルもここから変更する事も出来る。</p>

<p>これで設定は完了。先ほどの匿名実行と同じ内容でログを出力してみると、大幅に内容が減っているのが確認出来る。</p>

<p><img src="/images/2017/04/debug_log_level_07.jpg" alt="" /></p>

<p>また、実はSF側のデバッグログのページを確認すると、開発者コンソールを起動させた時点で設定したデバッグレベル・ログイン中のユーザーの状態で、デバッグログが自動的にセットされている。</p>

<p><img src="/images/2017/04/debug_log_level_06.jpg" alt="" /></p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostmanでSalesforce REST APIに接続]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/12/07/sf-rest-api-postman/"/>
    <updated>2016-12-07T16:27:12+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/12/07/sf-rest-api-postman</id>
    <content type="html"><![CDATA[<p>以前まではRestAPIの接続確認には、<a href="https://apigee.com/providers">Apigee</a>を使用していたのだけれど、TLS1.0無効化の問題の影響からsandboxでは接続できなくなってしまった。<br/>
なので、代替としてちょっとめんどうだけれど、Postmanで接続してみた。</p>

<!-- more -->


<h1>アクセストークンの取得</h1>

<p>ドメインは、sandboxの場合は、 <code>test.salesforce.com</code> 、本番は、 <code>login.salesforce.com</code> となる。<br/>
今回はsandboxで試す。</p>

<p>Postmanにて、以下の内容で送信。</p>

<blockquote><p>POST : <a href="https://test.salesforce.com/services/oauth2/token">https://test.salesforce.com/services/oauth2/token</a></p></blockquote>

<ul>
<li><code>grant_type</code> : <code>password</code></li>
<li><code>client_id</code> : 接続アプリケーションのコンシューマ鍵</li>
<li><code>client_secret</code> : 接続アプリケーションのコンシューマの秘密</li>
<li><code>username</code> : 使用するアカウントのユーザ名</li>
<li><code>password</code> : パスワード。必要な場合は、パスワード+セキュリティトークン</li>
</ul>


<p><img src="/images/2016/12/sf_api_postman_01.jpg" alt="" /></p>

<p>正しくログイン出来ると以下のようにJSONが返ってくる。</p>

<p><code>
{
  "access_token": "xxx",
  "instance_url": "https://xxxx.salesforce.com",
  "id": "https://test.salesforce.com/id/xxxx/xxxx",
  "token_type": "Bearer",
  "issued_at": "xxx",
  "signature": "xxx"
}
</code></p>

<p><code>access_token</code>と<code>instance_url</code>だけ必要。</p>

<h1>APIに接続</h1>

<p>例として、オブジェクトの一覧を取得してみる。<br/>
URLのドメイン部分を先程取得した、 <code>instance_url</code> を使用する。</p>

<blockquote><p>GET : <a href="https://xxx.salesforce.com/services/data/v24.0/sobjects">https://xxx.salesforce.com/services/data/v24.0/sobjects</a></p></blockquote>

<p>ヘッダーに以下を追加。<br/>
<code>ACCESS_TOKEN</code>には先程取得した、<code>access_token</code>を使用する。</p>

<ul>
<li><code>Authorization</code> : <code>Bearer ACCESS_TOKEN</code></li>
</ul>


<p><img src="/images/2016/12/sf_api_postman_02.jpg" alt="" /></p>

<p>カスタムRestAPIの場合は以下のURLになる。<br/>
<code>hoge/hoge</code>が<code>@RestResource(urlMapping='/hoge/hoge')</code>で指定したURLとなる。</p>

<blockquote><p><a href="https://xxx.salesforce.com/services/apexrest/hoge/hoge">https://xxx.salesforce.com/services/apexrest/hoge/hoge</a></p></blockquote>

<h1>参考</h1>

<ul>
<li><a href="http://sfdcbeginner.com/how-to-test-salesforce-rest-api.html">HOW TO TEST SALESFORCE REST API</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SalesforceのREST API接続用のLaravelパッケージを使ってみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel/"/>
    <updated>2016-11-17T14:00:34+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel</id>
    <content type="html"><![CDATA[<p>Salesforce接続用のLaravel5パッケージ、<code>omniphx/forrest</code>を使ってみた。</p>

<!-- more -->


<h1>セットアップ</h1>

<p>Composerに追加。</p>

<p><code>
$ composer require "omniphx/forrest":"2.*"
</code></p>

<p><code>config/app.php</code>に以下を追加</p>

<p>```
&lsquo;providers&rsquo; => [
  // &hellip;
  Omniphx\Forrest\Providers\Laravel\ForrestServiceProvider::class,
  // &hellip;
],</p>

<p>&hellip;</p>

<p>&lsquo;aliases&rsquo; => [
  // &hellip;</p>

<pre><code>'Forrest' =&gt; Omniphx\Forrest\Providers\Laravel\Facades\Forrest::class
</code></pre>

<p>  // &hellip;
],
```
以下で設定ファイルを生成させる。</p>

<p><code>
$ php artisan vendor:publish
</code></p>

<h1>設定ファイル</h1>

<p>SFへの接続方法は２つから選択可能。</p>

<ul>
<li>Web Server authentication flow &ndash; 個別のSFアカウントでのログイン</li>
<li>Username-Password authentication flow &ndash; 接続用のアカウントを使用したログイン</li>
</ul>


<p>通常は、Username-Password authentication を利用する事が多い。</p>

<p><code>config/forrest.php</code>で以下を書き換え。</p>

<p><code>
//11行目
'authentication' =&gt; 'WebServer',
↓↓
'authentication' =&gt; 'UserPassword',
</code></p>

<p>あとは、<code>.env</code>ファイルでユーザ名やパスワード、アプリのキーなどを設定する。</p>

<p><code>
CONSUMER_KEY=xxx
CONSUMER_SECRET=xxx
LOGIN_URL=https://login.salesforce.com/
USERNAME=xxx
PASSWORD=xxx
</code></p>

<p><code>LOGIN_URL</code>を <code>https://test.salesforce.com/</code>としておくと常にsandboxへの接続となる。</p>

<h1>利用</h1>

<h2>ログイン</h2>

<p>以下でログイン。</p>

<p><code>
use Omniphx\Forrest\Providers\Laravel\Facades\Forrest;
...
Forrest::authenticate();
</code></p>

<p>(PHPStormの補完が効かない…）</p>

<h2>クエリの発行</h2>

<p><code>
Forrest::query('SELECT Id FROM Account');
</code></p>

<h2>レコードの作成など</h2>

<p>```
$body = [&lsquo;Name&rsquo; => &lsquo;New Account&rsquo;];
Forrest::sobjects(&lsquo;Account&rsquo;,[</p>

<pre><code>'method' =&gt; 'post',
'body'   =&gt; $body]);
</code></pre>

<p>```</p>

<p><code>sobjects</code>で第一引数にオブジェクトを指定し、第二引数に送信する内容を指定する。<br/>
送信内容は配列でキーを指定してやればよい。<br/>
<code>method</code>はそれぞれ以下。</p>

<ul>
<li>post &ndash; 作成</li>
<li>put &ndash; 更新</li>
<li>patch &ndash; アップサート</li>
<li>delete &ndash; 削除</li>
</ul>


<p>削除の場合は以下のようにREST形式でSFIDを指定してやる。</p>

<p><code>
Forrest::sobjects('Account/001i000000xxx', ['method' =&gt; 'delete']);
</code></p>

<h2>トークンの操作</h2>

<ul>
<li>リフレッシュ &ndash; <code>refresh()</code></li>
<li>廃止 &ndash; <code>revoke()</code></li>
</ul>


<h2>カスタムエンドポイント</h2>

<p>以下の様のして送信する。</p>

<p>```
Forrest::custom(&lsquo;/myEndpoint&rsquo;, [</p>

<pre><code>'method' =&gt; 'post',
'body' =&gt; ['foo' =&gt; 'bar'],
'parameters' =&gt; ['flim' =&gt; 'flam']]);
</code></pre>

<p>```</p>

<p>その他は、GitHubのReadme参照。</p>

<h1>参考</h1>

<ul>
<li><a href="https://github.com/omniphx/forrest">omniphx/forrest: Salesforce.com REST API Client for Laravel 5</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Salesforce] Let’s Encryptの証明書ではSFからのコールアウトを受けられない]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/08/10/sf-lets-encrypt/"/>
    <updated>2016-08-10T11:49:42+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/08/10/sf-lets-encrypt</id>
    <content type="html"><![CDATA[<p>Let’s Encryptで取得した証明書を適用させたサイトへコールアウトしたところエラーが発生し接続出来なかったので、調査してみた。</p>

<!-- more -->


<h1>エラー内容</h1>

<p>エラーは下記の内容。</p>

<blockquote><p>System.CalloutException: sun.security.validator.ValidatorException: <br/>
PKIX path building failed: <br/>
sun.security.provider.certpath.SunCertPathBuilderException: <br/>
unable to find valid certification path to requested target</p></blockquote>

<p>エラー内容で調べてみると、自己証明書、ではSFからのアクセスが出来ない、という情報があり、その中で紹介されているエラーが上記内容と酷似していることがわかった。</p>

<p><a href="http://appirio.co.jp/category/tech-blog/2013/05/apex%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%A2%E3%82%A6%E3%83%88%E3%81%AE%E3%83%99%E3%82%B9%E3%83%88%E3%83%97%E3%83%A9%E3%82%AF%E3%83%86%E3%82%A3%E3%82%B9part-2/">Apexコールアウトのベストプラクティス:Part 2 &ndash; Appirio Japan</a></p>

<p>しかし、Let’s Encryptは自己証明書ではない…。</p>

<h1>SFが許可するCA</h1>

<p>引き続き調べてみると、どうやらsalesforceは接続出来る認証局 (CA) をホワイトリスト方式で設定しているよう。</p>

<p><a href="https://help.salesforce.com/HTViewSolution?id=000007225&amp;language=en_US">Salesforce.com SSL certificates Salesforce supports</a></p>

<p>以下が許可されている認証局のリスト。</p>

<p><a href="https://developer.salesforce.com/page/Outbound_Messaging_SSL_CA_Certificates">Outbound Messaging SSL CA Certificates &ndash; developer.force.com</a></p>

<p>このリストには、Let’s Encryptがない。<br/>
というわけで、SFがLet’s Encrypt認証局が作成した証明書を適用したサイトへの接続は許可していない、ということになり、冒頭のエラーが発生していた、ということになる。</p>

<p>ちなみに、Let’s Encryptの認証局をリストに加えてほしい、という要望は結構前から上がっているよう。</p>

<p><a href="https://success.salesforce.com/ideaView?id=08730000000E28LAAS">Support Let&rsquo;s Encrypt CA Certificate &ndash; Ideas &ndash; Salesforce Success Community</a></p>

<p>対応する気はないのか、まだ手が回ってないだけなのか…。</p>

<h1>参考</h1>

<ul>
<li><a href="https://jp.globalsign.com/service/knowledge/ca/">認証局 （CA：Certification Authority）とは？ | SSL・電子証明書ならGMOグローバルサイン</a></li>
<li><a href="http://qiita.com/kawaz/items/f90810b9ea823b6556a8">認証局を立ててぼろもうけしたいんですが＞無理な理由を理解しよう &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
