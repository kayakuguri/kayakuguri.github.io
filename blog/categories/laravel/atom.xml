<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: laravel | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/laravel/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-12-13T11:17:49+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HerokuでLaravel-Mixを利用する際の環境変数]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/12/13/laravel-mix-heroku-env/"/>
    <updated>2017-12-13T11:08:35+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/12/13/laravel-mix-heroku-env</id>
    <content type="html"><![CDATA[<p>HerokuでLaravel Mixを使っている際に、ビルドに失敗する時があり調べた結果、環境変数を追加するだけで対策出来たのでメモ。</p>

<!-- more -->


<h1>症状</h1>

<p>Herokuのビルドパックには <code>heroku/nodejs</code>と<code>heroku/php</code>を入れておき、順番はnode.jsが先。</p>

<p><code>
$ heroku buildpacks -a app-name
=== app-name Buildpack URLs
1. heroku/nodejs
2. heroku/php
</code></p>

<p>この状態でpushしてデプロイするも、npmのインストールなどは走るがLaravel Mixのコンパイルが走らない状態(たぶん）。<br/>
ビルドログを見ると以下のようなエラーが出ている。</p>

<p><code>
Additional dependencies must be installed. This will only take a moment.
warning " &gt; browser-sync-webpack-plugin@1.2.0" has unmet peer dependency "webpack@^1 || ^2 || ^3".
Finished. Please run Mix again.
</code></p>

<p>依存関係が解消出来てないとかなんとか？</p>

<h1>解決策</h1>

<p>ググると以下の情報。</p>

<p>環境変数に、<code>YARN_PRODUCTION</code>を<code>false</code>で追加してやるだけ。</p>

<ul>
<li><a href="https://www.neontsunami.com/posts/using-laravel-mix-on-heroku">Using Laravel Mix on Heroku &mdash; Neon Tsunami</a></li>
</ul>


<p>環境変数を追加してやることで、<code>devDependencies</code>から依存関係を取得するように指示してやる事が出来るよう。</p>

<blockquote><p>First, set <code>YARN_PRODUCTION</code> to false using the following command. This tells Heroku to install the devDependencies in your package.json, but leaves NODE_ENV as production.</p></blockquote>

<p>Google翻訳</p>

<blockquote><p>まず、次のコマンドを使用して<code>YARN_PRODUCTION</code>をfalseに設定します。これは、あなたのpackage.jsonにdevDependenciesをインストールするようにHerokuに指示しますが、NODE_ENVをプロダクションとして残します。</p></blockquote>

<p>記事の通り、上手く行ってなかった環境に環境変数を追加してやると無事、コンパイルされるようになった。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[laravel5.5でajaxでPOST通信する時のCSRFトークン]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/12/06/laravel-ajax-csrf/"/>
    <updated>2017-12-06T20:46:06+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/12/06/laravel-ajax-csrf</id>
    <content type="html"><![CDATA[<p>Laravel5.5にて、ajaxでPOST通信する際にCSRFトークンも送る方法のメモ。</p>

<!-- more -->


<h1>概要</h1>

<p>LaravelではデフォルトではPOST通信には全てCSRFトークンをつけてやる必要がある。<br/>
ajaxでの通信でも例外ではない。<br/>
なので、そのまま何も考えずにajaxを使うとそこで引っかかってしまう。</p>

<h1>方法</h1>

<p>方法としては(主に)2つ。</p>

<ul>
<li>送信するURLはCSRFトークンの対象外としてやる</li>
<li>ajax通信の際にもCSRFトークンを送る</li>
</ul>


<p>もちろん後者の方が安全。</p>

<h1>CSRFトークンの追加</h1>

<p>HTMLのmetaタグにCSRFトークンをおいてやり、それを取得して送る。<br/>
POST送信の<code>_token</code>パラメータに入れてやるだけでよい。</p>

<ul>
<li><a href="https://laracasts.com/discuss/channels/requests/laravel-5-cant-use-ajax-post-request">Laravel 5 can&#039;t use ajax post request</a></li>
</ul>


<p>```
<meta name="csrf-token" content="" /></p>

<p>var CSRF_TOKEN = $(&lsquo;meta[name=&ldquo;csrf-token&rdquo;]&rsquo;).attr(&lsquo;content&rsquo;);</p>

<p>$.ajax({</p>

<pre><code>url: '/home/upload/',
type: 'POST',
data: {_token: CSRF_TOKEN},
dataType: 'JSON',
success: function (data) {
    console.log(data);
}
</code></pre>

<p>});
```</p>

<p>公式のドキュメントにも方法は載っているが、これは、Axios HTTPライブラリを使った方法？のよう。<br/>
上記でないと上手く動作しなかったが…やり方が悪いのかもしれない。</p>

<ul>
<li><a href="https://readouble.com/laravel/5.5/ja/csrf.html#csrf-x-csrf-token">X-CSRF-TOKEN | Laravel 5.5 CSRF保護</a></li>
</ul>


<h1>トークン対象外</h1>

<p>一応、トークンの対象外とする方法も。</p>

<p><code>app/http/Middleware/VerifyCsrfToken.php</code>内にて指定してやる。</p>

<p>```
protected $except = [</p>

<pre><code>'ajax/post/path/*',
</code></pre>

<p>];
```</p>

<ul>
<li><a href="https://readouble.com/laravel/5.5/ja/csrf.html#csrf-excluding-uris">URIの除外 | Laravel5.5 CSRF通信</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CSVのテキストからLaravelのSeeder用コードを作る]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/10/30/larave-csv-seeder/"/>
    <updated>2017-10-30T10:26:29+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/10/30/larave-csv-seeder</id>
    <content type="html"><![CDATA[<p>CSVのテキストをLaravelのseeder、というか、クエリビルダに変換したかったのでツールを作った。</p>

<!-- more -->


<p><a href="https://laravel-csv-seeder.herokuapp.com/">Laravel CSV Seeder</a></p>

<h1>使い方</h1>

<p><code>Table name</code>にはテーブル名を入れる。<br/>
(何も入れなかった場合はダミーの文字が入る)</p>

<p><code>CSV Format Text</code>にはカンマと改行区切りのCSVフォーマットのテキストを入力する。</p>

<p><code>convert</code>ボタンを押すと、その下のテキストエリアに出力結果が表示される。</p>

<h2>CSVの仕様</h2>

<ul>
<li>項目ごとはカンマ区切り</li>
<li>行は改行区切り</li>
<li>行は以下の仕様

<ul>
<li>1行目 : 日本語項目名。変換後のコードには使用されません</li>
<li>2行目 : 項目名。キーとして使用されます</li>
<li>3行目以降 : インサートされる内容</li>
</ul>
</li>
</ul>


<h2>Github</h2>

<p>コードはGithubにあげた。</p>

<p><a href="https://github.com/k-usk/laravel-csv-seeder">https://github.com/k-usk/laravel-csv-seeder</a></p>

<p>無駄にHeroku Buttonも付けたので自分の環境で動かしたいという人がいたらどうぞ。</p>

<h1>説明</h1>

<p>CSVを読み込んで整形してるだけなんでたいしたことはしてない。<br/>
CSVの整形には以下のライブラリを使用した。</p>

<ul>
<li><a href="http://csv.thephpleague.com/">league/csv</a></li>
</ul>


<h2>その他</h2>

<p>同じようなツールがないか調べたりはしたのだが、CSVをそのままSeederとして使えるものはいくつかあった。</p>

<ul>
<li><a href="https://github.com/Flynsarmy/laravel-csv-seeder">Flynsarmy/laravel-csv-seeder</a></li>
<li><a href="https://github.com/andycrockett/laravel-csv-seeder">andycrockett/laravel-csv-seeder</a></li>
</ul>


<p>後は、エクセルファイルをLaravelで扱うための便利パッケージとか。<br/>
エクセルを作ったりそのまま読み込めたりするよう。これはこれでかなり有用そう。</p>

<ul>
<li><a href="https://github.com/Maatwebsite/Laravel-Excel/blob/2.1/README.md">Maatwebsite/Laravel-Excel</a></li>
<li><a href="https://blog.motimotilab.com/?p=68">Laravel Excelの紹介（Laravel：Excelファイル入出力ライブラリ）</a></li>
</ul>


<p>ただし今回はそこまでのツールではなく、また、アプリ本体にそういう機能は組み込みたくなかったため、別のツールとして作成した。</p>

<h1>参考</h1>

<ul>
<li><a href="https://readouble.com/laravel/5.5/ja/queries.html">Laravel 5.5 データベース：クエリビルダ</a></li>
<li><a href="http://csv.thephpleague.com/9.0/reader/">league/csv cocument</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravelでロードバランサを挟んだ時のisSecure判定を動作させる]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/10/27/laravel-https-loadbalancer/"/>
    <updated>2017-10-27T15:28:33+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/10/27/laravel-https-loadbalancer</id>
    <content type="html"><![CDATA[<p>Laravelの小ネタ。<br/>
ELBなどのロードバランサを挟むと <code>Request</code> の <code>isSecure</code> が正しく動作してくれなかったのでメモ。</p>

<!-- more -->


<p>ブレードでリンクを生成する時に、<code></code>と記述して組み立てていたのだが、ローカル環境では正しく<code>https</code>のURLで絶対パスが指定されていたのに、herokuにアップした途端に<code>http</code>で生成されるようになってしまった。</p>

<p><code>Request</code>の<code>root()</code>がどうやって判定しているのかを辿っていくと、<code>getScheme()</code>というRequestの関数内で、以下のように判定して取得していた。</p>

<p>```
public function getScheme()
{</p>

<pre><code>return $this-&gt;isSecure() ? 'https' : 'http';
</code></pre>

<p>}
```</p>

<p>よってこの、<code>isSecure</code>が正しく動作していないと思われる。<br/>
Herokuはロードバランサが標準で入っているため、その辺りだろうとググってみると公式ドキュメントがヒット。</p>

<blockquote><p>TLS／SSL証明を行うロードバランサの裏でアプリケーションが実行されている場合、アプリケーションが時々HTTPSリンクを生成しないことに、気づくでしょう。典型的な理由は、トラフィックがロードバランサにより８０番ポートへフォワーディングされるため、セキュアなリンクを生成すべきだと判断できないからです。</p></blockquote>

<ul>
<li><a href="https://readouble.com/laravel/5.5/ja/requests.html">Laravel 5.5 HTTPリクエスト</a> 最下部の、信用するプロキシの設定</li>
</ul>


<p>まさにこの通りで、<code>app/Http/Middleware/TrustProxies.php</code>で全てのプロキシを信用するようにしたところ、無事、<code>https</code>で生成されるようになった。</p>

<p><code>
protected $proxies = '**';
</code></p>

<blockquote><p>Amazon AWSや他の「クラウド」ロードバランサプロバイダを使用している場合は、実際のバランサのIPアドレスは分かりません。このような場合、全プロキシを信用するために、**を使います。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel Passportのクライアント認証を試してみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/10/20/laravel-passport-sample/"/>
    <updated>2017-10-20T14:01:59+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/10/20/laravel-passport-sample</id>
    <content type="html"><![CDATA[<p>Laravel Passportを使ってAPIからのアクセスにOAuth認証をかけたい。<br/>
一般に公開するものではなく、特定のクライアントからのアクセスのみを想定する。<br/>
そのため、ユーザデータは使用しない。</p>

<!-- more -->


<h2>インストール</h2>

<p>Laravel Passportをインストール。</p>

<p><code>
$ composer require laravel/passport
</code></p>

<p>Package Auto-Discovery に対応しているため、プロバイダに追加してやる作業は必要ない。</p>

<ul>
<li><a href="https://laravel-news.com/package-auto-discovery">Laravel Package Auto-Discovery &ndash; Laravel News</a></li>
</ul>


<h2>セットアップ</h2>

<p>DBに必要なテーブルを作成する。</p>

<p><code>
$ php artisan migrate
</code></p>

<p>OAuth用に以下のテーブルが作成される。</p>

<ul>
<li><code>oauth_access_tokens</code></li>
<li><code>oauth_auth_codes</code></li>
<li><code>oauth_clients</code></li>
<li><code>oauth_personal_access_clients</code></li>
<li><code>oauth_refresh_tokens</code></li>
</ul>


<p>トークン作成時に使用されるキーを生成する。</p>

<p><code>
$ php artisan passport:install
</code></p>

<p>キーは、<code>/storage/</code>以下に生成される。<br/>
デフォルトでは<code>.gitignore</code>で無視する設定となっているので注意。<br/>
また、公開リポジトリにアップしてはいけない。<br/>
対処法などは以下参考。</p>

<ul>
<li><a href="https://qiita.com/kawax/items/59fde47056816cec52ec">Laravel Passport keyファイルの扱い &ndash; Qiita</a></li>
</ul>


<p>また、キーの生成とともに、DBにクライアントが作成される。</p>

<p><code>
Encryption keys generated successfully.
Personal access client created successfully.
Client ID: 1
Client Secret: tR7FSAHLQ8qw1xIgEWMKQ26QK2nKUxHahSHvY3RW
Password grant client created successfully.
Client ID: 2
Client Secret: 6n4TGzdrJHYdEJwPoMsaYuCA9EaFpXiGFr4dMVc8
</code></p>

<p>一つ目が、 <code>Laravel Personal Access Client</code><br/>
二つ目が、<code>Laravel Password Grant Client</code></p>

<p>二つ目はユーザ名＋パスワードを利用したアクセストークンの発行に利用出来る。<br/>
(ユーザーとの紐付けは特に必要なし)<br/>
(必要なければ消しておいてもよい)</p>

<h3>コードに追加</h3>

<h4><code>AuthServiceProvider.php</code>に追加</h4>

<p><code>/app/Providers/AuthServiceProvider.php</code></p>

<p>```
public function boot()
{</p>

<pre><code>$this-&gt;registerPolicies();

Passport::routes();
</code></pre>

<p>}
```</p>

<h4><code>auth.php</code>のdriverをpassportに変更</h4>

<p><code>/config/auth.php</code></p>

<p>```
&lsquo;guards&rsquo; => [</p>

<pre><code>'web' =&gt; [
    'driver' =&gt; 'session',
    'provider' =&gt; 'users',
],

'api' =&gt; [
    'driver' =&gt; 'passport',
    'provider' =&gt; 'users',
],
</code></pre>

<p>],
```</p>

<h2>クライアント認証情報グラントトークン</h2>

<p>冒頭の趣旨を実現するために、マシン-マシン間の認証に最適、という認証方式を採用する。</p>

<h4><code>Kanel.php</code>に追加</h4>

<p><code>/app/Http/Kanel.php</code></p>

<p>```
protected $routeMiddleware = [</p>

<pre><code>...
'client' =&gt; CheckClientCredentials::class,
</code></pre>

<p>];<br/>
```</p>

<h2>アクセストークンの取得</h2>

<p>以下にアクセスして取得出来る。</p>

<p>・リクエスト</p>

<p><code>
POST : /oauth/token
</code></p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> <code>grant_type</code> </td>
<td align="left"> <code>client_credentials</code> |</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>client_id</code> </td>
<td align="left"> 発行したクライアントのID(数字) |</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>client_secret</code> </td>
<td align="left"> 発行したクライアントのシークレット |</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>scope</code> </td>
<td align="left"> アクセスするスコープ |</td>
</tr>
</tbody>
</table>


<p>・レスポンス</p>

<p>```
{</p>

<pre><code>"token_type": "Bearer",
"expires_in": 31536000,
"access_token": "YOUR-ACCESS-TOKEN-HERE"
</code></pre>

<p>}
```</p>

<p>発行されたトークンは、<code>oauth_access_tokens</code>テーブルに格納されていく。</p>

<h3>有効期限</h3>

<p>デフォルトではトークンの有効期限は１年間となっている。</p>

<p>変更するには、<code>AuthServiceProvider</code>の<code>boot</code>メソッドから変更可能。</p>

<p><code>/app/Providers/AuthServiceProvider.php</code></p>

<p>```
public function boot()
{</p>

<pre><code>$this-&gt;registerPolicies();

Passport::routes();
Passport::tokensExpireIn(Carbon::now()-&gt;addMinute(60));
Passport::refreshTokensExpireIn(Carbon::now()-&gt;addHour(2));
</code></pre>

<p>}
```</p>

<h2>APIへのアクセス</h2>

<p>上記トークンを使用してアクセス制限をかけたAPIへアクセスする。</p>

<h3>ルートに追加</h3>

<p>追加したミドルウェアを使用して、apiのルートにこの認証で使用するエンドポイントのリクエストを追加。</p>

<p><code>/routes/api.php</code></p>

<p>```
Route::get(&lsquo;/hoge&rsquo;, function (){</p>

<pre><code>return 'OK';
</code></pre>

<p>})&ndash;>middleware(&lsquo;client&rsquo;);
```</p>

<h3>アクセス</h3>

<p>apiのルーティングは、<code>/api</code>以下に作成される。<br/>
よって、エンドポイントは以下になる</p>

<p><code>
GET : /api/hoge
</code></p>

<p>ヘッダにアクセストークンを付与してアクセスする。</p>

<ul>
<li>Authorization : <code>Bearer YOUR-ACCESS-TOKEN</code></li>
</ul>


<h4>エラー</h4>

<p>アクセストークンが間違っているなどの場合は、<code>InvalidArgumentException</code>が発生する。</p>

<h1>参考</h1>

<ul>
<li><a href="https://readouble.com/laravel/5.5/ja/passport.html">API認証(Passport) 5.5 Laravel</a></li>
<li><a href="https://qiita.com/niiyz/items/fffff94acb6061ecc9d4">Laravel5.5でAPI認証のパッケージ(Laravel Passport)を利用する &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
