<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: laravel | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/laravel/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-04-11T18:17:07+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Laravel]フォームのバリデーションをRequestクラスに分離する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/11/18/larave-request/"/>
    <updated>2016-11-18T17:46:52+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/11/18/larave-request</id>
    <content type="html"><![CDATA[<p>LaraveのバリデーションチェックをRequestクラスの別ファイルにまとめる方法。<br/>
すでに各所で解説が書かれているだろうけれど、自分なりに把握出来たのでメモ。</p>

<!-- more -->


<h1>作成</h1>

<h2>生成</h2>

<p><code>
$ php artisan make:request HogeRequest
</code></p>

<p>これで、<code>app/Http/Requests/</code>以下に生成される。</p>

<p>デフォルトで生成される内容は以下。</p>

<p>```
&lt;?php</p>

<p>namespace App\Http\Requests;</p>

<p>use App\Http\Requests\Request;</p>

<p>class HogeRequest extends Request
{</p>

<pre><code>/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    return false;
}

/**
 * Get the validation rules that apply to the request.
 *
 * @return array
 */
public function rules()
{
    return [
        //
    ];
}
</code></pre>

<p>}
```</p>

<h2>認証</h2>

<p>一つ目のメソッド、<code>authorize</code>はデフォルトでは<code>false</code>となっている。<br/>
これは、このフォームを送信出来るユーザの認証を判定する箇所で、デフォルトの<code>false</code>だと全てのユーザが弾かれてしまう。<br/>
なのでこれは<code>true</code>に変更する。</p>

<h2>バリデーションルール</h2>

<p>肝心のバリデーションルールは、<code>rules()</code>メソッド内の戻り値として書く。<br/>
配列にコントローラーに書いていた時と同じように書く。</p>

<p>例）</p>

<p>```
public function rules()
{</p>

<pre><code>return [
    'LastName' =&gt; 'required',
    'FirstName' =&gt; 'required',
    'Email' =&gt; 'required|email',
];
</code></pre>

<p>}
```</p>

<h2>項目の名前 (日本語化)</h2>

<p>バリデーションルールに引っかかった際に返されるエラーメッセージはデフォルトでは英語になっている。<br/>
これを日本語にするには、言語ファイルを用意してやるとよい。<br/>
<code>resouces/lang/ja/</code>以下に、<code>validation.php</code>を置いてやる。<br/>
以下が、デフォルトの英語ファイルを日本語訳してくれているもの。<br/>
<a href="https://gist.github.com/syokunin/b37725686b5baf09255b">https://gist.github.com/syokunin/b37725686b5baf09255b</a></p>

<p>しかしこのままだと、項目名についてはnameで指定したもののママになってしまう。<br/>
これをカスタムで日本語化するには、さきほど追加した、<code>validation.php</code>の<code>attributes</code>で指定してやる。</p>

<p>例）</p>

<p>```
&lsquo;attributes&rsquo; => [</p>

<pre><code>'title' =&gt; 'タイトル',
'body' =&gt; '本文',
'published_at' =&gt; '公開日',
</code></pre>

<p>],
```</p>

<ul>
<li><a href="https://laravel10.wordpress.com/2015/03/11/%E5%88%9D%E3%82%81%E3%81%A6%E3%81%AElaravel-5-19-%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8C%96/">初めてのLaravel 5.1 : (19) エラーメッセージの日本語化 &#8211; ララ帳</a></li>
</ul>


<p>ここでの設定は全体での適用となるので、一括指定出来る反面、切り分けが出来ない。<br/>
これを各フォーム個別の設定としてやるために、先ほどの、Requestクラスに追加してやることが可能。</p>

<p>例）</p>

<p>```
public function attributes()
{</p>

<pre><code>return [
    'name'    =&gt; 'お名前',
    'email'   =&gt; 'メールアドレス',
    'subject' =&gt; '件名',
    'content' =&gt; '内容',
];
</code></pre>

<p>}
```</p>

<ul>
<li><a href="http://qiita.com/ponko2/items/fd7ac38b964e10f16f52#%E3%81%8A%E5%95%8F%E3%81%84%E5%90%88%E3%82%8F%E3%81%9B%E7%94%BB%E9%9D%A2%E3%81%AErequest">Laravel 5で確認画面付き問い合わせフォームを作る &ndash; Qiita</a></li>
</ul>


<h2>戻り先</h2>

<p>デフォルトの状態では、バリデーションエラーがあった場合は一つ前のページへ自動的に遷移する。<br/>
入力 → 確認 という遷移なら、確認に遷移してきた時点でエラーが出ると、一つ前の入力ページへ飛ぶ。</p>

<p>しかし、確認画面を挟むようなフォームの場合、確認画面から完了画面の際にもバリデーションチェックが必要となる。<br/>
これがデフォルトのままだと、<br/>
確認 → 完了 という遷移となり、エラーが出ると一つ前の確認画面に戻ってしまう。<br/>
ここでは入力画面に戻って欲しい。</p>

<p>その場合、Requestクラスで戻り先を指定してやる事が出来る。</p>

<p><code>
protected $redirect = 'hoge_input';
</code></p>

<p>変数名で指定の仕方を変えてやることが可能。</p>

<ul>
<li><code>redirect</code> &ndash; URIでの指定</li>
<li><code>redirectRoute</code> &ndash; 名前付きルートの名前での指定</li>
<li><code>redirectAction</code> &ndash; コントローラーのアクションでの指定</li>
</ul>


<p>[参考]</p>

<ul>
<li><a href="http://n2utech.hatenablog.jp/entry/2015/11/13/154754">【メモ】 Laravel 5.1 において FormRequest でエラーが発生した際の戻し先を変更する &ndash; n2utech</a></li>
<li><a href="https://github.com/laravel/framework/blob/5.1/src/Illuminate/Foundation/Http/FormRequest.php#L34-L53">framework/FormRequest.php at 5.1 · laravel/framework · GitHub</a></li>
</ul>


<h1>完成</h1>

<p>最終的に以下のような形とした。</p>

<p>```
&lt;?php</p>

<p>namespace App\Http\Requests;</p>

<p>use App\Http\Requests\Request;</p>

<p>class HogeRequest extends Request
{</p>

<pre><code>/**
 * 戻り先
 *
 * @var string
 */
protected $redirect = 'hoge_input';

/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    return true;
}

/**
 * バリデーションルール
 *
 * @return array
 */
public function rules()
{
    return [
        'LastName' =&gt; 'required',
        'FirstName' =&gt; 'required',
        'Email' =&gt; 'required|email',
    ];
}

/**
 * エラー時に表示する項目名
 *
 * @return array
 */
public function attributes()
{
    return [
        'LastName' =&gt; '姓',
        'FirstName' =&gt; '名',
        'Email' =&gt; 'メールアドレス',
    ];
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SalesforceのREST API接続用のLaravelパッケージを使ってみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel/"/>
    <updated>2016-11-17T14:00:34+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel</id>
    <content type="html"><![CDATA[<p>Salesforce接続用のLaravel5パッケージ、<code>omniphx/forrest</code>を使ってみた。</p>

<!-- more -->


<h1>セットアップ</h1>

<p>Composerに追加。</p>

<p><code>
$ composer require "omniphx/forrest":"2.*"
</code></p>

<p><code>config/app.php</code>に以下を追加</p>

<p>```
&lsquo;providers&rsquo; => [
  // &hellip;
  Omniphx\Forrest\Providers\Laravel\ForrestServiceProvider::class,
  // &hellip;
],</p>

<p>&hellip;</p>

<p>&lsquo;aliases&rsquo; => [
  // &hellip;</p>

<pre><code>'Forrest' =&gt; Omniphx\Forrest\Providers\Laravel\Facades\Forrest::class
</code></pre>

<p>  // &hellip;
],
```
以下で設定ファイルを生成させる。</p>

<p><code>
$ php artisan vendor:publish
</code></p>

<h1>設定ファイル</h1>

<p>SFへの接続方法は２つから選択可能。</p>

<ul>
<li>Web Server authentication flow &ndash; 個別のSFアカウントでのログイン</li>
<li>Username-Password authentication flow &ndash; 接続用のアカウントを使用したログイン</li>
</ul>


<p>通常は、Username-Password authentication を利用する事が多い。</p>

<p><code>config/forrest.php</code>で以下を書き換え。</p>

<p><code>
//11行目
'authentication' =&gt; 'WebServer',
↓↓
'authentication' =&gt; 'UserPassword',
</code></p>

<p>あとは、<code>.env</code>ファイルでユーザ名やパスワード、アプリのキーなどを設定する。</p>

<p><code>
CONSUMER_KEY=xxx
CONSUMER_SECRET=xxx
LOGIN_URL=https://login.salesforce.com/
USERNAME=xxx
PASSWORD=xxx
</code></p>

<p><code>LOGIN_URL</code>を <code>https://test.salesforce.com/</code>としておくと常にsandboxへの接続となる。</p>

<h1>利用</h1>

<h2>ログイン</h2>

<p>以下でログイン。</p>

<p><code>
use Omniphx\Forrest\Providers\Laravel\Facades\Forrest;
...
Forrest::authenticate();
</code></p>

<p>(PHPStormの補完が効かない…）</p>

<h2>クエリの発行</h2>

<p><code>
Forrest::query('SELECT Id FROM Account');
</code></p>

<h2>レコードの作成など</h2>

<p>```
$body = [&lsquo;Name&rsquo; => &lsquo;New Account&rsquo;];
Forrest::sobjects(&lsquo;Account&rsquo;,[</p>

<pre><code>'method' =&gt; 'post',
'body'   =&gt; $body]);
</code></pre>

<p>```</p>

<p><code>sobjects</code>で第一引数にオブジェクトを指定し、第二引数に送信する内容を指定する。<br/>
送信内容は配列でキーを指定してやればよい。<br/>
<code>method</code>はそれぞれ以下。</p>

<ul>
<li>post &ndash; 作成</li>
<li>put &ndash; 更新</li>
<li>patch &ndash; アップサート</li>
<li>delete &ndash; 削除</li>
</ul>


<p>削除の場合は以下のようにREST形式でSFIDを指定してやる。</p>

<p><code>
Forrest::sobjects('Account/001i000000xxx', ['method' =&gt; 'delete']);
</code></p>

<h2>トークンの操作</h2>

<ul>
<li>リフレッシュ &ndash; <code>refresh()</code></li>
<li>廃止 &ndash; <code>revoke()</code></li>
</ul>


<h2>カスタムエンドポイント</h2>

<p>以下の様のして送信する。</p>

<p>```
Forrest::custom(&lsquo;/myEndpoint&rsquo;, [</p>

<pre><code>'method' =&gt; 'post',
'body' =&gt; ['foo' =&gt; 'bar'],
'parameters' =&gt; ['flim' =&gt; 'flam']]);
</code></pre>

<p>```</p>

<p>その他は、GitHubのReadme参照。</p>

<h1>参考</h1>

<ul>
<li><a href="https://github.com/omniphx/forrest">omniphx/forrest: Salesforce.com REST API Client for Laravel 5</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel HomesteadのPostgreSQLにPosticoから接続する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/06/09/homestead-postgres-via-homestead/"/>
    <updated>2016-06-09T14:56:23+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/06/09/homestead-postgres-via-homestead</id>
    <content type="html"><![CDATA[<p>まとまって情報がなかったのでメモ。</p>

<!-- more -->


<h1>SSH</h1>

<p>ssh接続する際のユーザー名・パスワードは、デフォルトでは、<code>vagrant/vagrant</code>のよう。
ユーザー名はホスト名とは別で、vagrantを立ち上げた状態で以下のコマンドで確認出来た。</p>

<p><code>
$ vagrant ssh-config
Host default
  HostName 127.0.0.1
  User vagrant
  Port 2222
  UserKnownHostsFile /dev/null
  StrictHostKeyChecking no
  PasswordAuthentication no
  IdentityFile /Users/USER_NAME/Vagrant/app_folder/.vagrant/machines/default/virtualbox/private_key
  IdentitiesOnly yes
  LogLevel FATAL
  ForwardAgent yes
</code></p>

<p>この中の、<code>User vagrant</code>という部分。</p>

<p>SSH Hostは、<code>Homestead.yaml</code>で指定したip。
デフォルトは、<code>192.168.10.10</code>だと思う。</p>

<p><code>
ip: "192.168.10.10"
</code></p>

<h1>Postgres</h1>

<p>Postgresはデフォルトでは以下の設定になっている。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left">ホスト名 </td>
<td align="left"> localhost </td>
</tr>
<tr>
<td></td>
<td align="left"> DB名 </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> ユーザー名 </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> パスワード </td>
<td align="left"> secret </td>
</tr>
</tbody>
</table>


<h1>Postico</h1>

<p>Posticoから接続する際には、Optionsから、<code>Connect via SSH</code>を選択してSSH接続設定をしておく。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> Nickname </td>
<td align="left"> (なんでも) </td>
</tr>
<tr>
<td></td>
<td align="left"> Host </td>
<td align="left"> localhost (デフォルト) </td>
</tr>
<tr>
<td></td>
<td align="left"> Port </td>
<td align="left"> 5432 (デフォルト) </td>
</tr>
<tr>
<td></td>
<td align="left"> User </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> Password </td>
<td align="left"> secret </td>
</tr>
<tr>
<td></td>
<td align="left"> Database </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> SSH Host </td>
<td align="left"> 192.168.10.10 </td>
</tr>
<tr>
<td></td>
<td align="left"> Port </td>
<td align="left"> 22 (デフォルト) </td>
</tr>
<tr>
<td></td>
<td align="left"> User </td>
<td align="left"> vagrant </td>
</tr>
<tr>
<td></td>
<td align="left"> Password </td>
<td align="left"> vagrant </td>
</tr>
<tr>
<td></td>
<td align="left"> Private Key </td>
<td align="left"> なし </td>
</tr>
</tbody>
</table>


<p><img src="/images/2016/06/postico_homestead.jpg" alt="" /></p>

<p>これで接続出来た。</p>

<h1>参考</h1>

<ul>
<li><a href="https://laravel.com/docs/5.1/homestead">Laravel Homestead</a></li>
<li><a href="http://qiita.com/megane42/items/1d8ae7444d8c1b10bbd7">Vagrant で作った VM にやってはいけない2つのこと &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lumenのテーブル名を既存のものに合わせる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/01/05/lumen-eloquent/"/>
    <updated>2016-01-05T17:37:23+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/01/05/lumen-eloquent</id>
    <content type="html"><![CDATA[<p>lumenやlaravelではモデル名が単数形で、DBのテーブル名はその複数形、が基本の仕様となっている。<br/>
なので、新規にテーブル名を作成する場合や、テーブル名が複数形であればとくに問題ないのだが、<br/>
既存のテーブル名を利用する際に単数形となってしまっている時には明示的に指定してやる必要がある。<br/>
指定は<code>Eloquent</code>を利用してやる。</p>

<!-- more -->


<blockquote><p>Eloquentとは、PHPフレームワークのLaravelに最初から含まれているORM（Object-relational mapping:オブジェクト関係マッピング）です。</p></blockquote>

<h2>lumenでの利用</h2>

<p>lumenではデフォルトではEloquentの利用がオフになっている。<br/>
なので、<code>bootstrap/app.php</code>内のコメントアウトを外して有効にしてやる。</p>

<pre><code>$app-&gt;withEloquent();
</code></pre>

<h2>モデルの作成</h2>

<p>モデルは、<code>app/</code>以下に作成する。<br/>
例えば、user、というテーブル名を利用したい場合は、<code>app/User.php</code>を作成してやる。<br/>
その中で、<code>protected $table</code>の箇所がテーブル名を指定している箇所となるので、ここで単数形のテーブル名を指定してやる。</p>

<p>```
&lt;?php namespace App;
use Illuminate\Database\Eloquent\Model;
class User extends Model {</p>

<pre><code>protected $table = ‘user’;
protected $fillable = [
    ‘name’,
    ‘username’,
    ‘password’
];
protected $hidden = [ ‘password’ ];
</code></pre>

<p>}
```</p>

<h2>利用</h2>

<p>マイグレーションは作成しなくても動作した。<br/>
(項目をDBとコードで同期させる時にartisanから利用するよう。lumenでも利用できる）</p>

<p>以下の様な形で取得できた。</p>

<pre><code>DB::table('user')-&gt;get();
</code></pre>

<h2>参考</h2>

<p><a href="http://laravel4.winroad.jp/2014/03/06/eloquent-orm%E3%81%AE%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E4%BD%BF%E7%94%A8%E6%B3%95/">Eloquent ORMの基本的な使用法 | WinRoadのLaravel4初心者講座</a><br/>
<a href="https://medium.com/@petehouston/enable-eloquent-orm-in-laravel-lumen-micro-framework-7a4f2fbcaf5d#.pe3a4ibc8">Enable Eloquent ORM in Laravel Lumen micro-framework — Medium</a></p>
]]></content>
  </entry>
  
</feed>
