<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: salesforce | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/salesforce/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-04-10T11:51:16+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[開発者コンソールで表示させるデバッグログのレベルを変更する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/04/10/change-debug-log-level/"/>
    <updated>2017-04-10T11:45:42+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/04/10/change-debug-log-level</id>
    <content type="html"><![CDATA[<p>開発者コンソールを開いていると、ログインしているユーザーのデバッグログを直接参照する事が出来る。
このログは、ログレベルがデフォルトの設定になっているが、色んなログが大量に出てしまう。</p>

<!-- more -->


<p><code>Debug Only</code>にチェックをつければ自分で出力したログだけを表示してくれたり、<code>Filter</code>機能があるのでみたいログだけに絞って表示させることは比較的容易に出来る。<br/>
しかし、そもそもログの内容が多すぎて、出力出来る最大サイズを越えてしまうことがたまにある。<br/>
そんな時は余計なログは出力させないようにデバッグレベルを調整してやる必要がある。</p>

<p><img src="/images/2017/04/debug_log_level_01.jpg" alt="" /></p>

<p>(匿名実行のログを表示させたところ）</p>

<p>開発者コンソールじゃなくて、SFの設定からデバッグログを設定してやる場合はデバッグレベル名を必須で選択するので、レベルの調整が可能なことはわかっていたが、開発者コンソールでもこのデバッグレベルを変更出来た。</p>

<h1>デバッグレベル</h1>

<p>まず、予めデバッグレベルを作成しておく。<br/>
<code>設定 -&gt; ログ -&gt; デバッグレベル</code> にアクセス。</p>

<p>新規、から作成。</p>

<p>名前は適当に設定し、レベルは欲しい情報に絞ったりして調整する。<br/>
例えば、Apexで<code>System.debug()</code>で出力したものは、Apexコードで、レベルを <code>デバッグ</code> にしておけば出力される。<br/>
(それ以外のカテゴリはなし、で問題ない）</p>

<p><img src="/images/2017/04/debug_log_level_02.jpg" alt="" /></p>

<h1>ログレベルの変更</h1>

<p>開発者コンソールのメニューから、 <code>Debug -&gt; Change Log Levels</code> を選択。<br/>
<img src="/images/2017/04/debug_log_level_03.jpg" alt="" /></p>

<p>ログレベルの選択画面がモーダルで表示される。<br/>
一番上の、<code>General Trace Settings for You</code>が、開発者コンソールで表示されるログのレベルの設定となる。<br/>
現状は、デフォルトのレベルが設定されているはずなので、一番右の項目にある、 <code>Add/Change</code> をクリック。</p>

<p><img src="/images/2017/04/debug_log_level_04.jpg" alt="" /></p>

<p>デフォルトのレベルと、先ほど設定したレベルが表示されるので、設定したレベルを選択し、<code>Done</code>をクリック。</p>

<p><img src="/images/2017/04/debug_log_level_05.jpg" alt="" /></p>

<p>実は、予めレベルをSF側から作成しなくても、ここで、<code>Add</code>して作成する事も可能。<br/>
さらに、各カテゴリのレベルもここから変更する事も出来る。</p>

<p>これで設定は完了。先ほどの匿名実行と同じ内容でログを出力してみると、大幅に内容が減っているのが確認出来る。</p>

<p><img src="/images/2017/04/debug_log_level_07.jpg" alt="" /></p>

<p>また、実はSF側のデバッグログのページを確認すると、開発者コンソールを起動させた時点で設定したデバッグレベル・ログイン中のユーザーの状態で、デバッグログが自動的にセットされている。</p>

<p><img src="/images/2017/04/debug_log_level_06.jpg" alt="" /></p>

<p>以上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PostmanでSalesforce REST APIに接続]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/12/07/sf-rest-api-postman/"/>
    <updated>2016-12-07T16:27:12+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/12/07/sf-rest-api-postman</id>
    <content type="html"><![CDATA[<p>以前まではRestAPIの接続確認には、<a href="https://apigee.com/providers">Apigee</a>を使用していたのだけれど、TLS1.0無効化の問題の影響からsandboxでは接続できなくなってしまった。<br/>
なので、代替としてちょっとめんどうだけれど、Postmanで接続してみた。</p>

<!-- more -->


<h1>アクセストークンの取得</h1>

<p>ドメインは、sandboxの場合は、 <code>test.salesforce.com</code> 、本番は、 <code>login.salesforce.com</code> となる。<br/>
今回はsandboxで試す。</p>

<p>Postmanにて、以下の内容で送信。</p>

<blockquote><p>POST : <a href="https://test.salesforce.com/services/oauth2/token">https://test.salesforce.com/services/oauth2/token</a></p></blockquote>

<ul>
<li><code>grant_type</code> : <code>password</code></li>
<li><code>client_id</code> : 接続アプリケーションのコンシューマ鍵</li>
<li><code>client_secret</code> : 接続アプリケーションのコンシューマの秘密</li>
<li><code>username</code> : 使用するアカウントのユーザ名</li>
<li><code>password</code> : パスワード。必要な場合は、パスワード+セキュリティトークン</li>
</ul>


<p><img src="/images/2016/12/sf_api_postman_01.jpg" alt="" /></p>

<p>正しくログイン出来ると以下のようにJSONが返ってくる。</p>

<p><code>
{
  "access_token": "xxx",
  "instance_url": "https://xxxx.salesforce.com",
  "id": "https://test.salesforce.com/id/xxxx/xxxx",
  "token_type": "Bearer",
  "issued_at": "xxx",
  "signature": "xxx"
}
</code></p>

<p><code>access_token</code>と<code>instance_url</code>だけ必要。</p>

<h1>APIに接続</h1>

<p>例として、オブジェクトの一覧を取得してみる。<br/>
URLのドメイン部分を先程取得した、 <code>instance_url</code> を使用する。</p>

<blockquote><p>GET : <a href="https://xxx.salesforce.com/services/data/v24.0/sobjects">https://xxx.salesforce.com/services/data/v24.0/sobjects</a></p></blockquote>

<p>ヘッダーに以下を追加。<br/>
<code>ACCESS_TOKEN</code>には先程取得した、<code>access_token</code>を使用する。</p>

<ul>
<li><code>Authorization</code> : <code>Bearer ACCESS_TOKEN</code></li>
</ul>


<p><img src="/images/2016/12/sf_api_postman_02.jpg" alt="" /></p>

<p>カスタムRestAPIの場合は以下のURLになる。<br/>
<code>hoge/hoge</code>が<code>@RestResource(urlMapping='/hoge/hoge')</code>で指定したURLとなる。</p>

<blockquote><p><a href="https://xxx.salesforce.com/services/apexrest/hoge/hoge">https://xxx.salesforce.com/services/apexrest/hoge/hoge</a></p></blockquote>

<h1>参考</h1>

<ul>
<li><a href="http://sfdcbeginner.com/how-to-test-salesforce-rest-api.html">HOW TO TEST SALESFORCE REST API</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SalesforceのREST API接続用のLaravelパッケージを使ってみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel/"/>
    <updated>2016-11-17T14:00:34+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel</id>
    <content type="html"><![CDATA[<p>Salesforce接続用のLaravel5パッケージ、<code>omniphx/forrest</code>を使ってみた。</p>

<!-- more -->


<h1>セットアップ</h1>

<p>Composerに追加。</p>

<p><code>
$ composer require "omniphx/forrest":"2.*"
</code></p>

<p><code>config/app.php</code>に以下を追加</p>

<p>```
&lsquo;providers&rsquo; => [
  // &hellip;
  Omniphx\Forrest\Providers\Laravel\ForrestServiceProvider::class,
  // &hellip;
],</p>

<p>&hellip;</p>

<p>&lsquo;aliases&rsquo; => [
  // &hellip;</p>

<pre><code>'Forrest' =&gt; Omniphx\Forrest\Providers\Laravel\Facades\Forrest::class
</code></pre>

<p>  // &hellip;
],
```
以下で設定ファイルを生成させる。</p>

<p><code>
$ php artisan vendor:publish
</code></p>

<h1>設定ファイル</h1>

<p>SFへの接続方法は２つから選択可能。</p>

<ul>
<li>Web Server authentication flow &ndash; 個別のSFアカウントでのログイン</li>
<li>Username-Password authentication flow &ndash; 接続用のアカウントを使用したログイン</li>
</ul>


<p>通常は、Username-Password authentication を利用する事が多い。</p>

<p><code>config/forrest.php</code>で以下を書き換え。</p>

<p><code>
//11行目
'authentication' =&gt; 'WebServer',
↓↓
'authentication' =&gt; 'UserPassword',
</code></p>

<p>あとは、<code>.env</code>ファイルでユーザ名やパスワード、アプリのキーなどを設定する。</p>

<p><code>
CONSUMER_KEY=xxx
CONSUMER_SECRET=xxx
LOGIN_URL=https://login.salesforce.com/
USERNAME=xxx
PASSWORD=xxx
</code></p>

<p><code>LOGIN_URL</code>を <code>https://test.salesforce.com/</code>としておくと常にsandboxへの接続となる。</p>

<h1>利用</h1>

<h2>ログイン</h2>

<p>以下でログイン。</p>

<p><code>
use Omniphx\Forrest\Providers\Laravel\Facades\Forrest;
...
Forrest::authenticate();
</code></p>

<p>(PHPStormの補完が効かない…）</p>

<h2>クエリの発行</h2>

<p><code>
Forrest::query('SELECT Id FROM Account');
</code></p>

<h2>レコードの作成など</h2>

<p>```
$body = [&lsquo;Name&rsquo; => &lsquo;New Account&rsquo;];
Forrest::sobjects(&lsquo;Account&rsquo;,[</p>

<pre><code>'method' =&gt; 'post',
'body'   =&gt; $body]);
</code></pre>

<p>```</p>

<p><code>sobjects</code>で第一引数にオブジェクトを指定し、第二引数に送信する内容を指定する。<br/>
送信内容は配列でキーを指定してやればよい。<br/>
<code>method</code>はそれぞれ以下。</p>

<ul>
<li>post &ndash; 作成</li>
<li>put &ndash; 更新</li>
<li>patch &ndash; アップサート</li>
<li>delete &ndash; 削除</li>
</ul>


<p>削除の場合は以下のようにREST形式でSFIDを指定してやる。</p>

<p><code>
Forrest::sobjects('Account/001i000000xxx', ['method' =&gt; 'delete']);
</code></p>

<h2>トークンの操作</h2>

<ul>
<li>リフレッシュ &ndash; <code>refresh()</code></li>
<li>廃止 &ndash; <code>revoke()</code></li>
</ul>


<h2>カスタムエンドポイント</h2>

<p>以下の様のして送信する。</p>

<p>```
Forrest::custom(&lsquo;/myEndpoint&rsquo;, [</p>

<pre><code>'method' =&gt; 'post',
'body' =&gt; ['foo' =&gt; 'bar'],
'parameters' =&gt; ['flim' =&gt; 'flam']]);
</code></pre>

<p>```</p>

<p>その他は、GitHubのReadme参照。</p>

<h1>参考</h1>

<ul>
<li><a href="https://github.com/omniphx/forrest">omniphx/forrest: Salesforce.com REST API Client for Laravel 5</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Salesforce] Let’s Encryptの証明書ではSFからのコールアウトを受けられない]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/08/10/sf-lets-encrypt/"/>
    <updated>2016-08-10T11:49:42+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/08/10/sf-lets-encrypt</id>
    <content type="html"><![CDATA[<p>Let’s Encryptで取得した証明書を適用させたサイトへコールアウトしたところエラーが発生し接続出来なかったので、調査してみた。</p>

<!-- more -->


<h1>エラー内容</h1>

<p>エラーは下記の内容。</p>

<blockquote><p>System.CalloutException: sun.security.validator.ValidatorException: <br/>
PKIX path building failed: <br/>
sun.security.provider.certpath.SunCertPathBuilderException: <br/>
unable to find valid certification path to requested target</p></blockquote>

<p>エラー内容で調べてみると、自己証明書、ではSFからのアクセスが出来ない、という情報があり、その中で紹介されているエラーが上記内容と酷似していることがわかった。</p>

<p><a href="http://appirio.co.jp/category/tech-blog/2013/05/apex%E3%82%B3%E3%83%BC%E3%83%AB%E3%82%A2%E3%82%A6%E3%83%88%E3%81%AE%E3%83%99%E3%82%B9%E3%83%88%E3%83%97%E3%83%A9%E3%82%AF%E3%83%86%E3%82%A3%E3%82%B9part-2/">Apexコールアウトのベストプラクティス:Part 2 &ndash; Appirio Japan</a></p>

<p>しかし、Let’s Encryptは自己証明書ではない…。</p>

<h1>SFが許可するCA</h1>

<p>引き続き調べてみると、どうやらsalesforceは接続出来る認証局 (CA) をホワイトリスト方式で設定しているよう。</p>

<p><a href="https://help.salesforce.com/HTViewSolution?id=000007225&amp;language=en_US">Salesforce.com SSL certificates Salesforce supports</a></p>

<p>以下が許可されている認証局のリスト。</p>

<p><a href="https://developer.salesforce.com/page/Outbound_Messaging_SSL_CA_Certificates">Outbound Messaging SSL CA Certificates &ndash; developer.force.com</a></p>

<p>このリストには、Let’s Encryptがない。<br/>
というわけで、SFがLet’s Encrypt認証局が作成した証明書を適用したサイトへの接続は許可していない、ということになり、冒頭のエラーが発生していた、ということになる。</p>

<p>ちなみに、Let’s Encryptの認証局をリストに加えてほしい、という要望は結構前から上がっているよう。</p>

<p><a href="https://success.salesforce.com/ideaView?id=08730000000E28LAAS">Support Let&rsquo;s Encrypt CA Certificate &ndash; Ideas &ndash; Salesforce Success Community</a></p>

<p>対応する気はないのか、まだ手が回ってないだけなのか…。</p>

<h1>参考</h1>

<ul>
<li><a href="https://jp.globalsign.com/service/knowledge/ca/">認証局 （CA：Certification Authority）とは？ | SSL・電子証明書ならGMOグローバルサイン</a></li>
<li><a href="http://qiita.com/kawaz/items/f90810b9ea823b6556a8">認証局を立ててぼろもうけしたいんですが＞無理な理由を理解しよう &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Salesforce]関連リストのインライン編集をVFで作成する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/07/11/vf-inline-edit/"/>
    <updated>2016-07-11T17:56:11+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/07/11/vf-inline-edit</id>
    <content type="html"><![CDATA[<p>オブジェクトの詳細で表示される関連リスト部分、要するにそのレコードを参照しているレコード、を一覧表示からインライン編集出来るようにしたかったので、インライン編集の基本的な部分から調べてみた。</p>

<!-- more -->


<h1>参考</h1>

<ul>
<li><a href="https://developer.salesforce.com/docs/atlas.ja-jp.pages.meta/pages/pages_quick_start_inline_editing.htm">インライン編集の有効化 Visualforce開発者ガイド</a></li>
</ul>


<h1>詳細レコード</h1>

<p>該当のレコードの詳細を表示し、表示している項目をインライン編集出来るようにする。</p>

<p>作成しているVFページのURLにて、IDが指定されている + 指定されている<code>standardController</code>のオブジェクトであれば、Visualforceだけで表示させることが可能。</p>

<blockquote><p><a href="https://Salesforce_instance/apex/myPage?id=001x000xxx3Jsxb">https://Salesforce_instance/apex/myPage?id=001x000xxx3Jsxb</a></p></blockquote>

<p>この場合、IDが<code>001x000xxx3Jsxb</code>の取引先(<code>Account</code>)が表示される。<br/>
<code>apex:detail</code>タグを使うと、このレコードの詳細がそのまま表示される。<br/>
その際に、属性<code>inlineEdit</code>を<code>true</code>で指定するとインライン編集が可能となる。</p>

<p>```
&lt;apex:page standardController=&ldquo;Account&rdquo;></p>

<pre><code>    &lt;apex:detail subject="{!account.Id}" relatedList="false" inlineEdit="true"/&gt; 
</code></pre>

<p>&lt;/apex:page>
```</p>

<p>特定のレコードの詳細をそのまま表示したい時とかには便利。</p>

<h1>一覧表示</h1>

<p>詳細ではなく、一覧表示で複数件いっぺんに編集したい場合。
<code>apex:page</code>の属性で、<code>recordSetVar</code>を指定してやれば、<code>standardController</code>で指定したオブジェクトのリストを表示出来る。</p>

<p><a href="http://qiita.com/tyoshikawa1106/items/4ef3b8e1998609f2c573">standardControllerとrecordSetVar &ndash; Qiita</a></p>

<p>```
&lt;apex:page standardController=&ldquo;Account&rdquo; recordSetVar=&ldquo;records&rdquo; id=&ldquo;thePage&rdquo;></p>

<pre><code>&lt;apex:form id="theForm"&gt; 
    &lt;apex:pageBlock id="thePageBlock"&gt; 
        &lt;apex:pageBlockTable value="{!records}" var="record" id="thePageBlockTable"&gt; 
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!record.Name}" id="AccountNameDOM" /&gt; 
                &lt;apex:facet name="header"&gt;Name&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!record.Type}" id="AccountTypeDOM" /&gt; 
                &lt;apex:facet name="header"&gt;Type&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!record.Industry}" 
                    id="AccountIndustryDOM" /&gt;  
                    &lt;apex:facet name="header"&gt;Industry&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:inlineEditSupport event="ondblClick" 
                    showOnEdit="saveButton,cancelButton" hideOnEdit="editButton" /&gt; 
        &lt;/apex:pageBlockTable&gt; 
        &lt;apex:pageBlockButtons &gt; 
            &lt;apex:commandButton value="Edit" action="{!save}" id="editButton" /&gt;
            &lt;apex:commandButton value="Save" action="{!save}" id="saveButton" /&gt;
            &lt;apex:commandButton value="Cancel" action="{!cancel}" id="cancelButton" /&gt;
        &lt;/apex:pageBlockButtons&gt; 
    &lt;/apex:pageBlock&gt; 
&lt;/apex:form&gt;
</code></pre>

<p>&lt;/apex:page>
```</p>

<p>コードは公式ドキュメントのママ。<br/>
formなど各タグ内のIDは別にあってもなくてもよさそう。</p>

<p>以下のように表示される。</p>

<p><img src="/images/2016/07/sf_inline01.jpg" alt="" /></p>

<p><code>apex:column</code>で囲まれてた部分が1つの項目になっており、<code>&lt;apex:facet name="header"&gt;</code>タグの内容がそれぞれの項目の見出しとなる。</p>

<p>このままページを表示してインライン編集後、saveボタンをクリックすると確かに更新はされるがホームへ遷移してしまう。
(キャンセルをクリックしても同様)</p>

<p>これを解消するために、カスタムコントローラーを割り当ててみた。<br/>
<code>recordSetVar</code>を使っていると、割り当てたカスタムコントローラ側で取得したレコードリストを使用するために、<code>StandardSetController</code>を使う必要がある、とのこと。</p>

<p><a href="http://tyoshikawa1106.hatenablog.com/entry/2013/09/03/232942">SFDC：recordSetVarとextensions &ndash; tyoshikawa1106のブログ</a></p>

<p>これを、<code>StandardController</code>をコントローラ側で使っていると下記のようなエラーがでる。
エラーメッセージだけでは非常にわかりにくそうなので注意。</p>

<blockquote><p>common.apex.runtime.bytecode.BytecodeApexObjectType cannot be cast to common.apex.runtime.impl.ApexType</p></blockquote>

<p>で、カスタムコントローラ内で、ボタンを押された際のアクションを作成し、<code>null</code>を返す事でページ遷移をしないようにする。<br/>
ただし、保存する<code>save</code>ボタンはこれをしてしまうと保存されなくなってしまったので、キャンセルボタンだけにしておいた。</p>

<p>VF</p>

<p><code>
&lt;apex:page standardController="Account" recordSetVar="records" extensions="VfInlineEditSample" id="thePage"&gt;
</code></p>

<p>apex (<code>VfInlineEditSample.apxc</code>)</p>

<p>```
public class VfInlineEditSample {</p>

<pre><code>public VfInlineEditSample(ApexPages.StandardSetController stdController){
    List&lt;Account&gt; lists = (List&lt;Account&gt;)stdController.getRecords();
}

public PageReference cancel(){
    return null;
}
</code></pre>

<p>}
```</p>

<p><a href="http://www.developerforce.com/guides/fr/apex_fr/Content/apex_pages_standardsetcontroller.htm">Classe StandardSetController</a></p>

<h1>関連リスト</h1>

<p>とあるレコードの関連リストを一覧表示からインライン編集したい場合。<br/>
上記の一覧表示と同じようにすればインライン編集出来るテーブルを作る事は可能。</p>

<p>IDはVFページのパラメータから取得する。</p>

<p>例）<br/>
<code>VfInlineEditSamplePage.vfp</code></p>

<p>```
&lt;apex:page standardController=&ldquo;Account&rdquo; extensions=&ldquo;VfInlineEditSample&rdquo; id=&ldquo;thePage&rdquo;></p>

<pre><code>&lt;apex:form id="theForm"&gt; 
    &lt;apex:pageBlock title="商談" &gt;
        &lt;apex:pageBlockTable value="{!opp_records}" var="opp"&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.Name}" /&gt; 
                &lt;apex:facet name="header"&gt;商談名&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.Amount}" /&gt; 
                &lt;apex:facet name="header"&gt;金額&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.StageName}" /&gt; 
                &lt;apex:facet name="header"&gt;フェーズ&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:column &gt;
                &lt;apex:outputField value="{!opp.NextStep}" /&gt; 
                &lt;apex:facet name="header"&gt;次回アクション&lt;/apex:facet&gt;
            &lt;/apex:column&gt;
            &lt;apex:inlineEditSupport event="ondblClick" /&gt;
        &lt;/apex:pageBlockTable&gt; 
        &lt;apex:pageBlockButtons &gt; 
            &lt;apex:commandButton value="Save" action="{!save}" /&gt;
            &lt;apex:commandButton value="Cancel" action="{!cancel}" /&gt;
        &lt;/apex:pageBlockButtons&gt; 
    &lt;/apex:pageBlock&gt; 
&lt;/apex:form&gt;
</code></pre>

<p>&lt;/apex:page>
```</p>

<p><code>VfInlineEditSample.apxc</code></p>

<p>```
public class VfInlineEditSample {</p>

<pre><code>public List&lt;Opportunity&gt; opp_records{get; set;}

public VfInlineEditSample(ApexPages.StandardController stdController){
    Account acc = (Account)stdController.getRecord();
    Id aid = acc.id;
    Account record = [SELECT id, name, (SELECT id,name,StageName,NextStep,Amount FROM Opportunities) FROM Account WHERE id=:aid];
    opp_records = record.Opportunities;
}

public PageReference cancel(){
    return null;
}
</code></pre>

<p>}
```</p>

<p>以下のようになる。</p>

<p><img src="/images/2016/07/sf_inline02.jpg" alt="" /></p>

<p>このままだとSaveをクリックしても保存はされない。<br/>
なので、cancelと同じようにカスタムコントローラ内でアクションを受け取り、編集した内容はVFへ引き渡している、 <code>opp_records</code>に入っているので、それをupdateすれば更新される。</p>

<p>apexクラスに以下を追加。</p>

<p>```
public PageReference save(){</p>

<pre><code>update opp_records;
return null;
</code></pre>

<p>}
```</p>

<p>しかしこうすると、編集されたされてないにかかわらず、関連リストに並んでいるオブジェクト(この場合は商談)のレコード全てが更新されてしまう。<br/>
ガバナ制限は、1万レコードまで大丈夫なので、問題になることは少ないと思うが、最終更新日付が全て更新されてしまうのが都合が悪いかもしれない。</p>

<p><a href="https://developer.salesforce.com/docs/atlas.ja-jp.salesforce_app_limits_cheatsheet.meta/salesforce_app_limits_cheatsheet/salesforce_app_limits_platform_apexgov.htm">Apex ガバナ制限</a></p>

<h2>更新対象を選ぶ</h2>

<p>ワークフローであれば、<code>ISCHANGED</code>を使えば、その項目が変更されたかどうかをチェック出来るが、apexではそのメソッドはない。<br/>
(機能追加が要望があがってたりする(トリガの機能としてだけど） <a href="https://success.salesforce.com/ideaview?id=087300000007LI2AAM">IsChanged function in Apex</a>)</p>

<p>なので、更新される項目を一つずつ比較して更新があるかどうかを確認する泥臭い方法を取ってみる。<br/>
(他にいいアイデアがあれば教えて欲しい…）</p>

<p>修正後のapex</p>

<p>```
public class VfInlineEditSample {</p>

<pre><code>public List&lt;Opportunity&gt; opp_records{get; set;}
private List&lt;Opportunity&gt; old_records;

public VfInlineEditSample(ApexPages.StandardController stdController){
    Account acc = (Account)stdController.getRecord();
    Id aid = acc.id;
    Account record = [SELECT id, name, (SELECT id,name,StageName,NextStep,Amount FROM Opportunities) FROM Account WHERE id=:aid];
    opp_records = record.Opportunities;
    old_records = opp_records.deepClone();
}

public PageReference cancel(){
    return null;
}

public PageReference save(){
    List&lt;Opportunity&gt; update_lists = new List&lt;Opportunity&gt;();
    for(Integer i = 0; i&lt; opp_records.size(); i++){
        if(opp_records[i].name != old_records[i].name){
            update_lists.add(opp_records[i]);
            continue;
        }else if(opp_records[i].StageName != old_records[i].StageName){
            update_lists.add(opp_records[i]);
            continue;
        }else if(opp_records[i].NextStep != old_records[i].NextStep){
            update_lists.add(opp_records[i]);
            continue;
        }else if(opp_records[i].Amount != old_records[i].Amount){
            update_lists.add(opp_records[i]);
            continue;
        }
    }

    if(update_lists.size() &gt; 0){
        update update_lists;
    }

    return null;
}
</code></pre>

<p>}
```</p>

<p>リストをコピーする際に、<code>deepClone</code>を使わないと<code>clone</code>では浅いコピーとなってしまい、参照しているものが同じになってしまうので注意。
(一方の値を更新するともう一方も同じ値になってしまう）</p>

<h2>汎用的にする</h2>

<p>上記だと、表示する項目を増やす度に比較の条件文を追加しないといけない。<br/>
なので、全項目から取得出来るものだけを比較するようにしてみた。</p>

<p>以下、関数。</p>

<p>```
public List<sObject> isChanged(String object_name, List<sObject> new_records, List<sObject> old_records){</p>

<pre><code>sObject obj = (sObject)Type.forName(object_name).newInstance();
Schema.DescribeSObjectResult descR = obj.getsObjectType().getDescribe();
Set&lt;String&gt; fields = descR.fields.getMap().keySet();
Map&lt;String, Schema.SObjectField&gt; fmap = descR.fields.getMap();

List&lt;sObject&gt; update_records = new List&lt;sObject&gt;();
for(Integer i = 0; i&lt; new_records.size(); i++){
    for(String field : fields){
        try{
            Schema.SObjectField f = fmap.get(field);
            Schema.DescribeFieldResult fr = f.getDescribe();
            if(!fr.isUpdateable()) continue; //更新出来ない項目は飛ばす
            //比較
            if(new_records[i].get(field) != old_records[i].get(field)){
                update_records.add(new_records[i]);
                continue;
            }
        }catch(SObjectException e){
            //取得していない項目
        }
    }
}

return update_records;
</code></pre>

<p>}
```</p>

<ul>
<li><code>getDescribe()</code>で指定したオブジェクトの全項目名を取得出来る</li>
<li>取得した項目名を使ってオブジェクトから<code>get()</code>で取得。例外が発生したものはselectで取得していない項目、となる</li>
<li>更新可能かどうかは、<code>Describe</code>で取得出来る項目の情報内を見れば判定可能<br/>
<code>isUpdateable</code>がtrueなら更新が出来る項目となるので、これがtrueのもののみ比較している</li>
</ul>


<p>使用の際は、第一引数にオブジェクトの参照名、第二引数に更新後のレコードリスト、第三引数に更新前のレコードリストを指定してやる。</p>

<p><code>
List&lt;Opportunity&gt; update_lists = isChanged('Opportunity', opp_records, old_records);
</code></p>

<p>これで項目が増えても安心。</p>

<h3>参考</h3>

<ul>
<li><a href="http://kayakuguri.github.io/blog/2014/04/23/sf-mailtemplate/">[SalesForce]メールテンプレートの項目一覧 &ndash; KayaMemo</a></li>
<li><a href="http://appirio.co.jp/category/tech-blog/2012/07/force-com-apex%E3%81%AE%E3%80%8Cdescribe%E3%80%8D%E3%81%A7%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%EF%BC%88%E3%81%9D%E3%81%AE%EF%BC%91%EF%BC%89/">Force.com Apexの「Describe」でできること（その１） &ndash; Appirio Japan</a></li>
<li><a href="http://appirio.co.jp/category/tech-blog/2012/09/force-com-apex%E3%81%AE%E3%80%8Cdescribe%E3%80%8D%E3%81%A7%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%93%E3%81%A8%EF%BC%88%E3%81%9D%E3%81%AE%EF%BC%92%EF%BC%89/">Force.com Apexの「Describe」でできること（その２） &ndash; Appirio Japan</a></li>
<li><a href="http://vaindespair.blogspot.jp/2012/04/blog-post_04.html">memo: Force.com&#12288;&#65306;&#12288;Apex でオブジェクト及び項目の情報を取得する</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
