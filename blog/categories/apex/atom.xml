<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apex | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/apex/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2015-12-08T19:13:29+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ApexでJSONをパースする]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/12/08/json-apex-parse/"/>
    <updated>2015-12-08T19:12:05+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/12/08/json-apex-parse</id>
    <content type="html"><![CDATA[<p>Apex RestAPIなんかを作成している際に、インプットをJSONにしたい場合があります。<br/>
その際に受け取ったJSONをApexでパースして使用する方法がややこしかったのでメモ。</p>

<!-- more -->


<h2>基本</h2>

<p>基本としては、以下の記事が詳しいです。<br/>
<a href="http://www.teamspirit.co.jp/blog/staff/2011/10/winter12json2.html">Winter&rsquo;12のJSONサポートを使いこなす(2) | チームスピリット</a></p>

<p>ここにもある通り、例えば、<code>{a:xx, b:xxx}</code>などのJSONがある場合は、予めapex側でそのJSONの内容専用のクラスを用意してやる必要がある、とのこと。<br/>
何もなしでいきなりパースしていくことが出来ない。</p>

<p>そのためにクラスを用意してオブジェクトにして……が非常にめんどくさい。</p>

<h2>変換ツール</h2>

<p>そんなめんどくさいJSONのクラス作成を一発で変換してくれるwebツールが以下。</p>

<p><a href="http://json2apex.herokuapp.com/">JSON2Apex</a></p>

<p>例の通り、例えば以下の様なJSONを入力してapexを作成すると、以下のようなコードが生成される。</p>

<p>```
public class JSON2Apex {</p>

<pre><code>public class User {
    public String name;
    public String twitter;
}

public User user;


public static JSON2Apex parse(String json) {
    return (JSON2Apex) System.JSON.deserialize(json, JSON2Apex.class);
}
</code></pre>

<p>}
```</p>

<p>そしてなんと一緒にテストコードまで出力してくれる。</p>

<p>```
@IsTest
public class JSON2Apex_Test {</p>

<pre><code>static testMethod void testParse() {
    String json = '{ ¥"user¥" : { ¥"name¥" : ¥"Simon Fell¥", ¥"twitter¥" : ¥"@superfell¥" } }';
    JSON2Apex obj = JSON2Apex.parse(json);
    System.assert(obj != null);
}
</code></pre>

<p>}
```</p>

<p>これをコピペするなりしてapexクラスとして作成すればOK。</p>

<h2>配列のJSON</h2>

<p>以下の様な配列になっているJSONをパースしたい場合。</p>

<p>```
{&ldquo;data&rdquo;:[</p>

<pre><code>{
    "userid":1,
    "name":"hoge"
},
{   "userid":2,
    "name":"fuga"
}
</code></pre>

<p>]}<br/>
```</p>

<p>これも上記ツールにかけると以下の様なクラスが生成される。<br/>
(テストクラスは割愛)</p>

<p>```
public class JSON2Apex {</p>

<pre><code>public List&lt;Data&gt; data;

public class Data {
    public Integer userid;
    public String name;
}


public static JSON2Apex parse(String json) {
    return (JSON2Apex) System.JSON.deserialize(json, JSON2Apex.class);
}
</code></pre>

<p>}
```</p>

<p>これを利用して<code>userid</code>を順番に取得したい場合は以下のようにすればいい。<br/>
(json_strには上記のJSONが入っているものとする)</p>

<p>```
JSON2Apex_Thread obj = JSON2Apex_Thread.parse(json_str);
for(JSON2Apex.Data val : obj.data){</p>

<pre><code>System.debug(val. userid);
</code></pre>

<p>}
```</p>

<h2>まとめ</h2>

<p>いちいちJSONの内容に合わせてクラスを作成しないといけないのは非常にめんどくさい。<br/>
<code>JSON.deserialize</code>の他にも、<code>JSON.createParser()</code>もあるが、これも同じくクラスの作成は必要。<br/>
型が厳密なだけにいちいち指定が必要になるのかもしれない。</p>

<h2>参考</h2>

<p><a href="http://salesforce.stackexchange.com/questions/5427/json-deserialize-array-of-objects">apex &ndash; JSON.deserialize Array of Objects &ndash; Salesforce Stack Exchange</a><br/>
<a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_class_System_JsonParser.htm">JSONParser Class | Force.com Apex Code Developer&#x27;s Guide | Salesforce Developers</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[apex]バッチ実行時にカウントデータを引き継ぐ]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/08/05/apex-batch-data/"/>
    <updated>2015-08-05T11:26:58+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/08/05/apex-batch-data</id>
    <content type="html"><![CDATA[<p>apexでバッチを走らせる場合は、デフォルトでの200件ごとに処理を走らせる場合が多いけれれど、<br/>
その時に処理の中でカウントアップしたデータを次の処理に引き継ぎたかった。</p>

<!-- more -->


<p>結論から言うと、 <code>Database.Stateful</code> を使うと、データの内容を保持した状態でバッチが走らせられた。</p>

<p>具体的には以下。</p>

<p>```
public with sharing class Hogehoge_Batch implements Database.Batchable<sObject>, Database.Stateful{</p>

<pre><code>private Integer count {get; set;}

public Hogehoge_Batch(Boolean isLastBatch){
    this.count = 0;
}

public Database.QueryLocator start(Database.BatchableContext BC){
    String query = 'select id from Lead';
     return Database.getQueryLocator(query);
}

public void execute(Database.BatchableContext BC, List&lt;Lead&gt; scope){
    for(Lead user : scope){ 
        user.count__c = this.count;
        this.count++;
    }
    update scope;
}

public void finish(Database.BatchableContext BC){
}
</code></pre>

<p>}
```</p>

<p>クラス定義の1行目の最後にくっついてる。<br/>
これがないと<code>count</code>は毎回リセットされてしまう。</p>

<h2>参考</h2>

<p><a href="http://tyoshikawa1106.hatenablog.com/entry/2015/02/15/182505">SFDC：【大量データ処理】Apex Batchで一括更新処理を確認してみました &ndash; tyoshikawa1106のブログ</a><br/>
<a href="http://salesforceapexcodecorner.blogspot.jp/2011/08/state-management-in-batch-apex-in.html">State Management In Batch Apex in Salesforce</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]apexでレコードをフォローさせる]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/07/02/record-follow/"/>
    <updated>2015-07-02T09:54:50+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/07/02/record-follow</id>
    <content type="html"><![CDATA[<p>レコードを作った段階で自動的にフォローさせたかったので調べてみた。</p>

<!-- more -->


<h2>チャター</h2>

<p>デフォルトでは一部のレコードを除いてレコードのフォロー機能はオフになっている。<br/>
オンにするには、<code>フィード追跡</code>で有効にする。</p>

<p><code>設定 -&gt; カスタマイズ -&gt; Chatter -&gt; フィード追跡</code>を選択。<br/>
有効にしたいオブジェクトを選んで、<code>フィード追跡の有効化</code>にチェックを入れて保存。</p>

<p><img src="/images/2015/07/feed_follow01.jpg" alt="" /></p>

<p>すると、設定したレコード詳細の上部にフォローの表示とチャターコメントが出現する。<br/>
フォローしたい場合はここをクリックしてフォロー出来る。</p>

<p><img src="/images/2015/07/feed_follow02.jpg" alt="" /></p>

<p>フォローすると以下のような表示に変わる。</p>

<p><img src="/images/2015/07/feed_follow03.jpg" alt="" /></p>

<h2>apexでのフォロー</h2>

<p>フォローは、<code>EntitySubscription</code>なるオブジェクトで管理されている。<br/>
現在のフォロー関係一覧を取得するSOQLは以下。</p>

<pre><code>SELECT Id, ParentId, SubscriberId FROM EntitySubscription
</code></pre>

<p><code>ParentId</code>が、フォロー対象のユーザーやオブジェクトのレコードID。<br/>
<code>SubscriberId</code>が、フォローするユーザーのID、となる。</p>

<p>なので、このオブジェクトにフォロー対象とフォローするIDを入れてインサートしてやればよい。</p>

<p>例）</p>

<p><code>
EntitySubscription follow = new EntitySubscription();
follow.ParentId = 'ID'; //対象のレコード
follow.SubscriberId = 'ID'; //ユーザーのID
insert follow;
</code></p>

<p>トリガーで実装する場合は、レコードのIDが必要になるので、<code>after insert</code>で実行すること。</p>

<h2>参考</h2>

<p><a href="http://vaindespair.blogspot.jp/2011/01/blog-post.html">memo: Force.com&#12288;&#65306;&#12288;行動を作成したとき&#12289;自動的にフォローするようにしたい</a></p>

<p>チャター関係は以下のPDFにまとまっていた。<br/>
<a href="http://developerforcejp.s3.amazonaws.com/books/cheatsheets/Chatter-cheatsheet_Ja.pdf">http://developerforcejp.s3.amazonaws.com/books/cheatsheets/Chatter-cheatsheet_Ja.pdf</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ApexRESTにてPOSTで送信された配列のデータを受け取る]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/06/23/apexrest-post-array/"/>
    <updated>2015-06-23T20:38:27+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/06/23/apexrest-post-array</id>
    <content type="html"><![CDATA[<p>RestApexを作成していて、配列でPOSTした値はどうやって取得するのかを調べてみた。</p>

<!-- more -->


<p>例えば、POSTでidというパラメータで送信した内容は以下のようにして取得可能。</p>

<pre><code>RestRequest req = RestContext.request;
String id = req.params.get('id');
</code></pre>

<p>しかし配列だとこれでは取得できなかった。</p>

<p>送信データ</p>

<pre><code>$value = [
  'hoge'=&gt;['1', '2', '3']
];
</code></pre>

<p>受信</p>

<pre><code>RestRequest req = RestContext.request;
String id = req.params.get('hoge');  //null
</code></pre>

<p>なので、どのようにしてデータがわたっているのかを出力させてみた。</p>

<p>送信したデータ</p>

<pre><code>$value = [
  'id'=&gt;'hoge',
  'arr'=&gt;['1', '2', '3']
];
</code></pre>

<p>出力させたコード</p>

<pre><code>RestRequest req = RestContext.request;
System.debug(req.params);
</code></pre>

<p>出力結果</p>

<pre><code>{arr[0]=1, arr[1]=2, arr[2]=3, id=hoge}
</code></pre>

<p>どうやらちゃんとデータは受け取れているよう。<br/>
この<code>req.params</code>で受け取るデータの型は<code>Map</code>になっているよう。<br/>
以下のように出来る。</p>

<pre><code>RestRequest req = RestContext.request;
Map&lt;String, String&gt; p = req.params;
</code></pre>

<p>ということはキーを取得できるし、キーから中身を全て取り出す事もできる。</p>

<hr />

<p>そんなわけで、かなり無理矢理だけど、指定したキーの中身を取り出す関数を作ってみた。<br/>
配列で受け取る場合はフォームではチェックボックス、SF上では複数選択リスト、になるので、<br/>
SFの形式に合わせて、<code>;</code>セミコロン区切りの文字列として返すようにした。</p>

<p>```
public String convertArrayPostData(Map&lt;String, String> val, String target){</p>

<pre><code>String res = '';
for(String sKey : val.keySet()){
    Integer c = sKey.indexOf('[');
    if(c == -1) continue;
    String key = sKey.left(c);
    if(key == target){
        res += val.get(sKey) + ';';
    }
}
if(res != '') res = res.removeEnd(';');
return res;
</code></pre>

<p>}
```</p>

<p>上記の<code>arr</code>というキーのデータを取り出す場合は以下のように。</p>

<pre><code>RestRequest req = RestContext.request;
Map&lt;String, String&gt; p = req.params;
String arrs = convertArrayPostData(p, 'arr');  //1;2;3
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]バッチスケジュールの一通りの書き方]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/06/11/apex-batch-schedule/"/>
    <updated>2015-06-11T10:59:41+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/06/11/apex-batch-schedule</id>
    <content type="html"><![CDATA[<p>複数クラスにわたってたりしてややこしかったのでメモ。</p>

<!-- more -->


<h2>バッチ</h2>

<p>まずはバッチファイル。<br/>
ここで実際に動作させたい内容を書く。<br/>
枠はこんな感じ。</p>

<p><code>Batch_sample.apex</code></p>

<p>```
global with sharing class Batch_sample implements Database.Batchable<sObject>
{</p>

<pre><code>private String query;

//コンストラクタ
global Batch_UpdatePushlist(String q){
    query = q;
}

//データ取得
global Database.QueryLocator start(Database.BatchableContext BC){
    return Database.getQueryLocator(query);
}

//開始
global void execute(Database.BatchableContext BC, List&lt;sObject&gt; scope){

    //バッチの処理を記述

}

//完了
global void finish(Database.BatchableContext BC)
{
    //完了後の処理があれば
}
</code></pre>

<p>}
```</p>

<p>バッチを起動させるには以下のようにSOQL文と件数を渡して実行する。</p>

<p><code>
String soql = 'SELECT ID FROM sObject';
Batch_sample b = new Batch_sample(soql);
Database.executeBatch(b, 200);
</code></p>

<p>実行時に指定したSOQLで取得するレコード分、バッチが動作する。<br/>
この際に取得出来る件数が、バッチの場合は500万件。<br/>
とはいえ、実際には一度の処理では指定した件数分のみ処理し、ガバナ制限がリセットされて再度実行、を繰り返す。<br/>
<code>executeBatch</code>の第二引数が一回の処理で実行する件数。<br/>
(デフォルトは200件)</p>

<p>バッチ全体の動作は10分以内、というガバナ制限もあり。<br/>
(100万件単位になってくると結構厳しい数字っぽい)</p>

<h2>スケジューラー</h2>

<p>設定したバッチをスケジューラーとして実行させる。<br/>
以下のように、<code>Schedulable</code>クラスをimplementsする。</p>

<p><code>Schedule_sample.apxc</code></p>

<p>```
global class Schedule_sample implements Schedulable {</p>

<pre><code>private final Integer BATCH_SIZE = 200;

global void execute(SchedulableContext ctx) {
    String soql = 'SELECT ID FROM sObject';
    Batch_sample b = new Batch_sample(soql);
    Database.executeBatch(b, BATCH_SIZE);
}
</code></pre>

<p>}
```</p>

<p>このクラスをジョブに追加することでバッチをスケジューリング出来る。</p>

<h2>スケジュールに追加</h2>

<p>追加方法は２つある</p>

<h3>設定画面から追加</h3>

<p><code>設定-&gt;開発-&gt;Apexクラス</code>を選択。<br/>
画面内の<code>Apexをスケジュール</code>をクリック。</p>

<p><img src="/images/2015/06/apex_schedule01.jpg" alt="" /></p>

<p>この中で毎月や毎日、などを選択できる。<br/>
終了日も設定出来るので、ずっと動作するさせるものに関しては長めに設定しておく。</p>

<p><img src="/images/2015/06/apex_schedule02.jpg" alt="" /></p>

<h3>コードで実行</h3>

<p>設定画面から追加での最大のデメリットは実行時間が毎時0分のみ、と、分の指定ができないところ。<br/>
これをさせようと思うとコードからジョブに追加してやる必要がある。</p>

<p>以下が追加させるコード</p>

<pre><code>System.schedule('ジョブ名','0 0 * * * ?', new Schedule_sample());
</code></pre>

<p>第二引数に指定しているものは、クーロン式、というもので、ここで時間指定をしている。<br/>
これは、左から、秒、分、時、日、月、曜日、年となっている。<br/>
(年は省略化)</p>

<p>例）</p>

<ul>
<li>&lsquo;0 0 13 * * ?'：毎日13時に実行</li>
<li>&lsquo;0 0 10 ? * MON-FRI'：月～金の10時に実行</li>
<li>&lsquo;0 0 * * * ?'：毎時0分に実行</li>
<li>&lsquo;0 30 * * * ?'：毎時30分に実行</li>
</ul>


<p>秒のみの指定は怖くて試してません。</p>

<p>この実行式を開発者コンソールの匿名実行から実行することでジョブに追加させられる。</p>

<p><img src="/images/2015/06/apex_schedule03.jpg" alt="" /></p>

<p>コードを書いて、実行ボタンをクリック。</p>

<p><img src="/images/2015/06/apex_schedule04.jpg" alt="" /></p>

<p>追加されたジョブは設定画面の、<code>ジョブ-&gt;スケジュール済みジョブ</code>から確認できる。</p>

<p><img src="/images/2015/06/apex_schedule05.jpg" alt="" /></p>

<h2>動作テスト</h2>

<p>実際に開発中にいちいちスケジュールさせてジョブが実行されるのを待つのはあまりにもめんどくさい。<br/>
バッチを起動させるコードを匿名実行から起動させてもよいがそれでも待ち時間が長いので、結局バッチ処理特有の部分をコメントアウトして、単なるクラスにしてそれを直接実行させる方法で確認した。</p>

<p>以下のようにコメントアウトした。</p>

<p>```
//global with sharing class Batch_sample implements Database.Batchable<sObject>
public class Batch_sample
{</p>

<pre><code>/*
private String query;   
//コンストラクタ
global Batch_UpdatePushlist(String q){
    query = q;
}

//データ取得
global Database.QueryLocator start(Database.BatchableContext BC){
    return Database.getQueryLocator(query);
}
*/

//開始
public void execute(List&lt;sObject&gt; scope){
//global void execute(Database.BatchableContext BC, List&lt;sObject&gt; scope){

    //バッチの処理を記述

}

//global void finish(Database.BatchableContext BC){}
</code></pre>

<p>}
```</p>

<p>これを匿名実行からSOQLでデータを取得してからそれを渡してやりつつ実行する。</p>

<p><code>
String soql = 'SELECT ID FROM sObject';
List&lt;sObject&gt; data = Database.query(soql);
Batch_sample batch = new Batch_sample();
batch.execute(data);
</code></p>

<p>もっとスマートなやり方があったらぜひ。</p>

<h2>テスト</h2>

<p>テストコードはスケジューラに対して実行する。</p>

<p><code>Schedule_sample_Test.apxc</code></p>

<p>```
@isTest
public class Schedule_sample_Test {</p>

<pre><code>public static String CRON_EXP = '0 0 0 15 3 ? 2022';

static testmethod void test() {
    //データ準備

    Test.startTest();
    String jobId = System.schedule('ScheduleApexClassTest', CRON_EXP, new Batch_sample());
    Test.stopTest();

    //バッチ後のデータ確認
}
</code></pre>

<p>}
```</p>

<p>指定するクーロン式はなんでもよくて、<code>Test.stopTest();</code>の後にすぐにスケジュールが実行される。</p>

<h2>参考</h2>

<p><a href="https://developer.salesforce.com/docs/atlas.ja-jp.apex_workbook.meta/apex_workbook/apex_scheduling_2.htm">スケジュール可能なクラスのテストの追加 | Apex ワークブック | Salesforce Developers</a><br/>
<a href="http://blog.flect.co.jp/salesforce/2010/08/apex-2136.html">セールスフォースの豆知識: スケジュール実行するApexのテストメソッドと実行時刻の詳細設定</a><br/>
<a href="http://blog.livedoor.jp/androidbeginner/archives/39179776.html">【Salesforce】Apexジョブの書き方 : 怠けろ！プログラマ！</a></p>
]]></content>
  </entry>
  
</feed>
