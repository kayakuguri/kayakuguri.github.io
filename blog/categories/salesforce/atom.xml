<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: salesforce | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/salesforce/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2018-10-22T18:41:36+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sites_dml_not_allowed]]></title>
    <link href="http://kayakuguri.github.io/blog/2018/10/22/sites-dml-not-allowed/"/>
    <updated>2018-10-22T18:25:25+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2018/10/22/sites-dml-not-allowed</id>
    <content type="html"><![CDATA[<p>Salesforceにて、サイトで公開しているページでオブジェクトにデータを挿入出来ずにハマったのでメモ。</p>

<!-- more -->


<h1>権限</h1>

<p>サイトで使用される権限は、設定した各サイト別にユーザが作られ、そのプロファイルで変更が可能。<br/>
作成したカスタムオブジェクトはデフォルトでは作成権限はないため、権限を与えてやる必要がある。</p>

<p><a href="https://help.salesforce.com/articleView?id=000006778&amp;language=ja&amp;type=1">Force.com サイトのゲストユーザラインセンス</a></p>

<p>そのプロファイルへアクセスするには…、</p>

<p>設定から、クイック検索に <code>サイト</code> と入力。<br/>
表示されるメニューから、<code>サイト</code> をクリック。</p>

<p><img src="/images/2018/10/sites_permission_01.jpg" alt="" /></p>

<p>サイト一覧から変更したいサイトの「表示ラベル」をクリック。<br/>
詳細が表示されるので、「公開アクセス設定」をクリック。</p>

<p><img src="/images/2018/10/sites_permission_02.jpg" alt="" /></p>

<p>ここから通常のプロファイルと同じように権限を変更してやることが可能。<br/>
オブジェクトへのアクセス権限を編集したい場合は、「オブジェクト設定」から変更してやる。</p>

<p><img src="/images/2018/10/sites_permission_03.jpg" alt="" /></p>

<p>ここから設定したいオブジェクトを選択し、オブジェクト権限、や、項目権限、を与えてやればよい。</p>

<h1>エラー</h1>

<p>しかし、上記の手順で、作成、権限を与えているにも関わらず、下記のエラーが出た。</p>

<blockquote><p>DML operation INSERT not allowed on YOUROBJECT__c</p></blockquote>

<h1>オブジェクトの設定</h1>

<p>色々確認していると、オブジェクトを公開していなかったから、だった。</p>

<p>カスタムオブジェクトの項目で、オブジェクトの<code>リリース状況</code>という設定があるのだが、これが<code>開発中</code>になっていたため、外部扱いとなるサイトからはインサートが出来なかったよう。</p>

<p><img src="/images/2018/10/sites_permission_04.jpg" alt="" /></p>

<p>これを<code>リリース済み</code>に変更すると、無事、インサートが可能となった。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[テスト内での個人取引先有効時のポータルユーザの作成方法]]></title>
    <link href="http://kayakuguri.github.io/blog/2018/06/11/create-portal-user-for-person-account/"/>
    <updated>2018-06-11T18:51:31+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2018/06/11/create-portal-user-for-person-account</id>
    <content type="html"><![CDATA[<p>テストコード内にて、取引先をポータルユーザとして作成したいのだが、個人取引先が有効になっている場合に少しハマったのでメモ。</p>

<!-- more -->


<p>ポータルユーザとして登録しようとすると、対象のユーザには<strong>必ず</strong>取引先責任者が紐付いていなければならないよう。 <br/>
指定せずに有効化しようとすると以下のようにエラーが出てしまう。</p>

<blockquote><p>取引先責任者のないポータルユーザは作成できません</p></blockquote>

<p>しかし個人取引先が有効になっている場合には取引先責任者は使用しないのでどれを指定すればいいのかわからず迷ってしまった。</p>

<p>個人取引先を有効にしている組織の場合、取引先(<code>Account</code>)を作成すると取引先責任者(<code>Contact</code>)が自動的に作成されるよう。<br/>
SF上では取引先しか見えていないのだが、<code>Contact</code>でクエリを実行して検索すると、同じ名前のレコードがヒットする。</p>

<p>よって、取引先を作成し、同時に作成される取引先責任者を検索しそれをユーザと紐付けてから、ポータルユーザとして登録してやることで無事、作成することが出来た。<br/>
手順としては以下。</p>

<ol>
<li>取引先(<code>Account</code>)を作成</li>
<li>取引先責任者(<code>Contact</code>)を取得</li>
<li>ユーザ(<code>User</code>)を作成</li>
<li>ポータルユーザとして登録</li>
</ol>


<p>実際のコードは以下。<br/>
ユーザを作成する際のプロフィールは作成済のポータルユーザ用のプロフィールを指定すること。</p>

<p>```
@isTest
public with sharing class CreatePortalUserTest {</p>

<pre><code>static testMethod void create() {
    // 1. 取引先を作成
    Account account = new Account(
            FirstName = '名',
            LastName = '姓'
    );
    insert account;

    // 2. 取引先責任者を取得
    Contact contact = [SELECT id,accountId FROM Contact LIMIT 1];

    // 3. ユーザを作成
    List&lt;Profile&gt; profiles = [SELECT Id FROM Profile WHERE Name IN ('プロフィール名')];
    User user = New User(
            Username = 'for_apex_test@example.com',
            Email = 'for_apex_test@example.com',
            LastName = '姓',
            Alias = '姓',
            TimeZoneSidKey = 'Asia/Tokyo',
            LocaleSidKey = 'ja_JP',
            EmailEncodingKey = 'ISO-2022-JP',
            ProfileId = profiles.get(0).Id,
            LanguageLocaleKey = 'ja',
            ContactId = contact.Id
    );
    insert user;

    // 4. ポータルユーザとして登録
    Site.createPortalUser(user, account.Id, 'password');


    // 確認
    Account acc = [SELECT id,IsCustomerPortal FROM Account LIMIT 1];
    System.assertEquals(acc.IsCustomerPortal, true);
}
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<ul>
<li><a href="https://developer.salesforce.com/docs/atlas.ja-jp.apexcode.meta/apexcode/apex_classes_sites.htm">Site クラス | Apex 開発者ガイド | Salesforce Developers</a></li>
<li><a href="https://developer.salesforce.com/forums/?id=906F00000008qL2IAI">How to create person account in Test class &ndash; Salesforce Developer Community</a></li>
<li><a href="https://qiita.com/shinsaka/items/b69467656a73b4ac0173">ユーザを作成するテストコードではUserNameに注意 &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visualforceに日付時間を表示する時にタイムゾーンを設定する]]></title>
    <link href="http://kayakuguri.github.io/blog/2018/06/05/vf-datetime-timezone/"/>
    <updated>2018-06-05T11:57:08+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2018/06/05/vf-datetime-timezone</id>
    <content type="html"><![CDATA[<p>日付時間( <code>datetime</code> )型のデータをVisualforceに表示する時に、<code>apex:outputtext</code>を使用すればフォーマットさせて表示することが出来るのだが、GMTで表示されてしまうため9時間ずれてしまう。</p>

<!-- more -->


<p>これはオプションでは用意されていないようで、apex側でずらす時間を指定してそれを足してやる、という方法でタイムゾーンを指定してやる必要があるよう。<br/>
apexで使用アカウントでセットされているタイムゾーンを取得してずれている時間のミリ秒を取得してそれを足す、という方法。</p>

<h3>apex</h3>

<p>```
//表示する日付
datetime_test = Datetime.newInstance(2018, 6, 5, 0, 0, 0);</p>

<p>public Double timezoneOffset{get{</p>

<pre><code>TimeZone tz = UserInfo.getTimeZone();
//Milliseconds to Day
return tz.getOffset(DateTime.now()) / (1000 * 3600 * 24.0);
</code></pre>

<p>}}
```</p>

<h3>VF</h3>

<p>```
{!datetime_test}
// Mon Jun 04 15:00:00 GMT</p>

<p>&lt;apex:outputtext value=&ldquo;{0, date, yyyy/MM/dd HH:mm:ss}&rdquo;></p>

<pre><code>&lt;apex:param value="{!datetime_test}" /&gt;
</code></pre>

<p>&lt;/apex:outputtext>
// 2018 2018/06/04 15:00:00</p>

<p>&lt;apex:outputtext value=&ldquo;{0, date, yyyy/MM/dd HH:mm:ss}&rdquo;></p>

<pre><code>&lt;apex:param value="{!datetime_test + timezoneOffset}" /&gt;
</code></pre>

<p>&lt;/apex:outputtext>
// 2018/06/05 00:00:00
```</p>

<h2>参考</h2>

<ul>
<li><a href="http://blog.flect.co.jp/salesforce/2010/08/visualforce-16a.html">セールスフォースの豆知識： Visualforceで数値や日付のフォーマットを指定して表示するには？</a></li>
<li><a href="https://success.salesforce.com/ideaView?id=08730000000i6AaAAI">apex：outputtext should support formatting of date/time in local time zone &ndash; Ideas &ndash; Salesforce Trailblazer Community</a></li>
<li><a href="https://salesforce.stackexchange.com/questions/15944/timezone-issue-with-datetime-field-again">visualforce &ndash; Timezone issue with Datetime Field ［again ;&ndash;)］ &ndash; Salesforce Stack Exchange</a></li>
<li><a href="https://www.xgeek.net/ja/salesforce/display-datetime-with-timezone-in-visualforce-page/">Visualforce Pageでタイムゾーン時間の出力 | Xgeek</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Illuminated Cloud 2を使ってみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2018/04/23/illuminated-cloud-2/"/>
    <updated>2018-04-23T15:19:26+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2018/04/23/illuminated-cloud-2</id>
    <content type="html"><![CDATA[<p>MavensMateが開発終了、ということで、Illuminated Cloudを使ってみる。</p>

<!-- more -->


<h1>概要</h1>

<p><a href="http://www.illuminatedcloud.com/">Illuminated Cloud</a></p>

<p>Salesforce公式が出している、JetBrainsのエディタのプラグイン。<br/>
<a href="https://plugins.jetbrains.com/plugin/10253-illuminated-cloud-2">Illuminated Cloud 2 ：： JetBrains Plugin Repository</a></p>

<p>補完もちゃんと出るし、テストやdeployも可能っぽい。<br/>
以下、英語だけどデモ動画。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/7kzZrCoNWN8?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>


<p>以下の２つのエディタで利用可能</p>

<ul>
<li>IntelliJ IDEA

<ul>
<li><a href="https://www.jetbrains.com/idea/">IntelliJ IDEA： The Java IDE for Professional Developers by JetBrains</a></li>
</ul>
</li>
<li>WebStorm IDEs

<ul>
<li><a href="https://www.jetbrains.com/webstorm/">WebStorm： The Smartest JavaScript IDE by JetBrains</a></li>
</ul>
</li>
</ul>


<p>IntelliJ IDEAのCommunity Editionなら無料で使用可能。</p>

<p>30日間は無料トライアルがあるが、それ以降は、$125/年、のサブスクリプションプランとなっている。</p>

<h1>インストール</h1>

<p>Preferencesから、Pluginsを選択し、Browse repositories&hellip;を選択。<br/>
検索に、<code>Illu</code>などと入力して、結果の、<code>Illuminated Cloud 2</code>を選択してインストールする。<br/>
(<code>Illuminated Cloud</code>無印の方は古い方なので間違えないように）</p>

<h1>プロジェクトの作成</h1>

<p>New Projectを選択し、Illuminated Cloudを選択。</p>

<p><img src="/images/2018/04/illuminated01.png" alt="" /></p>

<p>Connectionの部分で接続するSalesforceのアカウントを選択する。<br/>
まずはアカウントの設定が必要なので、鉛筆マークからアカウント情報を追加すする。</p>

<p><img src="/images/2018/04/illuminated02.png" alt="" /></p>

<p>入力して、Testボタンで接続テストが可能。Connection configuration is valid.と表示されればOK。<br/>
(TestせずにOKをクリックすると接続確認してからでないと接続出来ない、等の警告が出た）<br/>
OKをクリックすると、メタデータが取得され、どれを同期するかのリストが表示されるので、ApexやVFなど必要なものを選択してNextをクリック。</p>

<p><img src="/images/2018/04/illuminated03.jpg" alt="" /></p>

<p>プロジェクトの保存先を聞かれるので選択。</p>

<p>作成されると、以下のアラートが表示された。</p>

<p><img src="/images/2018/04/illuminated04.jpg" alt="" /></p>

<p>MavensMateなんかと同じく、保存アクション(コマンド+S)時にSFへDeployするかどうか、のよう。<br/>
ファイルの保存自体は自動で行われるので、deployしたい場合にのみ、コマンド+Sする、という流れになりそう。<br/>
Yesで有効化しておく。</p>

<h2>使用する</h2>

<p>FAQとして、メニューのショートカットの一覧？が載っていた。<br/>
<a href="http://www.illuminatedcloud.com/support/faq">FAQ &ndash; Illuminated Cloud</a></p>

<h3>新規作成</h3>

<p>新規作成はFile→Newで作成可能。<br/>
<code>src/classes</code>を選択した状態では<code>Apex Class</code>が、<code>src/pages</code>を選択した状態だと、<code>Visualforce Page</code>が選択肢に表示される。</p>

<p><img src="/images/2018/04/illuminated05.png" alt="" /></p>

<p>SF側の更新を聞かれるので、Yesで。</p>

<p><img src="/images/2018/04/illuminated06.png" alt="" /></p>

<p>作成するとSFの方にもそのまま作成される。</p>

<h3>削除</h3>

<p>ファイルを右クリックでDeleteを選択。いくつか聞かれるが、Yesを選んでいけば、SF上のファイルも削除される。</p>

<h3>同期</h3>

<p>SF側で作成や削除したファイルがあれば、Retrievalから同期が可能。</p>

<p><img src="/images/2018/04/illuminated07.jpg" alt="" /></p>

<p>新しく追加したい時は、Searver Onlyにチェックし、 <code>Retrieve for Merge</code>をクリックする。</p>

<p><img src="/images/2018/04/illuminated08.jpg" alt="" /></p>

<p>すると、マージするファイルの選択画面となるので、選択し、緑の三角をクリックして選択しているファイルをマージさせる。<br/>
(この場合は2ファイル追加）</p>

<p><img src="/images/2018/04/illuminated09.jpg" alt="" /></p>

<h3>テスト</h3>

<p>Run → Runを選択。(Ctrl + Opt + R)<br/>
Edit Configurations..というウインドウが出るのでそのままクリック。<br/>
左のツリーから、Apex Unit Testsを選択。<br/>
Test Classesからテストしたいクラスを選択。</p>

<p><img src="/images/2018/04/illuminated10.png" alt="" /></p>

<p>そのままRunをクリックすればテストが実行される。<br/>
結果は以下のような感じ。</p>

<p><img src="/images/2018/04/illuminated11.jpg" alt="" /></p>

<h1>まとめ</h1>

<p>Eclipseの時と違って特に悩むようなところはなかった。<br/>
ただ、この機能ってどこにあるんだろう？となった時に探す手段がない。<br/>
公式のドキュメントもそれらしいものがほぼないし。<br/>
とはいえ、公式で有料のものなので今後のサポートなどは安心感がある。Salesforce DXも対応しており、今後はこれ一択、とかになりそうな気配。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apex Rest APIで任意のステータスコードを返す]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/11/27/apex-rest-response/"/>
    <updated>2017-11-27T14:49:52+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/11/27/apex-rest-response</id>
    <content type="html"><![CDATA[<p>カスタムでApex Rest APIを作成する際にレスポンスにステータスコードを反映させる方法。</p>

<!-- more -->


<h1>概要</h1>

<p>今までは、返却用するJSON用のクラスを作成し、そのクラスを返却していたのだが、<br/>
そもそも返却の方法としてはそれが正しくなかった（お作法に則っていなかった）よう。</p>

<p><a href="https://kayakuguri.github.io/blog/2015/03/27/apex-rest-tips/">[salesforce]Apex REST作成時のtips</a><br/>
この辺の記事内で返却しているやり方。</p>

<p>実際には、<code>return</code>で結果を返す必要はなく、<code>RestResponse</code>クラスに追加してやるだけでよかった。</p>

<ul>
<li><a href="https://developer.salesforce.com/docs/atlas.ja-jp.apexcode.meta/apexcode/apex_methods_system_restresponse.htm">RestResponse クラス</a></li>
</ul>


<h1>RestResponse</h1>

<h2>ステータスコード</h2>

<p>ステータスコードの指定は以下のようにする。</p>

<p><code>
RestResponse res = RestContext.response;
res.statusCode = 400;
</code></p>

<h2>ヘッダ情報</h2>

<p>デフォルトの情報だと、<code>Content-Type</code>が<code>application/octetstream</code>になっているようなので、<code>application/json</code>に変更したい。<br/>
ヘッダ情報の追加・変更は以下のようにする。</p>

<p><code>
RestResponse res = RestContext.response;
res.addHeader('Content-Type', 'application/json');
</code></p>

<h2>レスポンス内容</h2>

<p>レスポンスの内容をJSONで返す場合、作成した返却用クラスをJSONにパースし、<code>Blob</code>にキャストして追加してやる。</p>

<p>```
ResultData result = new ResultData();</p>

<p>RestResponse res = RestContext.response;
res.responseBody = Blob.valueOf(JSON.serialize(result));
```</p>

<h2>コード</h2>

<p>上記をまとめると以下のような形になる。</p>

<p>```
@RestResource(urlMapping=&lsquo;/your/api&rsquo;)
global with sharing class Your_Apex_Class  {</p>

<pre><code>@HttpPost
global static void something_method() {
  ResultData result = new ResultData();
  result.success = false;
  ResultError error = new ResultError();
  result.error = error;

  RestResponse res = RestContext.response;
  res.addHeader('Content-Type', 'application/json');
  // (中略)

  if(/* エラーの場合 */){
    error.message = 'エラーメッセージ';
    res.statusCode = 400;
    res.responseBody = Blob.valueOf(JSON.serialize(result));
    return;
  }

  // (中略)
  result.success = true;
  res.statusCode = 200;
  res.responseBody = Blob.valueOf(JSON.serialize(result));
  return;
}

global class ResultData{
  global Boolean success;
  global ResultError error;
}

global class ResultError{
  global String message;
}
</code></pre>

<p>} <br/>
```</p>

<p>エラー発生時にはステータスコードが<code>400</code>で以下のようなJSONが返却される。</p>

<p>```
{</p>

<pre><code>"success": false,
"error": {
    "message": "エラーメッセージ"
}
</code></pre>

<p>}
```</p>

<h1>テスト</h1>

<p>テストクラスを書く際に、送信結果を取得する場合には以下のようにする。</p>

<p>```
@isTest static void your_something_test() {</p>

<pre><code>String json_str = '{ "YOUR" : "JSON_DATA" }';

//あらかじめ宣言が必要
RestRequest req = new RestRequest();
req.requestBody = Blob.valueof(json_str);
RestContext.request = req;
RestResponse res = new RestResponse();
RestContext.response = res;

Your_Apex_Class.something_method(); //実行

System.assertEquals(res.statusCode, 400); //ステータスコード
//返却されたJSON文字列をMapにキャストする
Map&lt;String, Object&gt; requestBody = (Map&lt;String, Object&gt;)JSON.deserializeUntyped(res.responseBody.ToString());
Map&lt;String, Object&gt; errorBody = (Map&lt;String, Object&gt;)requestBody.get('error');
System.assertEquals(errorBody.get('message'), 'エラーメッセージ'); //エラーメッセージ
</code></pre>

<p>}
```</p>

<h1>参考</h1>

<ul>
<li><a href="https://salesforce.stackexchange.com/questions/54010/apexrest-controlling-http-error-codes-on-exceptions">apexrest: controlling HTTP error codes on exceptions</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
