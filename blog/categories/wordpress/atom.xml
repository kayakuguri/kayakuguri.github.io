<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: wordpress | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/wordpress/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2016-05-13T18:26:41+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ローカルのWordPressをCloud9の環境へ引っ越す(DB)]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/11/27/cloud9-wordpress-mysqlimport/"/>
    <updated>2015-11-27T15:30:19+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/11/27/cloud9-wordpress-mysqlimport</id>
    <content type="html"><![CDATA[<p>ローカルで開発していたwordpressをCloud9に移動させるべく、DBのインポートをしてみた。</p>

<!-- more -->


<p>まずはCloud9でWordpressプロジェクトを作成する。<br/>
これは順場に選んでくだけで簡単に可能。</p>

<p><img src="/images/2015/11/c9_00.jpg" alt="" /></p>

<h2>MySqlの起動など</h2>

<p>mysqlの起動などは以下で可能。</p>

<p>```</p>

<h1>起動</h1>

<p>$ mysql-ctl start</p>

<h1>停止</h1>

<p>$ mysql-ctl stop
```</p>

<p><code>mysql-ctl</code>コマンドは以下を実行可能。</p>

<pre><code>[start|restart|stop|status|cli|install]
</code></pre>

<p>以下で、mysqlに入る事が出来る。</p>

<pre><code>$ mysql-ctl cli
...
mysql&gt; 
</code></pre>

<p>もしくは、ユーザー指定で普通にログインも出来る。</p>

<pre><code>$ mysql -u kayakuguri
</code></pre>

<p>この中でデータベースやテーブルを作成したり出来る。<br/>
なので、インポートするDBを作成しておく。</p>

<h2>ダンプファイルのアップロード</h2>

<p>ローカルのファイルをアップするのと同じ手順でダンプしたSQLファイルをアップロードする。<br/>
Cloud9のIDE上から、<code>File -&gt; Upload Local Files...</code>を選択。</p>

<p><img src="/images/2015/11/c9_01.jpg" alt="" /></p>

<p>アップしたいファイルをウインドウにドロップして完了。<br/>
直下にアップした。</p>

<p><img src="/images/2015/11/c9_02.jpg" alt="" /></p>

<h2>インポート</h2>

<p>これで準備は整ったのでダンプファイルをインポートする。<br/>
下部のエリアから、<code>bash</code>タブを選択し、そこにコマンドを打ち込んでいく。</p>

<p>mysqlのユーザー名はCloud9のログイン名と同じで、パスワードはかかっていない。<br/>
なので以下のようになる。</p>

<pre><code>$ mysql -u kayakuguri test_wp_db &lt; dump.sql
</code></pre>

<p><img src="/images/2015/11/c9_03.jpg" alt="" /></p>

<h3>サイトURLの変更</h3>

<p>このままだとローカルのサイトURLがwordpressのURLとして引き継がれてしまうので、コマンドで直接DBのデータをいじって変更してみる。</p>

<pre><code>$ mysql -u kayakuguri
</code></pre>

<p>mysqlにログイン。</p>

<pre><code># DBを選択
mysql&gt; use test_wp_db;
# 現状の設定を確認
mysql&gt; SELECT * FROM wpoptions WHERE option_name='siteurl';
# アップデート
mysql&gt; UPDATE wpoptions SET option_value='https://your-project-kayakuguri.c9users.io' where option_name IN ('home', 'siteurl');
</code></pre>

<p>URLはRUNさせてみると確認出来る。<br/>
(<code>https://プロジェクト名.ユーザー名.c9users.io/</code>っぽい)</p>

<h3>wp-configの変更</h3>

<p>wp-configにて、mysqlのユーザー名を指定していると思うので、それをCloud9用に変更しておく。<br/>
パスワードはいらない。</p>

<p>```
/<em>* MySQL データベースのユーザー名 </em>/
define(&lsquo;DB_USER&rsquo;, &lsquo;kayakuguri&rsquo;);</p>

<p>/<em>* MySQL データベースのパスワード </em>/
define(&lsquo;DB_PASSWORD&rsquo;, &lsquo;&rsquo;);
```</p>

<p>完了。</p>

<h2>注意</h2>

<p>wordpressプロジェクトで始めた場合、<code>wp-admin</code>、<code>wp-content</code>、<code>wp-includes</code>の主要なディレクトリを直下以外のディレクトリに移動が出来なかった。<br/>
なので、ドキュメントルート以外でwordpressを稼働させるプロジェクトの場合は注意が必要。</p>

<p>その場合は、PHPのプロジェクトとして作成し、自前で全ファイルをアップロードしてDBの設定などをすればよいかとも思ったが、どうも上手くいかなかった。<br/>
要調査。</p>

<p>ちなみにPHPの環境は今日現在、<code>PHP Version 5.5.9-1ubuntu4.13</code>だった。</p>

<h2>参考</h2>

<p><a href="https://docs.c9.io/docs/setting-up-mysql">Setting Up MySQL · Cloud9</a><br/>
<a href="http://qiita.com/hishigataBOZE/items/bdd6009d3bfc1c7d313b">[WordPress + MySQL] DBからサイトURLを変更 &ndash; Qiita</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[WordPress] 別のユーザーグループが投稿した記事を編集出来ないようにする]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/11/12/wordpress-usergroup-edit/"/>
    <updated>2015-11-12T15:49:20+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/11/12/wordpress-usergroup-edit</id>
    <content type="html"><![CDATA[<p>ユーザーグループを作成し、別のユーザーグループが作成した記事を別のユーザーグループが編集出来ないように設定してみた。</p>

<!-- more -->


<h2>カスタムユーザー権限の作成</h2>

<p>User Role Editorのプラグインを使用する。<br/>
<a href="https://ja.wordpress.org/plugins/user-role-editor/">https://ja.wordpress.org/plugins/user-role-editor/</a></p>

<p>インストール、有効化するとユーザーのメニュー内に、User Role Editorの項目が追加される。</p>

<p><img src="/images/2015/11/user_group01.jpg" alt="" /></p>

<p>右側メニュー内の<code>Add Role</code>をクリックし、新しく権限を追加する。<br/>
Role name(ID)は英数字で設定しておく。<br/>
Display Role Nameはわかりやすいように日本語でも大丈夫。<br/>
Make copy of で、コピー元の権限があれば選択する。<br/>
今回は投稿者の権限を利用する事にする。</p>

<p><img src="/images/2015/11/user_group02.jpg" alt="" /></p>

<p>もう一つ、white(白組)という権限も作成しておく。</p>

<h2>ユーザーグループの設定</h2>

<p>User Access Managerのプラグインを使用する。<br/>
<a href="https://ja.wordpress.org/plugins/user-access-manager/">https://ja.wordpress.org/plugins/user-access-manager/</a></p>

<p>インストール、有効化するとユーザーのメニュー内に、UAMというメニューが追加される。</p>

<p><img src="/images/2015/11/user_group03.jpg" alt="" /></p>

<p>メニューをクリックするとグループが一つもない状態であれば、Add user groupが表示される状態となる。<br/>
なので、ここでユーザーグループを作成する。</p>

<p><code>User group name</code> はグループ名だが、日本語でも問題なかった。<br/>
<code>User group description</code> はグループの説明。<br/>
<code>IP range</code> はこのグループに属するユーザーのアクセスIPを制限する際に使用する。<br/>
<code>Read access</code> は、このグループが投稿した記事をだれが閲覧できるか、を設定する。<br/>
<code>All</code> にすれば誰でも閲覧可能。<br/>
<code>only group users</code> にすればこのユーザーグループのユーザーしか閲覧が出来ない。<br/>
今回は閲覧は全員可能としたかったので、allにした。<br/>
<code>Write access</code> は、この投稿した記事をだれが編集できるか、を設定する。<br/>
内容はReadと同じ。<br/>
今回は正にここが肝で、作成したユーザーグループ以外のユーザーには編集させないので、 <code>only group users</code> とした。<br/>
<code>Role affiliation</code>は、このユーザーグループに属する権限の設定。<br/>
ここを設定するとユーザーを作成する際に選んだ権限に属するユーザーグループは必ず選ばれるようになる。<br/>
要するに、権限を選べば自動でユーザーグループも指定されるので、設定しておいた方が楽。<br/>
ユーザーグループに入れるユーザーを個別に選びたい場合は外しておけばいいと思う。</p>

<p><img src="/images/2015/11/user_group04.jpg" alt="" /></p>

<p>同じく白組も登録しておく。</p>

<p><img src="/images/2015/11/user_group05.jpg" alt="" /></p>

<h2>ユーザーの追加</h2>

<p>ユーザーを追加する。<br/>
今回の環境が色々カスタマイズしているため未確認だけど、どうやら新規登録の際にはユーザーグループを選択する項目はなさそう。<br/>
とはいえ、権限を選べばグループも設定されるようになっているので問題はなし。<br/>
(権限ロールで、作成した「白組」の権限を選択するのを忘れないように）</p>

<p><img src="/images/2015/11/user_group06.jpg" alt="" /></p>

<p>同様に赤組ユーザーも追加する。<br/>
以下のように、権限ロールを設定しただけで、ユーザーグループも設定されていることがわかる。</p>

<p><img src="/images/2015/11/user_group07.jpg" alt="" /></p>

<h2>記事の投稿</h2>

<p>記事を投稿する。<br/>
この時にその記事を編集可能なユーザーグループを選択するのだけど、<br/>
ユーザーグループに所属しているユーザーで記事を作成しようとするとユーザーグループ選択の項目が表示されない。<br/>
なので、User Access Managerの設定画面で以下の項目を <code>Yes</code> に変更する。</p>

<blockquote><p>UAM &ndash;> Setting &ndash;> Authors settings &ndash;> Authors can add content to their own groups</p></blockquote>

<p><img src="/images/2015/11/user_group08.jpg" alt="" /></p>

<p>右側の列に以下のようなボックスが表示される。<br/>
記事作成の際に、チェックを入れるのを忘れないようにする。<br/>
(忘れてしまうとだれでも編集可能な記事となってしまう）</p>

<p><img src="/images/2015/11/user_group09.jpg" alt="" /></p>

<p>管理者権限でログインして一覧を見ると以下のような状況だが、</p>

<p><img src="/images/2015/11/user_group10.jpg" alt="" /></p>

<p>例えば白組のユーザーでログインして見ると以下のように白組に設定した記事のみが表示される。</p>

<p><img src="/images/2015/11/user_group11.jpg" alt="" /></p>

<h2>まとめ</h2>

<p>これで目的は達成出来た。<br/>
記事投稿する際にグループを選択しないといけない、など少し運用がめんどうになりそうな気配はあるが、<br/>
カスタムでここを触るのは現状不可能そうなので、プラグインでの対応しかなさそう。</p>

<h2>参考</h2>

<p><a href="http://ameblo.jp/signum21/entry-11468274679.html">WordPress会員制サイト構築 その7 User Access Manager｜オレオレWebサービス指南書！ 自分のチカラでサーバー世界を自由に創造するから面白い</a><br/>
<a href="http://ameblo.jp/ifl-nagatsuma-noriyuki/entry-11093035839.html">【WordPress】ユーザーごとに投稿ページ・固定ページの閲覧権限を設定する｜長妻紀之のブログ</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[WordPress]新規ユーザー登録時に選べる権限を制限する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/07/01/wordpress-capabilities/"/>
    <updated>2015-07-01T13:24:37+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/07/01/wordpress-capabilities</id>
    <content type="html"><![CDATA[<p>Wordpressにて、自分に設定されている権限レベル以下の権限のみを取得して、<br/>
新規登録画面で登録出来る権限を制御できるようにしてみた。</p>

<!-- more  -->


<h2>権限一覧の取得</h2>

<p>```
function xx(){</p>

<pre><code>global $wp_roles;
$all_roles = $wp_roles-&gt;roles;
</code></pre>

<p>}
```</p>

<p>出力</p>

<p>```
[(権限名-スラッグ)] => Array</p>

<pre><code>    (
        [name] =&gt; 権限名
        [capabilities] =&gt; Array
            (
                [read] =&gt; 1
                [level_0] =&gt; 1
                権限内容                    
            )

    )
</code></pre>

<p>```</p>

<h2>シリアライズ</h2>

<p>自分に設定されている権限を取得する。<br/>
ただし、DBを直接除くとシリアライズされている。</p>

<p>とはいえ、取得は普通にWPの関数で可能。</p>

<pre><code>get_user_meta(ID, 'wp_capabilities', true);
</code></pre>

<p>セットは以下のように</p>

<pre><code>update_user_meta($user_id, 'wp_capabilities', ['staff' =&gt; 1]);
</code></pre>

<h2>取得</h2>

<h3>自分のレベルを取得</h3>

<p><code>
global $current_user;
$mylevel = $current_user-&gt;user_level;
</code></p>

<p>これで一見取れているようにみえたが、なぜかレベルの低いユーザーもレベルが10と取得されてしまった。<br/>
なので、実際に入っているデータの、<code>level_xx</code>を見て一致させていく泥臭い手法をとった。</p>

<p>```
$uid = wp_get_current_user()&ndash;>get(&lsquo;ID&rsquo;);
//自分のロール
$my_role = get_user_meta($uid, &lsquo;wp_capabilities&rsquo;, true);
$my_role = key($my_role);
$myobj = $wp_roles->role_objects[$my_role]&ndash;>capabilities;
$mylevel = 0;
for($i = 10; $i>=0; $i&mdash;){</p>

<pre><code>if(isset($myobj['level_'.$i]) &amp;&amp; $myobj['level_'.$i]){
    $mylevel = $i;
    break;
}
</code></pre>

<p>}
```</p>

<h3>アクセス可能な権限をレベルで判別</h3>

<p>あとは取得したレベルと、権限の一覧のレベルを比べて、自分の方が大きければ取得していけばよい。</p>

<p>```
global $wp_roles;</p>

<p>$aste_user_role = [];
foreach($wp_roles->role_objects as $key=>$role){</p>

<pre><code>$level = 0;
for($i = 10; $i&gt;=0; $i--){
    if(isset($role-&gt;capabilities['level_'.$i]) &amp;&amp; $role-&gt;capabilities['level_'.$i]){
        $level = $i;
        break;
    }
}
if($mylevel &gt;= $level){
    $aste_user_role[] = [$key, $wp_roles-&gt;role_names[$key]];
}
</code></pre>

<p>}
```</p>

<p>結果</p>

<p>```
array (size=8)
  0 =></p>

<pre><code>array (size=2)
  0 =&gt; string 'administrator' (length=13)
  1 =&gt; string 'システム管理者' (length=21)
</code></pre>

<p>  1 =></p>

<pre><code>array (size=2)
  0 =&gt; string 'staff' (length=5)
  1 =&gt; string 'スタッフ' (length=12)
</code></pre>

<p>  2 =></p>

<pre><code>array (size=2)
</code></pre>

<p>&hellip;
&hellip;
```</p>

<h2>表示</h2>

<h3>新規登録</h3>

<p>新規登録画面への表示は、<code>user_new_form</code>のフックで行う。<br/>
フック内でHTMLを直接書いて対応。</p>

<p>```
//ユーザー登録画面
function user_new_form_css() {</p>

<pre><code>?&gt;
&lt;table class="form-table"&gt;
&lt;tr&gt;
    &lt;th scope="row"&gt;権限ロール &lt;span class="description"&gt;(必須)&lt;/span&gt;&lt;/th&gt;
    &lt;td&gt;&lt;select name="user_role"&gt;
            &lt;?php
            $tempo = '';
            foreach ($aste_user_role as $val) {
                $selected = 'selected';
                if($val[0] == 'subscriber'){
                    $tempo .= '&lt;option value="' . $val[0] . '"' . $selected . '&gt;' . $val[1] . '&lt;/option&gt;';
                }else{
                    $tempo .= '&lt;option value="' . $val[0] . '" &gt;' . $val[1] . '&lt;/option&gt;';
                }
            }
            echo $tempo;
            ?&gt;
        &lt;/select&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;?php
</code></pre>

<p>}
add_action( &lsquo;user_new_form&rsquo;, &lsquo;user_new_form_css&rsquo; );
```</p>

<h3>編集</h3>

<p>編集画面は、<code>personal_options</code>のフックで対応。</p>

<p>```
function add_profile_custom ($profileuser) {</p>

<pre><code>//権限
global $aste_user_role; //自身が参照可能な権限リスト
set_aste_role();
$html = '&lt;tr&gt;&lt;th scope="row"&gt;権限ロール &lt;span class="description"&gt;(必須)&lt;/span&gt;&lt;/th&gt;';
$html .= '&lt;td&gt;&lt;select name="user_role"&gt;';
//このユーザーの権現を取得
$current_role = get_user_meta($profileuser-&gt;ID, 'wp_capabilities', true);
$current_role = key($current_role);
foreach ($aste_user_role as $val) {
    $r = $current_role;
    $selected = '';
    if ($r == $val[0]) {
        $selected = ' selected="selected" ';
    }
    $html .= '&lt;option value="' . $val[0] . '"' . $selected . '&gt;' . $val[1] . '&lt;/option&gt;';
}
$html .= '&lt;/select&gt;&lt;/td&gt;&lt;/tr&gt;';
echo $html;
</code></pre>

<p>}
add_action( &lsquo;personal_options&rsquo;, &lsquo;add_profile_custom&rsquo;);
```</p>

<h2>登録処理</h2>

<p>登録は新規は、<code>user_register</code>、更新は、<code>profile_update</code>。<br/>
どちらも処理としては同じ。<br/>
<code>$_POST</code>から取得した値をシリアライズして入れる、のみ。</p>

<p>```
function save_custom_options_fields( $user_id ) {</p>

<pre><code>//権限ロール
$role_name = $_POST['user_role'];
update_user_meta($user_id, 'wp_capabilities', [$role_name =&gt; 1]);
</code></pre>

<p>}
add_action( &lsquo;profile_update&rsquo;, &lsquo;save_custom_options_fields&rsquo; ); //更新
add_action(&lsquo;user_register&rsquo;, &lsquo;save_custom_options_fields&rsquo;);  //新規登録
```</p>

<h2>既存のものを非表示に</h2>

<p>既存で表示されている権限設定のセレクトボックスを非表示に。</p>

<h3>新規登録</h3>

<p>上記、新規登録で項目を追加したフックと同じ関数内で実装する。<br/>
特定のクラスもIDも振られてないので、x番目と指定して非表示とする。<br/>
ただし、これはCSS3となっているので非対応のブラウザだと見えてしまうと思う。<br/>
他にいい方法があれば知りたい。</p>

<p>```
?><style type="text/css"></p>

<pre><code>table.form-table tr.form-field:nth-of-type(9)
</code></pre>

<p></style>&lt;?php
```</p>

<h3>編集</h3>

<p>上記、編集で項目を追加したフックと同じ関数内で実装する。<br/>
こちらはクラスが振ってあるので、それを指定して非表示とする。</p>

<p>```
?><style type="text/css"></p>

<pre><code>.user-role-wrap, /*権限グループ*/
</code></pre>

<p></style>&lt;?php
```</p>

<h2>まとめ</h2>

<p>これにて完成。<br/>
非表示にする箇所がかなり無理矢理だけれども、なんとか見た目は整った。<br/>
プラグインなどを使えばこの辺一発で出来たりするのだろうか。<br/>
ちなみに、権限の編集にはプラグインを使用した。<br/>
<a href="https://ja.wordpress.org/plugins/user-role-editor/">WordPress &#8250; User Role Editor &laquo; WordPress Plugins</a></p>

<h2>参考</h2>

<p><a href="http://wordpress.stackexchange.com/questions/1665/getting-a-list-of-currently-available-roles-on-a-wordpress-site">security &ndash; Getting a List of Currently Available Roles on a WordPress Site? &ndash; WordPress Development Stack Exchange</a><br/>
<a href="http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q12132319417">wordpressのユーザ権限を管理画面以外から変更する必要があり、～ &ndash; Yahoo!知恵袋</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wordpress上のメディアをcloudinaryに自動アップロードして管理する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/06/30/auto-upload-cloudinary-on-heroku/"/>
    <updated>2015-06-30T12:54:33+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/06/30/auto-upload-cloudinary-on-heroku</id>
    <content type="html"><![CDATA[<p>herokuでwordpressを使用した場合、通常ではアップロードした画像は<br/>
heorkuの再起動のタイミングで全て消えてしまいます。</p>

<!-- more -->


<p>なので、そうならないようにクラウド上のストレージサービスである、cloudinaryに保存させたりします。<br/>
cloudinaryには公式でwordpressのプラグインが用意されています。<br/>
<a href="https://ja.wordpress.org/plugins/cloudinary-image-management-and-manipulation-in-the-cloud-cdn/">WordPress &#8250; Cloudinary &ndash; Image management and manipulation in the cloud + CDN &laquo; WordPress Plugins</a></p>

<p>これを利用することでwordpress上の画像をcloudinaryで管理できるようになるのですが、<br/>
アップロードした画像を手動でcloudinaryに反映させてやらねばなりません。<br/>
それをなんとか自動でアップされるようにしてみました。</p>

<h2>cloudinaryへのアップロード手順(通常)</h2>

<p>通常と同じようにメディアライブラリ上から画像をアップロードします。<br/>
一覧表示で、詳細まで表示される、テーブル表示に切り替えます。<br/>
この時の右端に、<code>Upload to Cloudinary</code>というリンクがあるのでそれをクリックします。</p>

<p><img src="/images/2015/06/cloudinary_heroku01.jpg" alt="" /></p>

<p>するとアップロードされ、表記がアップロード済に変わります。</p>

<p><img src="/images/2015/06/cloudinary_heroku02.jpg" alt="" /></p>

<p>この時に内部では何をしているかと言うと、<br/>
cloudinaryにアップロードし、アップ先のURLを使ってメタデータを書き換え、<br/>
cloudinaryへアップした、というフラグを立てています。<br/>
このフラグを立てているところがポイントになります。</p>

<h2>メタデータ</h2>

<p>wordpressでは画像は投稿データとして管理されています。<br/>
データ構造は以下が詳しいのですが、画像部分だけを引用させてもらうとこんな感じです。<br/>
<a href="http://hijiriworld.com/web/wp-data-register/">WordPress データ登録機構を知ってもっと自由で効率的なフローを  |  hijiriworld Web</a></p>

<p><code>wp_posts</code>テーブル</p>

<table>
<thead>
<tr>
<th>post_title </th>
<th> post_status </th>
<th> post_name </th>
<th> guid </th>
<th> post_type </th>
<th> post_mine_type</th>
</tr>
</thead>
<tbody>
<tr>
<td>{$file_name} </td>
<td> inherit </td>
<td> {$file_name} </td>
<td> {$guid} </td>
<td> attachment </td>
<td> {$mine_type}</td>
</tr>
</tbody>
</table>


<p><code>wp_postmeta</code>テーブル</p>

<table>
<thead>
<tr>
<th>post_id </th>
<th> meta_key </th>
<th> meta_value</th>
</tr>
</thead>
<tbody>
<tr>
<td>{$attachment_id} </td>
<td> _wp_attached_file </td>
<td> {$file_name}</td>
</tr>
<tr>
<td>{$attachment_id} </td>
<td> _wp_attachment_metadata </td>
<td> シリアライズされたメタデータ</td>
</tr>
</tbody>
</table>


<p>wp_postsの方は特に変更する必要はありません。<br/>
重要なのはwp_postmetaのメタデータの方です。</p>

<p>今回、変更する具体的な箇所は以下の２箇所です。<br/>
<code>_wp_attached_file</code>をファイル名からcloudinaryのURLへ変更。<br/>
<code>_wp_attachment_metadata</code>の中にcloudinaryフラグを立てる。</p>

<h2>メディア管理とプラグインの仕組み</h2>

<p>wordpressのメディアは都度URLを動的に生成しています。<br/>
メイン画像の場合は以下。</p>

<blockquote><p>ブログのパス + <code>_wp_attached_file</code>の$file_name</p></blockquote>

<p>サムネイルの場合は以下。</p>

<blockquote><p>ブログのパス + <code>_wp_attachment_metadata</code>の指定サイズのファイル名</p></blockquote>

<p>なのでファイル名にcloudinaryの絶対パスを入れてしまうとURLが２重になってしまいます。</p>

<p>で。<br/>
これが、cloudinaryのフラグが立っているものに関しては、cloudinaryのプラグイン側でURLをうまい具合に置き換えて表示してくれます。<br/>
なので、こちらとしてはフラグを立てるだけ、で大丈夫。</p>

<h2>実作業</h2>

<p>処理の流れは以下のように。</p>

<ol>
<li>画像をアップロード</li>
<li>メタデータ作成のフック内で画像URLを取得</li>
<li>取得したURLでcloudinaryにアップロード</li>
<li>cloudinaryのURLでDBのファイル名を更新</li>
<li>メタデータにフラグを立てる</li>
</ol>


<p><code>wp_generate_attachment_metadata</code>で、アップされたファイルのメタデータを作成する処理にフックをかけられるのでそれを使用します。</p>

<p>functions.phpに以下を記述。</p>

<p>```
function cldnry_wp_generate_attachment_metadata($metadata, $postid){</p>

<pre><code>$imgPath = get_attached_file( $postid );

//ファイル形式のチェック
$info = pathinfo($imgPath);
$public_id = $info["filename"];
$mime_types = array("png"=&gt;"image/png", "jpg"=&gt;"image/jpeg", "pdf"=&gt;"application/pdf", "gif"=&gt;"image/gif", "bmp"=&gt;"image/bmp");
$extension = $info["extension"];
$type = @$mime_types[$extension];
//画像以外はcloudinaryにアップしない
if($type === null){
    $stderr = fopen( 'php://stderr', 'w' );
    fwrite( $stderr, 'アップロードされたファイルが画像ではありません。file-type:'.$extension );
    return $metadata;
}

//Cloudinaryへアップ
$cl_upload = new CloudinaryUploader();
$uploaded = $cl_upload-&gt;upload($imgPath, array(
));
$public_id = $uploaded['public_id'];

//DBへ保存
update_attached_file($postid, $uploaded['secure_url']);
$metadata['cloudinary'] = true; //cloudinaryからアップしたことを記録

return $metadata;
</code></pre>

<p>}
add_filter( &ldquo;wp_generate_attachment_metadata&rdquo; , &ldquo;cldnry_wp_generate_attachment_metadata&rdquo;,10 ,2 );
```</p>

<p>※2015/08/21追記<br/>
cloudinaryへアップする際にpublic_idを指定してしまうと画像が次々と上書きされてしまうので、その部分を削除しました。</p>

<p>  &ldquo;public_id&rdquo; => $public_id,</p>

<p>まず、<code>get_attached_file( $postid )</code>でアップされたファイルのURLを取得。<br/>
そのファイルが画像かどうかを一応チェックしている。<br/>
で、cloudinaryへアップロード。<br/>
cloudinaryはプラグインのファイルから利用するので公式で解説されているコードとは少し異なります。<br/>
で、アップされたらURLをファイル名として保存。<br/>
最後にポイントとなる、フラグを立てて終了。</p>

<p>これだけであとの表示周りの処理はcloudinaryがやってくれます。</p>

<h2>結果</h2>

<p>通常と同じように画像をアップすると、アップ完了時点でcloudinaryへ保存されます。<br/>
以下のようにURLがcloudinaryになっている事が確認できるかと思います。</p>

<p><img src="/images/2015/06/cloudinary_heroku03.jpg" alt="" /></p>

<p>一覧でテーブル表示にすると、cloudinaryにはすでにアップロード済の表記となっています。</p>

<h2>まとめ</h2>

<p>herokuでwordpressを扱う場合、この画像問題がネックの一つとなっているのですが、<br/>
herokuにはcloudinaryのアドオンがあるので、これでとりあえずは解消したのではないでしょうか。<br/>
この解消は自分の中ではかなり大きいです。</p>

<p>使用の際の注意点としては、wordpress上でデータを削除してもcloudinary上からは削除されない、という点です。<br/>
cloudinaryのアップロード容量が決まっているため、メンテナンスが必要かもしれません。</p>

<p>あとはアップデートの問題が解決すればすっきり出来るのですが。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wordpressをherokuにインストールする場合はルーティングのhtaccessを自分で設置すること]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/05/22/heroku-wp-htaccess/"/>
    <updated>2015-05-22T16:11:35+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/05/22/heroku-wp-htaccess</id>
    <content type="html"><![CDATA[<p>タイトルママ。<br/>
ちょっとハマったのでメモ。</p>

<!-- more -->


<h2>WordPressのインストール</h2>

<p>以下の手順で通常通りwordpressをインストールした。</p>

<ol>
<li>herokuにインストール用のアプリを作成</li>
<li>gitでローカルにclone</li>
<li>2のディレクトリ内に<a href="https://ja.wordpress.org/">Wordpress日本語版</a>をダウンロードして展開</li>
<li>herokuのアプリにmySQLのアドオン、<a href="https://addons.heroku.com/cleardb">ClearDB</a>を入れる</li>
<li>環境変数から、DBの接続情報を確認。<br/>
<code>mysql://ユーザ名:パスワード@サーバ名/データベース?reconnect=true</code></li>
<li>wp-config.phpにDB情報を反映</li>
<li>PushしてDploy</li>
<li>wp-admin/install.phpにアクセスして、サイト名やユーザー名などを設定してインストール。</li>
<li>完了</li>
</ol>


<h2>固定ページにアクセス</h2>

<p>通常の投稿でもたぶん同じ事が起こると思うが、<br/>
最初から入っているサンプルの固定ページにアクセス。</p>

<blockquote><p><a href="http://YOUR-APP-NAME.herokuapp.com/sample-page/">http://YOUR-APP-NAME.herokuapp.com/sample-page/</a></p></blockquote>

<p>アクセスを確認してから、特にソースは触らずに<a href="http://kayakuguri.github.io/blog/2015/04/21/git-allow-empty/">空でdeploy</a>。</p>

<p>再度上記の固定ページにアクセスすると、<strong>404 Notfound</strong>。</p>

<h2>ルーティング</h2>

<p>ローカルに入れていたWordPressのディレクトとファイルを見比べていると、<br/>
ローカルのものはドキュメントルートに<code>.htaccess</code>がある。</p>

<p>中身を見ていると、リダイレクトしているよう。</p>

<p>どうやら、wordpressのインストール時に、wordpressのルートにルーティング用の<code>.htaccess</code>を自動で作成するよう。<br/>
それがdeployのタイミングで消えてしまい、リダイレクトがかからず、404となっていた。</p>

<p><code>.htaccess</code>の中身は以下。</p>

<p>```</p>

<h1>BEGIN WordPress</h1>

<p><IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
RewriteRule ^index.php$ &ndash; [L]
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . /index.php [L]
</IfModule></p>

<h1>END WordPress</h1>

<p>```</p>

<p>これを<code>.htaccess</code>の名前でwordpressのルートに保存してやり、git管理下においてやればよい。</p>

<p>これを置いた状態であれば、deployかけても問題なくアクセスが出来た。</p>
]]></content>
  </entry>
  
</feed>
