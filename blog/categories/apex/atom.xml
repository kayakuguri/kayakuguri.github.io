<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apex | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/apex/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2015-04-28T20:26:51+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[apex][SF]ApexRESTのテストコードでのパラメータの渡し方]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/04/20/rest-apex-test/"/>
    <updated>2015-04-20T15:43:39+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/04/20/rest-apex-test</id>
    <content type="html"><![CDATA[<p>いくつくか方法があるような。<br/>
そのうち一番楽だったものを。</p>

<!-- more -->


<p>例えば以下のようなクラスを作ったとする。</p>

<p>```
@RestResource(urlMapping=&lsquo;/user/*&rsquo;)
global with sharing class userInfo_API {</p>

<pre><code>@HttpPost
global static ResultData doPost(){
    RestRequest req = RestContext.request;
    String user_id = req.params.get('user_id');

    //何らかの処理
}
</code></pre>

<p>}
```</p>

<p>この場合、<code>user_id</code>を渡すためには以下のように記述します。</p>

<p>```
@isTest
private class Test_userInfo_API {</p>

<pre><code>static testMethod void postTest(){
    RestRequest req = new RestRequest();
    RestContext.request = req;
    req.addParameter('user_id', 'ユーザーID');
    userInfo_API.doPost();
}
</code></pre>

<p>}
```</p>

<p><code>RestRequest</code>のパラメータにセットしておくだけでOKなよう。</p>

<p>余談。<br/>
APIのクラスのみを実行させようとしてもエラーが出る。</p>

<blockquote><p>System.NullPointerException: Attempt to de-reference a null object</p></blockquote>

<p>なのでテストメソッド内では最低限以下は必要。</p>

<p><code>
RestRequest req = new RestRequest();
RestContext.request = req;
userInfo_API.doPost();
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[apex][SF]InboundEmailHandlerを使ったリードの作成]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/04/17/inboundemailhandler-apex/"/>
    <updated>2015-04-17T14:47:20+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/04/17/inboundemailhandler-apex</id>
    <content type="html"><![CDATA[<p>salesforceでメールを受け取って、そのメールアドレスでリードを作る方法と、<br/>
エラーで返信するときの方法。</p>

<!-- more -->


<h2>apex</h2>

<p>メールサービスを作成する際にapexクラスを指定するので、先に作成しておきます。</p>

<p>例えば今回は、送信元のメールアドレスを使用してリードを作成するとします。<br/>
また、すでに登録されているメールアドレスの場合、エラーメールを返信するとします。</p>

<p>```
global class MailCreateLead implements Messaging.InboundEmailHandler {</p>

<pre><code>global Messaging.InboundEmailResult handleInboundEmail(Messaging.InboundEmail email, Messaging.InboundEnvelope envelope) {
    Messaging.InboundEmailResult result = new Messaging.InboundEmailresult();

    //メールが重複しているかどうかをチェック
    String mail_str = email.fromAddress;
    List&lt;Lead&gt; check = [SELECT id FROM Lead WHERE Email=:mail_str LIMIT 1];
    if(check.size() != 0){
        result.message = '送信されたメールアドレスはすでに登録済です。';
        result.success = false;
    }else{
        Lead l = new Lead();
        l.Company = '-'; //(必須)
        l.LastName = (email.fromName == null) ? 'メール会員' : email.fromName;
        l.Email = email.fromAddress;
        insert l;
        result.success = true;
    }

    return result;
}
</code></pre>

<p>}
```</p>

<p><code>Messaging.InboundEmailResult</code>を返却するが、<code>success</code>がfalseの場合は、<br/>
受信を拒否し、設定されたエラーメッセージ(<code>message</code>)を送信元のメールアドレスに返す。<br/>
この時返信されるメールは、<code>noreply@salesforce.com</code>となっており、これは変更できないっぽい。</p>

<p>重複していない場合は、送信元のメールアドレスと名前(あれば)を使用してリードを作っている。</p>

<h3>テストコード</h3>

<p>```
@isTest
public class MailCreateLead_Test {</p>

<pre><code>//正常時
private static testMethod void execute_success() {
    Test.startTest();

    Messaging.InboundEmail email = new Messaging.InboundEmail() ;
    Messaging.InboundEnvelope env = new Messaging.InboundEnvelope();
    email.subject = 'Test Success';
    email.fromname = 'FirstName LastName';
    email.fromAddress = 'someaddress@email.com';
    email.plainTextBody = '';

    MailServiceToCreateLead emailService = new MailServiceToCreateLead();
    Messaging.InboundEmailResult res = emailService.handleInboundEmail(email, env);

    Test.stopTest();
}

//エラー時
private static testMethod void execute_fail(){
    //重複チェック
    Lead le = new Lead();
    le.Company = '-';
    le.LastName = 'failed test';
    le.Email = 'test@test.com';
    Insert le;

    Test.startTest();

    Messaging.InboundEmail email = new Messaging.InboundEmail() ;
    Messaging.InboundEnvelope env = new Messaging.InboundEnvelope();
    email.subject = 'Test Failed';
    email.fromname = 'FirstName LastName';
    email.fromAddress = 'test@test.com'; //上記メールアドレスと被せる
    email.plainTextBody = '';
    MailServiceToCreateLead emailService = new MailServiceToCreateLead();
    Messaging.InboundEmailResult res = emailService.handleInboundEmail(email, env);

    Test.stopTest();
}
</code></pre>

<p>}
```</p>

<h2>メールサービス</h2>

<p><code>設定 &gt; 開発 &gt; メールサービス</code>から作成します。</p>

<p><img src="/images/2015/04/inboundemailhandler01.jpg" alt="メールサービス" /></p>

<p>設定内容は、サービス名と、先程作成したapexクラスを指定してやるくらいです。</p>

<p><img src="/images/2015/04/inboundemailhandler02.jpg" alt="新規作成" /></p>

<p>作成後、ユニークなメールアドレスが割り当てられるので、<br/>
そのアドレス宛てに送信するとメールサービスが起動します。</p>

<p><img src="/images/2015/04/inboundemailhandler03.jpg" alt="設定内容" /></p>

<h2>参考</h2>

<p><a href="https://help.salesforce.com/HTViewHelpDoc?id=code_inbound_email.htm&amp;language=ja">InboundEmail &#12458;&#12502;&#12472;&#12455;&#12463;&#12488;&#12398;&#20351;&#29992;</a><br/>
<a href="https://developer.salesforce.com/page/An_Introduction_To_Email_Services_on_Force.com">An Introduction To Email Services on Force.com &ndash; developer.force.com</a><br/>
<a href="http://tyoshikawa1106.hatenablog.com/entry/2013/07/31/213518">SFDC：Messaging.InboundEmailHandlerについて &ndash; tyoshikawa1106のブログ</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[apex]トリガーのインサートエラーのテストコードを書く]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/04/14/apex-test-trigger/"/>
    <updated>2015-04-14T17:31:36+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/04/14/apex-test-trigger</id>
    <content type="html"><![CDATA[<p>言われてみれば当たり前なんですが、メモ。</p>

<!-- more -->


<p>レコードがインサートされた際にデータ内容をチェックして、間違っていればエラーを返す、というトリガーを作成した。<br/>
要するに、自前のバリデーションチェックみたいなもの。<br/>
このテストコードを書いた際に、そのエラー部分も通るように作ってしまうと、テストコード自体がエラーになってしまってチェック出来なかった。</p>

<p>で、解決策としては単純で、<code>try〜catch</code>を使う。</p>

<p>以下、例。</p>

<h3>apex</h3>

<p>```
trigger SampleLeadTrigger on Lead (before insert) {</p>

<pre><code>for(Lead obj : Trigger.New){
    if(obj.LastName == 'test'){
        obj.addError('testという名前は使えません');
        continue;
    }
}
</code></pre>

<p>}
```</p>

<p>姓に、<code>test</code>という文字列の使用をエラーとするトリガーです。</p>

<h3>テストコード</h3>

<p>以下にようにそのままテストコードを書いてみます。</p>

<p>```
@isTest
private class Test_SampleLeadTrigger {</p>

<pre><code>static testMethod void excute(){
    Lead test_obj = new Lead();
    test_obj.Company = 'hoge co.';
    test_obj.LastName = 'test';

    insert test_obj;
}
</code></pre>

<p>}
```</p>

<p>すると、以下のようなエラーが出てしまい、テストコードが実行できません。</p>

<blockquote><p>18:14:44:833 FATAL_ERROR System.DmlException: Insert failed. First exception on row 0; first error: FIELD_CUSTOM_VALIDATION_EXCEPTION, testという名前は使えません: []</p></blockquote>

<p>なので、<code>insert</code>する部分を<code>try-catch</code>で例外をキャッチするようにします。</p>

<p>```
@isTest
private class Test_SampleLeadTrigger {</p>

<pre><code>static testMethod void excute(){
    Lead test_obj = new Lead();
    test_obj.Company = 'hoge co.';
    test_obj.LastName = 'test';

    try{
        insert test_obj;
    }catch(Exception e){

    }
}
</code></pre>

<p>}
```</p>

<p>これでエラーで止まらなくなるので実行は出来るようになります。<br/>
catchの部分は今回で言えば、<code>DmlException</code>なので、それでもよいですが、より広いエラーで、<code>Exception</code>にしています。<br/>
この辺はあまり深く追求してません。。</p>

<p>で、これだとテストは通りますが、テストの意味はあまりないと思うので、意図したエラーが返ってくるかを確認するために、以下のように変更します。</p>

<p><code>try-catch</code>部分</p>

<p>```
try{</p>

<pre><code>insert test_obj;
</code></pre>

<p>}catch(Exception e){</p>

<pre><code>Boolean expectedExceptionThrown =  e.getMessage().contains('testという名前は使えません') ? true : false;
System.AssertEquals(expectedExceptionThrown, true);
</code></pre>

<p>}
```</p>

<p>これで指定したエラーが返ってきたかどうかがチェックできます。<br/>
もし指定したエラー以外のものが返ってきた場合は以下のようなエラーが出てテストコードが実行できなくなってしまうので間違いに気付くことが出来ます。</p>

<blockquote><p>System.AssertException: Assertion Failed: Expected: false, Actual: true</p></blockquote>

<p>（<code>e.getMessage()</code>は、 System.DmlException:〜の文言を含んだ内容となるので、<code>contains</code>関数で指定の文字列が<strong>含まれている</strong>かどうかをチェックしている。）</p>

<h3>参考</h3>

<p><a href="https://developer.salesforce.com/forums/ForumsMain?id=906F00000008xGuIAI">How do I test for an exception(&lsquo;addError&rsquo;) in a Trigger ? &ndash; Salesforce Developer Community</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[apex]Date型のフォーマット]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/04/10/format-date/"/>
    <updated>2015-04-10T10:55:07+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/04/10/format-date</id>
    <content type="html"><![CDATA[<p>何回かググっているので、備忘録。</p>

<!-- more -->


<p>Date型のフォーマットは一応用意されているが、フォーマット内容を指定が出来ないよう。</p>

<p><code>
Date d = Date.newInstance(2015, 4, 10);
System.debug(d); //2015-04-10 00:00:00
String d_str = d.format();
System.debug(d_str); //2015/04/10
</code></p>

<p><code>format('yyyy-MM-dd')</code>とか書くと怒られる。<br/>
<a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_methods_system_date.htm#apex_System_Date_format">Date Class &ndash; format()</a></p>

<p>代わりにDatetime型の場合はフォーマットを指定して出力が可能。<br/>
なので、Date型のものをフォーマット指定して出力したい場合は、一度Datetime型に変換してやる必要がある。</p>

<p>apexのDatetime型の扱いには注意が必要で、そのまま変換してDatetime型のまま使用しているとタイムゾーンが標準時になって９時間戻ってしまう。<br/>
ただしそれをフォーマットして文字列にするとまた元に戻る。
指定するならする、しないならしない、で統一しているとややこしくならなくてすみそう。</p>

<p><code>
Date d = Date.newInstance(2015, 4, 10);
System.debug(d);  //2015-04-10 00:00:00
Datetime dt = Datetime.newInstance(d.year(), d.month(), d.day());
System.debug(dt);  //2015-04-09 15:00:00
String dt_str = dt.format('yyyy-MM-dd');
System.debug(dt_str);  //2015-04-10
</code></p>

<h3>参考</h3>

<p><a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_methods_system_date.htm#apex_System_Date_format">Date Class &ndash; format()</a><br/>
<a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_methods_system_datetime.htm#apex_System_Datetime_format_2">Datetime Class &ndash; format(string)</a><br/>
<a href="http://stackoverflow.com/questions/11834873/salesforce-apex-validating-date-for-format-and-value">validation &ndash; Salesforce Apex: Validating date for format and value &ndash; Stack Overflow</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]Apex REST作成時のtips]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/03/27/apex-rest-tips/"/>
    <updated>2015-03-27T19:45:44+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/03/27/apex-rest-tips</id>
    <content type="html"><![CDATA[<p>最近よくApexRESTを作成していて、<br/>
その中でちょっとしたtipsというかメモをメモっておきます。</p>

<!-- more -->


<h2>エンドポイント</h2>

<p>エンドポイントの指定には以下のように書きます。</p>

<pre><code>@RestResource(urlMapping='/User/Login')
</code></pre>

<p>この時に、<code>*</code>を使う事も出来ます。</p>

<pre><code>@RestResource(urlMapping='/User/*')
</code></pre>

<p>なので、ここにユーザーIDを入れたりして、そのIDを取得することで、<br/>
よりREST APIらしい(?)挙動でAPIを作成する事が出来ます。<br/>
apex側で送信されたIDを取得するには、以下のように<code>/</code>で区切って取得します。</p>

<pre><code>String accountId = req.requestURI.substring(req.requestURI.lastIndexOf('/')+1);
</code></pre>

<p>公式のドキュメントに正にこのままの内容が載っていました。</p>

<p><a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_rest_code_sample_basic.htm">Apex REST Basic Code Sample</a></p>

<h2>JSON</h2>

<p>返却するJSONの形式ですが、クラスの入れ子や、<code>List</code>を活用することで<br/>
かなり自由度高く作成出来ます。</p>

<p>例えば、以下のようなJSONを返すとします。</p>

<p>```
&ldquo;success&rdquo;:1,
&ldquo;User&rdquo; : {</p>

<pre><code>"user_id": xxx,
"hobby":[
    {"name":"映画", "level":"3"},
    {"name":"サッカー", "level":"1"}
]
</code></pre>

<p>},
&ldquo;request_time&rdquo;: &ldquo;2015-3-27 12:33&rdquo;
```</p>

<p>この場合、以下のようにクラスを複数作り、入れ子構造を作る事で作成出来ます。</p>

<p>```
global class UserData{</p>

<pre><code>global String user_id;
global HobbyData hobby
</code></pre>

<p>}
global class HobbyData{</p>

<pre><code>global String name;
global String level;
</code></pre>

<p>}
global class resultData{</p>

<pre><code>global Integer success;
global UserData User;
global String request_time;
</code></pre>

<p>}
```</p>

<p>作成するときは以下のような感じで。</p>

<p>```
List<HobbyData> hobbies = new List<HobbyData>();
HobbyData hobby1 = new HobbyData();
hobby1.name = &lsquo;映画&rsquo;;
hobby1.level = &lsquo;3&rsquo;;
hobbies.add(hobby1);
HobbyData hobby2 = new HobbyData();
hobby2.name = &lsquo;サッカー&rsquo;;
hobby2.level = &lsquo;1&rsquo;;
hobbies.add(hobby2);</p>

<p>UserData user = new UserData();
user.user_id = &lsquo;xxx&rsquo;;
user.hobby = hobbies;</p>

<p>resultData result = new resultData();
result.success = 1;
result.User = user;
result.request_time = &lsquo;2015-3-27 12:33&rsquo;;</p>

<p>return result;
```</p>

<p>地道な作業にはなりますが、これでわりかし綺麗なJSONが返せました。<br/>
もっと簡単な方法があったらまた書きます。</p>
]]></content>
  </entry>
  
</feed>
