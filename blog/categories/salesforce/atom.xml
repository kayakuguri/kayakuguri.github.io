<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: salesforce | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/salesforce/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2014-02-26T18:11:21+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ApexからコールアウトでPOST送信する]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/02/26/submit-callout-with-multipart/"/>
    <updated>2014-02-26T17:25:51+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/02/26/submit-callout-with-multipart</id>
    <content type="html"><![CDATA[<p>apexクラスからコールアウトを使って外部APIにPOST送信してみた。<br/>
ファイルも一緒に送信する。</p>

<!-- more -->


<h2>基本的なPOST送信の方法</h2>

<p>コールアウトで外部にHTTP送信する場合、<br/>
ヘッダーやボディの中身を順番に設定していき、送信、となる。<br/>
(この基本的な内容がわかっていなくて苦労した)</p>

<p>POSTやGETで送信されるデータの基本的な内容は以下。<br/>
<a href="http://www.yoheim.net/blog.php?q=20120611">[Web] HTTPリクエストの中身を学んでみた。GETやPOSTの違いなど</a></p>

<p>送信内容例はこんな感じ。(上記サイト内から引用)</p>

<pre><code>POST /www.hoge.com/test.php HTTP/1.1
Host: localhost:8080
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.54 Safari/536.5
Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
Accept-Language: ja,en-us;q=0.7,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: Shift_JIS,utf-8;q=0.7,*;q=0.7
Keep-Alive: 300
Connection: keep-alive
Content-Type: text/plain
Content-Length: 23

key1=value1&amp;key2=value2
</code></pre>

<p>apexからの基本的なPOST送信の方法は以下。<br/>
<a href="http://ameblo.jp/hayapu/entry-11431469756.html">[Salesforce][Force.com]外部サイトにHTTPアクセス（Callout）する</a><br/>
(上記サイトから引用、編集)</p>

<pre><code>HttpRequest request = new HttpRequest();
request.setEndpoint('http://****アクセスしたいAPIのURLだよ！****');
request.setMethod('POSTとかGETとか！');
request.setHeader('Accept','text/plain, */*');
request.setHeader('Accept-Charset','Shift_JIS,utf-8;q=0.7,*;q=0.3');
request.setHeader('Accept-Encoding','gzip,deflate,sdch');
request.setHeader('Accept-Language','ja,en-US;q=0.8,en;q=0.6');
request.setHeader('Connection','keep-alive');
request.setHeader('Content-Type','text/xml; charset=UTF-8 ');
String prams = 'key1=value1&amp;key2=value2';
request.setBody(prams);

Http http = new Http();
HttpResponse response = http.send(request);
String responseBody = response..getBody();
</code></pre>

<p>最初に上げた送信内容のボディ部分に、getパラメータのようにつなげて書かれている。<br/>
なので、そのようにボディ部分に書いてやればいい。<br/>
<a href="http://www.kokyakukanri.info/salesforce/blog/2010/12/apexpost.html">[Apex]WebコールアウトでPOST送信する場合のパラメータの設定方法は？</a></p>

<p>注意点としては、コールアウトするURLは事前にドメインを指定しておく必要があるよう。<br/>
指定してないと、<code>Unauthorized endpoint, please check Setup-&gt;Security-&gt;Remote site settings.</code>とエラーが出る。</p>

<pre><code>設定 -&gt; セキュリティのコントロール -&gt; リモートサイトの設定
</code></pre>

<p>さらに、接続するURLはSSLでないとエラーが返されてしまう。<br/>
<code>The requested URL could not be retrieved</code></p>

<p>ちなみに、配列で送信する場合は以下。</p>

<pre><code>params = 'hoge[]=huga&amp;hoge[]=fuge';
request.setBody(params);
</code></pre>

<h2>POSTでファイルを送信する</h2>

<p>参考：<a href="http://salesforceafondo.wordpress.com/2013/01/08/post-multipartform-data-out-of-salesforce-com-with-apex/">Post ‘multipart/form-data’ out of Salesforce.com with APEX</a><br/>
スペイン語なので読めないけど、コード部分は読める。</p>

<p>そのまま送信すると、送信先のPHP側で、<code>$_FILES</code>にデータが入っていた。</p>

<p>この方法で、ファイルと一緒にパラメータも送信するには、<br/>
POST送信する際のボディ内容を再現すればいいよう。</p>

<p><a href="http://d.hatena.ne.jp/satox/20110726/1311665904">いまさら聞けないHTTPマルチパートフォームデータ送信</a><br/>
(上記内容から引用)</p>

<pre><code>POST test.php HTTP/1.1\r\n
Host: satoxpochi.com\r\n
Content-Type: multipart/form-data; boundary=---------------------------102852708831426\r\n
Content-Length: 「ボディ部のサイズ」\r\n
\r\n
-----------------------------102852708831426\r\n
Content-Disposition: form-data; name="password"\r\n
\r\n
ponpoko\r\n
-----------------------------102852708831426\r\n
Content-Disposition: form-data; name="level"\r\n
\r\n
high\r\n
-----------------------------102852708831426\r\n
Content-Disposition: form-data; name="filename"; filename="text.txt"\r\n
Content-Type: application/octet-stream\r\n
Content-Transfer-Encoding: binary\r\n
\r\n
abcd
-----------------------------102852708831426--\r\n
</code></pre>

<p>このように、送りたい情報分だけ区切り線でつないでいけばいい。<br/>
(１つのパラメータで区切り１つ分！)</p>

<p>また、visualforceのinputでfileを送信するには以下のようにする。</p>

<pre><code>[apexクラス]
public String FileName { get; set; }
public Blob FileBody { get; set; }

[visualforceページ]
&lt;apex:inputFile value="{!FileBody}" filename="{!FileName}"/&gt;
</code></pre>

<p>これで、<code>FileName</code>にファイル名、<code>FileBody</code>にファイルが入る。</p>

<p>これらを踏まえて、最終的な送信部分のソースは以下。<br/>
POSTでデータとファイルをコールアウトで送信する。</p>

<p>[Visualforceページ]</p>

<pre><code>メールアドレス1:&lt;apex:input value="{!Email1}" /&gt;&lt;br /&gt;
メールアドレス2:&lt;apex:input value="{!Email2}" /&gt;&lt;br /&gt;
&lt;br /&gt;
添付ファイル : &lt;apex:inputFile value="{!FileBody}" filename="{!FileName}"/&gt;
</code></pre>

<p>[apexクラス]</p>

<pre><code>HttpRequest request = new HttpRequest();
request.setEndpoint('https://送信先アドレス.php');
request.setMethod('POST');
request.setHeader('Accept-Language', 'ja');

String boundary = String.valueOf(DateTime.now().getTime());
String body = '';
body+='------------' + boundary + '\r\n';
body+='Content-Disposition: form-data; name="to[]"\r\n';
body+='\r\n';
body+=Email1 + '\r\n';
body+='------------' + boundary + '\r\n';
body+='Content-Disposition: form-data; name="to[]"\r\n';
body+='\r\n';
body+=Email2 + '\r\n';
body+='------------' + boundary + '\r\n';
body+='Content-Disposition: form-data; name="data"; filename="' + FileName + '"\r\n';
body+='Content-Transfer-Encoding: base64\r\n';
String contentType = 'application/octet-stream';
body+='Content-Type: ' + contentType + '\r\n\r\n';
body+=EncodingUtil.base64Encode(FileBody);
body+='\r\n------------' + boundary + '--';
request.setHeader('Content-Type', 'multipart/form-data; boundary=----------' + boundary);
request.setHeader('Content-Length',String.valueof(body.length()));
request.setBody(body);

Http http = new Http();
HttpResponse response = http.send(request);
ResResult = response.getBody();
</code></pre>

<p>送信先のPHPでの受信内容は以下。</p>

<pre><code>($_POST)
array(1) { 
    ["to"]=&gt; array(2) { 
        [0]=&gt; string(14) "mail1@hoge.com" 
        [1]=&gt; string(14) "mail2@huga.com"
    }
}

($_FILES)
array(1) { 
    ["data"]=&gt; array(5) { 
        ["name"]=&gt; string(8) "img.jpg" 
        ["type"]=&gt; string(24) "application/octet-stream" 
        ["tmp_name"]=&gt; string(14) "/tmp/phpcEwVr6" 
        ["error"]=&gt; int(0) 
        ["size"]=&gt; int(309276) 
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Forceでの送信ボタン2度押し防止策]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/02/12/vf-doubleclick-check/"/>
    <updated>2014-02-12T19:47:53+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/02/12/vf-doubleclick-check</id>
    <content type="html"><![CDATA[<p>salesforceでvisualforceの<code>commandButton</code>で、ボタンを連打すると、<br/>
送信が完了してページが遷移するまでに何度でもデータが送信されてしまう。</p>

<p>単純に、apexクラス内で２度目はinsertしない、とかにしてればいいのだけど、<br/>
それをvisualforceで完結させることが出来たので、メモ。</p>

<!-- more -->


<p><code>apex:commandButton</code>内で、<code>onclick</code>を使って、JSを呼んで、<br/>
１度目だと<code>true</code>、2度目だと<code>false</code>を返すようにする。<br/>
<code>true</code>が返って来た時だけ、<code>action</code>内の関数が実行される。</p>

<pre><code>//JS
&lt;script type="text/javascript"&gt;
var isSave = false;
function check(){
    if (!isSave) {
        isSave = true;
        return true;
    }
    return false;
}
&lt;/script&gt;

//HTML
&lt;apex:commandButton action="{!save}" onclick="return check();" image="{!URLFOR($Resource.remind, 'images/btn_send.gif')}" alt="OK" /&gt;
</code></pre>

<p>これで、連打しても大丈夫。</p>

<p>参考：<a href="http://blog.livedoor.jp/volvic_beer/archives/52301425.html">http://blog.livedoor.jp/volvic_beer/archives/52301425.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visualforceページでカスタムコントローラーを指定する]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/02/06/apex-page/"/>
    <updated>2014-02-06T13:00:31+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/02/06/apex-page</id>
    <content type="html"><![CDATA[<p>タイトルの通りだけのメモ。</p>

<!-- more -->


<p>visualforceのページ内の冒頭、<code>&lt;apex:page&gt;</code>内で、<br/>
<code>extensions="RemindController"</code>という風に指定する。</p>

<pre><code>&lt;apex:page standardController="Lead" extensions="CustomController" &gt;
</code></pre>

<p>この指定をしておくことで、<code>action</code>内で参照する関数は、指定したクラス内から呼び出されるようになる。</p>

<p>また、VisualForce内の冒頭、<code>apex:page</code>タグ内で、<code>action</code>を指定して、そこで関数を実行するようにする。<br/>
すると、ページアクセス時にまず呼び出されるようになる。</p>

<p>[VisualForce]</p>

<pre><code>&lt;apex:page standardController="Lead" action="{!checkKey}" &gt;
</code></pre>

<p>[apexクラス]</p>

<pre><code>public Pagereference checkKey(){
    if(/*処理*/){
        reutrn Page.xx;
    }else{
        return null;
    }
}
</code></pre>

<p>参考：<a href="http://www.kokyakukanri.info/salesforce/blog/2010/11/urlkey.html">ページを開いた段階でURLに含まれるKeyなどが不足している場合に、 別ページに遷移させる方法。</a></p>

<p>注意点としては、エラーページに遷移しなくていい場合には、<br/>
自身のページを指定してしまうと、無限ループに入って、内部サーバーエラー、となってしまう。<br/>
なので、遷移しなくていい場合は、<code>null</code>を返しておくと大丈夫なよう。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Force.comのREST APIを使ってデータをインサートする]]></title>
    <link href="http://kayakuguri.github.io/blog/2013/12/05/sf-rest-api/"/>
    <updated>2013-12-05T13:13:07+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2013/12/05/sf-rest-api</id>
    <content type="html"><![CDATA[<p>参考ページ：<br/>
<a href="http://www.nkjmkzk.net/?p=2328">新しくなったForce.com OAuth Toolkit for phpの使い方</a><br/>
<a href="https://help.salesforce.com/apex/HTViewHelpDoc?id=remoteaccess_oauth_web_server_flow.htm&amp;language=ja">OAuth 2.0 Web サーバ認証フロー</a></p>

<p>接続するためには、facebookなどと同じように、sf側でアプリを作成しなければならない。<br/>
そのアプリが、アクセストークンを発行する形。<br/>
そのアプリは、以前までは、<code>リモートアクセス</code>と呼ばれるものだったけど、仕様変更で、<br/>
<code>接続アプリケーション</code>に、変わったよう。</p>

<!-- more -->


<p>リダイレクトのURLはhttpsでないとダメ。</p>

<p>不特定多数からの接続を受け付ける場合は、<br/>
<code>$oauth-&gt;auth_with_code();</code>ではなくて、<code>$oauth-&gt;auth_with_password(USERNAME, PASSWORD);</code>を使わないといけない。</p>

<p>さらに、不特定の外部からアクセスする場合にはパスワードにセキュリティトークンをつけないといけない。<br/>
<a href="http://vaindespair.blogspot.jp/search?q=rest">Force.com　：　REST API 開発　ユーザ名パスワード OAuth 認証</a></p>

<ul>
<li> 不特定多数からのアクセスを受け付ける場合(たいていこっち)は、パスワード＋セキュリティトークンで認証が必要</li>
<li> 特定のIPからの接続だけ、の場合は、IPを指定することでセキュリティトークンなしで認証が出来る。</li>
</ul>


<h4>インサートのサンプル</h4>

<p><a href="http://developer.force.com/cookbook/recipe/interact-with-the-forcecom-rest-api-from-php">Interact with the Force.com REST API from PHP</a></p>

<p>リードにインサートしようとしたところ、バージョンが20では無理だった。<br/>
バージョンを24にしたらいけた。</p>

<pre><code>$instance_url/services/data/v24.0/sobjects/Lead/
</code></pre>

<p>チェックボック型のデータは、boolean型。なので、true/falseで入れる。<br/>
日付型は、yyyy-mm-dd、とハイフンを入れる。<br/>
<a href="http://d.hatena.ne.jp/mizolog/20110620/1308552542">セールスフォースのデータローダで日付型を使う場合の注意</a></p>

<p>Leadでは<code>Company</code>は必須項目。</p>

<p>複数選択のチェックボックスを送信する場合、配列、にするのではなく、<code>;</code>区切りの文字列にして渡す。</p>

<pre><code>{"where_you_use__c":"work;other;home"}
</code></pre>
]]></content>
  </entry>
  
</feed>
