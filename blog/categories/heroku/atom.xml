<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: heroku | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/heroku/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2015-08-06T18:39:12+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[heroku]PHPのセッションをherokuのRedisで管理する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/08/06/session-storage-in-redis-on-heroku/"/>
    <updated>2015-08-06T18:06:13+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/08/06/session-storage-in-redis-on-heroku</id>
    <content type="html"><![CDATA[<p>heroku上でのPHPのセッション管理の定番は<a href="https://addons.heroku.com/memcachier">MemCachier</a>だけれど、<br/>
今回はHerokuのRedisに保存さえてみた。</p>

<h2>Redis</h2>

<p>herokuで使えるRedis、といってもいくつか種類がある。<br/>
それぞれどう違うのか、とか、設定方法の違い、とかは正直わからない。</p>

<p><a href="http://qiita.com/Oakbow/items/98599da0fc62863fc1b8#%E3%81%A9%E3%81%AE-redis-%E3%81%AE%E3%82%A2%E3%83%89%E3%82%AA%E3%83%B3%E3%82%92%E4%BD%BF%E3%81%86">herokuでセッションの保存先をRedisにする &ndash; Qiita</a></p>

<blockquote><p>現在、heroku には4つの Redis のアドオンがあります。<br/>
早晩5つめが増えるようです。</p></blockquote>

<p>この5つめ、にあたるものが今回使用する、Heroku Redis、です。　　
これは他のredisと違って、<a href="https://elements.heroku.com/addons/heroku-postgresql">Postgres</a>と同じくheroku内部のものなのでまぁ間違いないのかも、ってことで使ってみました。</p>

<p><a href="https://elements.heroku.com/addons/heroku-redis">Heroku Redis</a></p>

<h2>インストール</h2>

<p>公式の通り、インストールコマンドは以下。<br/>
アプリページからポチポチっと入れても問題なし。</p>

<pre><code>$ eroku addons:create heroku-redis:hobby-dev -a YOUR-APP-NAME
</code></pre>

<p><code>hobby-dev</code>は無料バージョン。</p>

<h2>セットアップ</h2>

<p>必要なソースはComposerで入れる。</p>

<p>(公式より)</p>

<p><code>
"require": {
  ...
  "predis/predis": "1.0.1",
  ...
}
</code></p>

<h2>接続先をredisに</h2>

<p>以下のページを参考、というかほぼそのままで。<br/>
<a href="http://www.sitepoint.com/saving-php-sessions-in-redis/">PHP Master | Saving PHP Sessions in Redis</a></p>

<p>まずは、接続用のクラスを用意。</p>

<p>```
&lt;?php
class RedisSessionHandler implements SessionHandlerInterface
{</p>

<pre><code>public $ttl = 1800; // 30 minutes default
protected $db;
protected $prefix;

public function __construct(PredisClient $db, $prefix = 'PHPSESSID:') {
    $this-&gt;db = $db;
    $this-&gt;prefix = $prefix;
}

public function open($savePath, $sessionName) {
    // No action necessary because connection is injected
    // in constructor and arguments are not applicable.
}

public function close() {
    $this-&gt;db = null;
    unset($this-&gt;db);
}

public function read($id) {
    $id = $this-&gt;prefix . $id;
    $sessData = $this-&gt;db-&gt;get($id);
    $this-&gt;db-&gt;expire($id, $this-&gt;ttl);
    return $sessData;
}

public function write($id, $data) {
    $id = $this-&gt;prefix . $id;
    $this-&gt;db-&gt;set($id, $data);
    $this-&gt;db-&gt;expire($id, $this-&gt;ttl);
}

public function destroy($id) {
    $this-&gt;db-&gt;del($this-&gt;prefix . $id);
}

public function gc($maxLifetime) {
    // no action necessary because using EXPIRE
}
</code></pre>

<p>}
```</p>

<p>で、最初に保存先を変更するページにて以下を実行する。</p>

<p>```
&lt;?php
require_once( dirname(<strong>FILE</strong>). &ldquo;/vendor/autoload.php&rdquo; );
require_once( dirname(<strong>FILE</strong>). &ldquo;/RedisSessionHandler.php&rdquo; );</p>

<p>$redis = new Predis\Client([</p>

<pre><code>'host' =&gt; parse_url($_ENV['REDIS_URL'], PHP_URL_HOST),
'port' =&gt; parse_url($_ENV['REDIS_URL'], PHP_URL_PORT),
'password' =&gt; parse_url($_ENV['REDIS_URL'], PHP_URL_PASS),
</code></pre>

<p>]);
$sessHandler = new RedisSessionHandler($redis);
session_set_save_handler($sessHandler);
session_start();
```</p>

<p>2行目はredisのライブラリを読み込むための設定。<br/>
3行目は先程作成したクラス。<br/>
で、5行目でnewしているが、ここが参考サイトから少し変えていて、Heroku Redis公式の方に合わせている。<br/>
で、後は参考サイト通りに。</p>

<p>これで後は普通にセッションを使えばRedisに保存されるようになる。</p>

<h2>参考</h2>

<p><a href="https://devcenter.heroku.com/articles/heroku-redis#connecting-in-php">Heroku Redis | Heroku Dev Center</a><br/>
<a href="http://www.sitepoint.com/saving-php-sessions-in-redis/">PHP Master | Saving PHP Sessions in Redis</a><br/>
<a href="http://qiita.com/Oakbow/items/98599da0fc62863fc1b8#%E3%81%A9%E3%81%AE-redis-%E3%81%AE%E3%82%A2%E3%83%89%E3%82%AA%E3%83%B3%E3%82%92%E4%BD%BF%E3%81%86">herokuでセッションの保存先をRedisにする &ndash; Qiita</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wordpress上のメディアをcloudinaryに自動アップロードして管理する]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/06/30/auto-upload-cloudinary-on-heroku/"/>
    <updated>2015-06-30T12:54:33+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/06/30/auto-upload-cloudinary-on-heroku</id>
    <content type="html"><![CDATA[<p>herokuでwordpressを使用した場合、通常ではアップロードした画像は<br/>
heorkuの再起動のタイミングで全て消えてしまいます。</p>

<!-- more -->


<p>なので、そうならないようにクラウド上のストレージサービスである、cloudinaryに保存させたりします。<br/>
cloudinaryには公式でwordpressのプラグインが用意されています。<br/>
<a href="https://ja.wordpress.org/plugins/cloudinary-image-management-and-manipulation-in-the-cloud-cdn/">WordPress &#8250; Cloudinary &ndash; Image management and manipulation in the cloud + CDN &laquo; WordPress Plugins</a></p>

<p>これを利用することでwordpress上の画像をcloudinaryで管理できるようになるのですが、<br/>
アップロードした画像を手動でcloudinaryに反映させてやらねばなりません。<br/>
それをなんとか自動でアップされるようにしてみました。</p>

<h2>cloudinaryへのアップロード手順(通常)</h2>

<p>通常と同じようにメディアライブラリ上から画像をアップロードします。<br/>
一覧表示で、詳細まで表示される、テーブル表示に切り替えます。<br/>
この時の右端に、<code>Upload to Cloudinary</code>というリンクがあるのでそれをクリックします。</p>

<p><img src="/images/2015/06/cloudinary_heroku01.jpg" alt="" /></p>

<p>するとアップロードされ、表記がアップロード済に変わります。</p>

<p><img src="/images/2015/06/cloudinary_heroku02.jpg" alt="" /></p>

<p>この時に内部では何をしているかと言うと、<br/>
cloudinaryにアップロードし、アップ先のURLを使ってメタデータを書き換え、<br/>
cloudinaryへアップした、というフラグを立てています。<br/>
このフラグを立てているところがポイントになります。</p>

<h2>メタデータ</h2>

<p>wordpressでは画像は投稿データとして管理されています。<br/>
データ構造は以下が詳しいのですが、画像部分だけを引用させてもらうとこんな感じです。<br/>
<a href="http://hijiriworld.com/web/wp-data-register/">WordPress データ登録機構を知ってもっと自由で効率的なフローを  |  hijiriworld Web</a></p>

<p><code>wp_posts</code>テーブル</p>

<table>
<thead>
<tr>
<th>post_title </th>
<th> post_status </th>
<th> post_name </th>
<th> guid </th>
<th> post_type </th>
<th> post_mine_type</th>
</tr>
</thead>
<tbody>
<tr>
<td>{$file_name} </td>
<td> inherit </td>
<td> {$file_name} </td>
<td> {$guid} </td>
<td> attachment </td>
<td> {$mine_type}</td>
</tr>
</tbody>
</table>


<p><code>wp_postmeta</code>テーブル</p>

<table>
<thead>
<tr>
<th>post_id </th>
<th> meta_key </th>
<th> meta_value</th>
</tr>
</thead>
<tbody>
<tr>
<td>{$attachment_id} </td>
<td> _wp_attached_file </td>
<td> {$file_name}</td>
</tr>
<tr>
<td>{$attachment_id} </td>
<td> _wp_attachment_metadata </td>
<td> シリアライズされたメタデータ</td>
</tr>
</tbody>
</table>


<p>wp_postsの方は特に変更する必要はありません。<br/>
重要なのはwp_postmetaのメタデータの方です。</p>

<p>今回、変更する具体的な箇所は以下の２箇所です。<br/>
<code>_wp_attached_file</code>をファイル名からcloudinaryのURLへ変更。<br/>
<code>_wp_attachment_metadata</code>の中にcloudinaryフラグを立てる。</p>

<h2>メディア管理とプラグインの仕組み</h2>

<p>wordpressのメディアは都度URLを動的に生成しています。<br/>
メイン画像の場合は以下。</p>

<blockquote><p>ブログのパス + <code>_wp_attached_file</code>の$file_name</p></blockquote>

<p>サムネイルの場合は以下。</p>

<blockquote><p>ブログのパス + <code>_wp_attachment_metadata</code>の指定サイズのファイル名</p></blockquote>

<p>なのでファイル名にcloudinaryの絶対パスを入れてしまうとURLが２重になってしまいます。</p>

<p>で。<br/>
これが、cloudinaryのフラグが立っているものに関しては、cloudinaryのプラグイン側でURLをうまい具合に置き換えて表示してくれます。<br/>
なので、こちらとしてはフラグを立てるだけ、で大丈夫。</p>

<h2>実作業</h2>

<p>処理の流れは以下のように。</p>

<ol>
<li>画像をアップロード</li>
<li>メタデータ作成のフック内で画像URLを取得</li>
<li>取得したURLでcloudinaryにアップロード</li>
<li>cloudinaryのURLでDBのファイル名を更新</li>
<li>メタデータにフラグを立てる</li>
</ol>


<p><code>wp_generate_attachment_metadata</code>で、アップされたファイルのメタデータを作成する処理にフックをかけられるのでそれを使用します。</p>

<p>functions.phpに以下を記述。</p>

<p>```
function cldnry_wp_generate_attachment_metadata($metadata, $postid){</p>

<pre><code>$imgPath = get_attached_file( $postid );

//ファイル形式のチェック
$info = pathinfo($imgPath);
$public_id = $info["filename"];
$mime_types = array("png"=&gt;"image/png", "jpg"=&gt;"image/jpeg", "pdf"=&gt;"application/pdf", "gif"=&gt;"image/gif", "bmp"=&gt;"image/bmp");
$extension = $info["extension"];
$type = @$mime_types[$extension];
//画像以外はcloudinaryにアップしない
if($type === null){
    $stderr = fopen( 'php://stderr', 'w' );
    fwrite( $stderr, 'アップロードされたファイルが画像ではありません。file-type:'.$extension );
    return $metadata;
}

//Cloudinaryへアップ
$cl_upload = new CloudinaryUploader();
$uploaded = $cl_upload-&gt;upload($imgPath, array(
    "public_id" =&gt; $public_id,
));
$public_id = $uploaded['public_id'];

//DBへ保存
update_attached_file($postid, $uploaded['secure_url']);
$metadata['cloudinary'] = true; //cloudinaryからアップしたことを記録

return $metadata;
</code></pre>

<p>}
add_filter( &ldquo;wp_generate_attachment_metadata&rdquo; , &ldquo;cldnry_wp_generate_attachment_metadata&rdquo;,10 ,2 );
```</p>

<p>まず、<code>get_attached_file( $postid )</code>でアップされたファイルのURLを取得。<br/>
そのファイルが画像かどうかを一応チェックしている。<br/>
で、cloudinaryへアップロード。<br/>
cloudinaryはプラグインのファイルから利用するので公式で解説されているコードとは少し異なります。<br/>
で、アップされたらURLをファイル名として保存。<br/>
最後にポイントとなる、フラグを立てて終了。</p>

<p>これだけであとの表示周りの処理はcloudinaryがやってくれます。</p>

<h2>結果</h2>

<p>通常と同じように画像をアップすると、アップ完了時点でcloudinaryへ保存されます。<br/>
以下のようにURLがcloudinaryになっている事が確認できるかと思います。</p>

<p><img src="/images/2015/06/cloudinary_heroku03.jpg" alt="" /></p>

<p>一覧でテーブル表示にすると、cloudinaryにはすでにアップロード済の表記となっています。</p>

<h2>まとめ</h2>

<p>herokuでwordpressを扱う場合、この画像問題がネックの一つとなっているのですが、<br/>
herokuにはcloudinaryのアドオンがあるので、これでとりあえずは解消したのではないでしょうか。<br/>
この解消は自分の中ではかなり大きいです。</p>

<p>使用の際の注意点としては、wordpress上でデータを削除してもcloudinary上からは削除されない、という点です。<br/>
cloudinaryのアップロード容量が決まっているため、メンテナンスが必要かもしれません。</p>

<p>あとはアップデートの問題が解決すればすっきり出来るのですが。。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[heroku]exif情報を扱う]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/05/29/heroku-exif/"/>
    <updated>2015-05-29T12:26:34+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/05/29/heroku-exif</id>
    <content type="html"><![CDATA[<p>heorkuで画像アップロード機能をつけた際、画像かを判定するのに、exif情報を利用したところ、エラーが出た。</p>

<!-- more -->


<p><code>exif_imagetype</code>を利用して画像かを判定していたのだけど、<br/>
以下のように、そんな関数ないよ、と怒られた。</p>

<blockquote><p>Fatal error: Call to undefined function exif_imagetype() i</p></blockquote>

<p>調べてみると、herokuは標準ではexif情報を扱うためのPHPモジュールが入っていないよう。<br/>
composerを使えばインストール出来る、とのことなので以下のように記述し再度deploy。<br/>
これで解決出来た。</p>

<p>```
{</p>

<pre><code>"require": {
    "ext-exif":"*"
}
</code></pre>

<p>}
```</p>

<h2>参考</h2>

<p><a href="http://stackoverflow.com/questions/16224488/how-to-get-the-exif-php-extension-working-on-heroku">How to get the EXIF PHP extension working on Heroku? &ndash; Stack Overflow</a><br/>
<a href="https://devcenter.heroku.com/articles/php-support#extensions">Extensions | Heroku PHP Support | Heroku Dev Center</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[wordpressをherokuにインストールする場合はルーティングのhtaccessを自分で設置すること]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/05/22/heroku-wp-htaccess/"/>
    <updated>2015-05-22T16:11:35+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/05/22/heroku-wp-htaccess</id>
    <content type="html"><![CDATA[<p>タイトルママ。<br/>
ちょっとハマったのでメモ。</p>

<!-- more -->


<h2>WordPressのインストール</h2>

<p>以下の手順で通常通りwordpressをインストールした。</p>

<ol>
<li>herokuにインストール用のアプリを作成</li>
<li>gitでローカルにclone</li>
<li>2のディレクトリ内に<a href="https://ja.wordpress.org/">Wordpress日本語版</a>をダウンロードして展開</li>
<li>herokuのアプリにmySQLのアドオン、<a href="https://addons.heroku.com/cleardb">ClearDB</a>を入れる</li>
<li>環境変数から、DBの接続情報を確認。<br/>
<code>mysql://ユーザ名:パスワード@サーバ名/データベース?reconnect=true</code></li>
<li>wp-config.phpにDB情報を反映</li>
<li>PushしてDploy</li>
<li>wp-admin/install.phpにアクセスして、サイト名やユーザー名などを設定してインストール。</li>
<li>完了</li>
</ol>


<h2>固定ページにアクセス</h2>

<p>通常の投稿でもたぶん同じ事が起こると思うが、<br/>
最初から入っているサンプルの固定ページにアクセス。</p>

<blockquote><p><a href="http://YOUR-APP-NAME.herokuapp.com/sample-page/">http://YOUR-APP-NAME.herokuapp.com/sample-page/</a></p></blockquote>

<p>アクセスを確認してから、特にソースは触らずに<a href="http://kayakuguri.github.io/blog/2015/04/21/git-allow-empty/">空でdeploy</a>。</p>

<p>再度上記の固定ページにアクセスすると、<strong>404 Notfound</strong>。</p>

<h2>ルーティング</h2>

<p>ローカルに入れていたWordPressのディレクトとファイルを見比べていると、<br/>
ローカルのものはドキュメントルートに<code>.htaccess</code>がある。</p>

<p>中身を見ていると、リダイレクトしているよう。</p>

<p>どうやら、wordpressのインストール時に、wordpressのルートにルーティング用の<code>.htaccess</code>を自動で作成するよう。<br/>
それがdeployのタイミングで消えてしまい、リダイレクトがかからず、404となっていた。</p>

<p><code>.htaccess</code>の中身は以下。</p>

<p>```</p>

<h1>BEGIN WordPress</h1>

<p><IfModule mod_rewrite.c>
RewriteEngine On
RewriteBase /
RewriteRule ^index.php$ &ndash; [L]
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . /index.php [L]
</IfModule></p>

<h1>END WordPress</h1>

<p>```</p>

<p>これを<code>.htaccess</code>の名前でwordpressのルートに保存してやり、git管理下においてやればよい。</p>

<p>これを置いた状態であれば、deployかけても問題なくアクセスが出来た。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[herokuアドオン]cloudinaryでの画像制限設定について]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/05/11/cloudinary-security/"/>
    <updated>2015-05-11T12:07:56+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/05/11/cloudinary-security</id>
    <content type="html"><![CDATA[<p>cloudinaryを利用した時に他者に乱用されたりしないのかどうかを調べてみた。</p>

<!-- more -->


<h2>画像のURL</h2>

<p>アップロードする際に、画像名となる<code>public_url</code>を指定しなければランダムで文字列がふられる。</p>

<p><strong>デフォルトでのアップロードの例</strong></p>

<blockquote><p><a href="https://res.cloudinary.com/harslxcej/image/upload/xa9kfgp9jvxouekmrrqu">https://res.cloudinary.com/harslxcej/image/upload/xa9kfgp9jvxouekmrrqu</a></p></blockquote>

<p><code>harslxcej</code>はcloudinaryアカウトごとの名前。<code>cloud_name</code>と呼ばれるもの。<br/>
<a href="http://cloudinary.com/documentation/api_and_access_identifiers#cloud_name">Cloud Name | API, URLs and access identifiers | Cloudinary</a></p>

<p>これだけでも推測は不可能だが、さらにprivateモードを利用することでさらに複雑にすることが可能。</p>

<p>PHPでのアップロード時のオプション</p>

<p>```
\Cloudinary\Uploader::upload(&ldquo;your-img&rdquo;,array(</p>

<pre><code>"type" =&gt; "private"
</code></pre>

<p>));
```</p>

<p>表示時のオプション</p>

<p>```
$private = cl_image_tag($public_id . &ldquo;.jpg&rdquo;, array(</p>

<pre><code>"type"=&gt;"private"
</code></pre>

<p>));
```</p>

<p>表示URL</p>

<blockquote><p><a href="http://res.cloudinary.com/harslxcej/image/private/leyxq6ys2wielv6b8yki">http://res.cloudinary.com/harslxcej/image/private/leyxq6ys2wielv6b8yki</a></p></blockquote>

<p>しかしこのままではアクセスが出来ない。<br/>
このURLでのアクセスを許可してやる必要がある。</p>

<h3>編集セットの個別許可</h3>

<p>Cloudinaryの管理画面から、<code>Transformations</code>を選択。<br/>
ここに、いままでアクセスしたことがある編集設定などがずらずらと並んでいるので、その中から探し出すか、新たに設定を作成してやる。</p>

<p><img src="/images/2015/05/cloudinary_security04.jpg" alt="Create new" /></p>

<p>編集設定を作る</p>

<p><img src="/images/2015/05/cloudinary_security05.jpg" alt="Create new" /></p>

<p>で、許可したい編集セットの<code>Disallowed</code>となっているマーク部分をクリックすると、<code>Allowed</code>の緑アイコンに代わり、アクセスが許可される。<br/>
(編集なしの生データにアクセスを許可してやるには、<code>Create a new transformaton..</code>で何もせずにそのまま保存してやればよい。)</p>

<p><img src="/images/2015/05/cloudinary_security03.jpg" alt="allowed" /></p>

<h3>sign_url</h3>

<p>最初は<code>sign_url</code>をつけないとプライベートのものはアクセス出来ないと思っていたが、上記の方法で解消できた。<br/>
以下でもアクセスは出来るが、プライベートタイプのものを表示する方法、という用途ではないと思われる。</p>

<p><code>"sign_url"=&gt;true</code>をつけると固定のURLとなるので、編集が不可能になるが、表示が許可されるようになる。</p>

<p>```
$private = cl_image_tag($public_id . &ldquo;.jpg&rdquo;, array(</p>

<pre><code>"type"=&gt;"private",
"sign_url"=&gt;true
</code></pre>

<p>));
```</p>

<p>表示URL</p>

<blockquote><p><a href="https://res.cloudinary.com/harslxcej/image/private/s--q7MlJXLg--/leyxq6ys2wielv6b8yki.jpg">https://res.cloudinary.com/harslxcej/image/private/s--q7MlJXLg--/leyxq6ys2wielv6b8yki.jpg</a></p></blockquote>

<h3>直リンクは可能</h3>

<p>ただし、URLさえわかってしまえば、表示することは可能。<br/>
また、いわゆる別サーバーからの直リンク、も制限は出来ない。</p>

<h2>編集の制限</h2>

<p>cloudinaryはURLから直接画像や動画を編集する事が出来る。<br/>
例えば以下のような指定。</p>

<pre><code>https://res.cloudinary.com/harslxcej/image/upload/h_100,w_100,c_fill/xa9kfgp9jvxouekmrrqu
</code></pre>

<p>これをプログラムからの指定のみに制限する事が可能。</p>

<p>Cloudinaryの管理画面から、<code>Setting -&gt; Security</code>にアクセス。<br/>
<code>Strict transformations:</code>を<code>Enabled</code>にしてsaveする。<br/>
これで、URLからの直接編集が禁止となる。</p>

<p><img src="/images/2015/05/cloudinary_security01.jpg" alt="Strict transformations" /></p>

<p>２つ下の項目に、<code>Strict video transformations:</code>と動画でも同じく禁止する設定があるので合わせて設定しておくとよいかも。</p>

<p>これで、PHPなどプログラム上からの生成以外は制限することができたが、<br/>
特定のURLからのみはURLでの編集を許可してやることも可能。</p>

<p>上記、<code>Security</code>画面から、<code>Allowed strict referral domains:</code>に許可したいドメインを指定することで設定できる。</p>

<p><img src="/images/2015/05/cloudinary_security02.jpg" alt="Allowed strict referral domains" /></p>

<h2>参考</h2>

<p><a href="http://support.cloudinary.com/hc/en-us/articles/202520342-Does-Cloudinary-support-uploading-private-images-">Does Cloudinary support uploading private images? &ndash; Cloudinary Support</a><br/>
<a href="http://support.cloudinary.com/hc/en-us/articles/202520632--Can-our-users-upload-private-images-which-are-not-accessible-through-a-public-URL-">Can our users upload private images which are not accessible through a public URL? &ndash; Cloudinary Support</a><br/>
<a href="http://cloudinary.com/blog/how_to_quickly_build_a_stock_photo_site_using_cloudinary">How to quickly build a stock photo site using Cloudinary | Cloudinary Blog</a></p>
]]></content>
  </entry>
  
</feed>
