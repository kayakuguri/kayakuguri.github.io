<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: laravel | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/laravel/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-10-27T15:36:17+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Laravel Passportのクライアント認証を試してみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/10/20/laravel-passport-sample/"/>
    <updated>2017-10-20T14:01:59+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/10/20/laravel-passport-sample</id>
    <content type="html"><![CDATA[<p>Laravel Passportを使ってAPIからのアクセスにOAuth認証をかけたい。<br/>
一般に公開するものではなく、特定のクライアントからのアクセスのみを想定する。<br/>
そのため、ユーザデータは使用しない。</p>

<!-- more -->


<h2>インストール</h2>

<p>Laravel Passportをインストール。</p>

<p><code>
$ composer require laravel/passport
</code></p>

<p>Package Auto-Discovery に対応しているため、プロバイダに追加してやる作業は必要ない。</p>

<ul>
<li><a href="https://laravel-news.com/package-auto-discovery">Laravel Package Auto-Discovery &ndash; Laravel News</a></li>
</ul>


<h2>セットアップ</h2>

<p>DBに必要なテーブルを作成する。</p>

<p><code>
$ php artisan migrate
</code></p>

<p>OAuth用に以下のテーブルが作成される。</p>

<ul>
<li><code>oauth_access_tokens</code></li>
<li><code>oauth_auth_codes</code></li>
<li><code>oauth_clients</code></li>
<li><code>oauth_personal_access_clients</code></li>
<li><code>oauth_refresh_tokens</code></li>
</ul>


<p>トークン作成時に使用されるキーを生成する。</p>

<p><code>
$ php artisan passport:install
</code></p>

<p>キーは、<code>/storage/</code>以下に生成される。<br/>
デフォルトでは<code>.gitignore</code>で無視する設定となっているので注意。<br/>
また、公開リポジトリにアップしてはいけない。<br/>
対処法などは以下参考。</p>

<ul>
<li><a href="https://qiita.com/kawax/items/59fde47056816cec52ec">Laravel Passport keyファイルの扱い &ndash; Qiita</a></li>
</ul>


<p>また、キーの生成とともに、DBにクライアントが作成される。</p>

<p><code>
Encryption keys generated successfully.
Personal access client created successfully.
Client ID: 1
Client Secret: tR7FSAHLQ8qw1xIgEWMKQ26QK2nKUxHahSHvY3RW
Password grant client created successfully.
Client ID: 2
Client Secret: 6n4TGzdrJHYdEJwPoMsaYuCA9EaFpXiGFr4dMVc8
</code></p>

<p>一つ目が、 <code>Laravel Personal Access Client</code><br/>
二つ目が、<code>Laravel Password Grant Client</code></p>

<p>二つ目はユーザ名＋パスワードを利用したアクセストークンの発行に利用出来る。<br/>
(ユーザーとの紐付けは特に必要なし)<br/>
(必要なければ消しておいてもよい)</p>

<h3>コードに追加</h3>

<h4><code>AuthServiceProvider.php</code>に追加</h4>

<p><code>/app/Providers/AuthServiceProvider.php</code></p>

<p>```php
public function boot()
{</p>

<pre><code>$this-&gt;registerPolicies();

Passport::routes();
</code></pre>

<p>}
```</p>

<h4><code>auth.php</code>のdriverをpassportに変更</h4>

<p><code>/config/auth.php</code></p>

<p>```php
&lsquo;guards&rsquo; => [</p>

<pre><code>'web' =&gt; [
    'driver' =&gt; 'session',
    'provider' =&gt; 'users',
],

'api' =&gt; [
    'driver' =&gt; 'passport',
    'provider' =&gt; 'users',
],
</code></pre>

<p>],
```</p>

<h2>クライアント認証情報グラントトークン</h2>

<p>冒頭の趣旨を実現するために、マシン-マシン間の認証に最適、という認証方式を採用する。</p>

<h4><code>Kanel.php</code>に追加</h4>

<p><code>/app/Http/Kanel.php</code></p>

<p>```php
protected $routeMiddleware = [</p>

<pre><code>...
'client' =&gt; CheckClientCredentials::class,
</code></pre>

<p>];<br/>
```</p>

<h2>アクセストークンの取得</h2>

<p>以下にアクセスして取得出来る。</p>

<p>・リクエスト</p>

<p><code>
POST : /oauth/token
</code></p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> <code>grant_type</code> </td>
<td align="left"> <code>client_credentials</code> |</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>client_id</code> </td>
<td align="left"> 発行したクライアントのID(数字) |</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>client_secret</code> </td>
<td align="left"> 発行したクライアントのシークレット |</td>
</tr>
<tr>
<td></td>
<td align="left"> <code>scope</code> </td>
<td align="left"> アクセスするスコープ |</td>
</tr>
</tbody>
</table>


<p>・レスポンス</p>

<p>```
{</p>

<pre><code>"token_type": "Bearer",
"expires_in": 31536000,
"access_token": "YOUR-ACCESS-TOKEN-HERE"
</code></pre>

<p>}
```</p>

<p>発行されたトークンは、<code>oauth_access_tokens</code>テーブルに格納されていく。</p>

<h3>有効期限</h3>

<p>デフォルトではトークンの有効期限は１年間となっている。</p>

<p>変更するには、<code>AuthServiceProvider</code>の<code>boot</code>メソッドから変更可能。</p>

<p><code>/app/Providers/AuthServiceProvider.php</code></p>

<p>```php
public function boot()
{</p>

<pre><code>$this-&gt;registerPolicies();

Passport::routes();
Passport::tokensExpireIn(Carbon::now()-&gt;addMinute(60));
Passport::refreshTokensExpireIn(Carbon::now()-&gt;addHour(2));
</code></pre>

<p>}
```</p>

<h2>APIへのアクセス</h2>

<p>上記トークンを使用してアクセス制限をかけたAPIへアクセスする。</p>

<h3>ルートに追加</h3>

<p>追加したミドルウェアを使用して、apiのルートにこの認証で使用するエンドポイントのリクエストを追加。</p>

<p><code>/routes/api.php</code></p>

<p>```php
Route::get(&lsquo;/hoge&rsquo;, function (){</p>

<pre><code>return 'OK';
</code></pre>

<p>})&ndash;>middleware(&lsquo;client&rsquo;);
```</p>

<h3>アクセス</h3>

<p>apiのルーティングは、<code>/api</code>以下に作成される。<br/>
よって、エンドポイントは以下になる</p>

<p><code>
GET : /api/hoge
</code></p>

<p>ヘッダにアクセストークンを付与してアクセスする。</p>

<ul>
<li>Authorization : <code>Bearer YOUR-ACCESS-TOKEN</code></li>
</ul>


<h4>エラー</h4>

<p>アクセストークンが間違っているなどの場合は、<code>InvalidArgumentException</code>が発生する。</p>

<h1>参考</h1>

<ul>
<li><a href="https://readouble.com/laravel/5.5/ja/passport.html">API認証(Passport) 5.5 Laravel</a></li>
<li><a href="https://qiita.com/niiyz/items/fffff94acb6061ecc9d4">Laravel5.5でAPI認証のパッケージ(Laravel Passport)を利用する &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PhpStormを使用してPHP UnitのテストをVagrantのリモート上で実行する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/22/laravel-phpunit-vagrant-phpstorm/"/>
    <updated>2017-09-22T19:05:58+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/22/laravel-phpunit-vagrant-phpstorm</id>
    <content type="html"><![CDATA[<p>LaravelのUnitテストを実行すべく、ローカルのVagrant環境上でPHP Unitを実行するように設定してみた。</p>

<!-- more -->


<h1>環境</h1>

<ul>
<li>Vagrant

<ul>
<li><a href="https://box.scotch.io/">ScotchBox</a></li>
</ul>
</li>
<li>Laravel 5.5.7</li>
<li>PHP 7.0</li>
</ul>


<h1>PHP Unit</h1>

<p>PHP UnitはCompoerにてプロジェクトディレクトリにインストールする。<br/>
LaravelではデフォルトでComposerに入っているので特に設定はなし。<br/>
(Linuxに入れる必要はない)</p>

<p><code>
"phpunit/phpunit": "~6.0"
</code></p>

<h1>PhpStorm</h1>

<p>PhpStormでの設定方法。<br/>
設定したいプロジェクトのルートディレクトリを開いた状態で設定する。</p>

<h2>PHP Interpreter</h2>

<p><code>Preference</code>を開く。<br/>
<code>Languages &amp; Frameworks -&gt; PHP -&gt; Test Frameworks</code>を選択。<br/>
<code>+</code>マークをクリックし、<code>PHPUnit by Remote Interpreter</code>を選択する。</p>

<p><img src="/images/2017/09/phpunit_01.jpg" alt="" /></p>

<p>Interpreterを選択するウインドウが開くが、interpreterがないので作成する。<br/>
右端の<code>...</code>をクリックする。</p>

<p><img src="/images/2017/09/phpunit_02.jpg" alt="" /></p>

<p>ウインドウが開くので、<code>+</code>をクリックし、<code>From Docker, Vagrant, VM, Remote...</code>を選択。</p>

<p><img src="/images/2017/09/phpunit_03.jpg" alt="" /></p>

<p>開いたウインドウで、<code>Vagrant</code>を選択。すると自動で設定が読み込まれるのでそのままOKする。</p>

<p><img src="/images/2017/09/phpunit_04.jpg" alt="" /></p>

<p>OKをクリックすると、SSH接続が行われ情報が自動で読み込まれる。<br/>
そのままでOKなのでOKをクリックする。</p>

<p><img src="/images/2017/09/phpunit_05.jpg" alt="" /></p>

<p>Interpreterを選択する画面に戻るので、作成したInterpreterを選択し、OKをクリック。</p>

<p><img src="/images/2017/09/phpunit_06.jpg" alt="" /></p>

<p>追加したInterpreterでPHPUnitのライブラリを指定するが、Composer経由でのロードになるので、デフォルトの<code>Use Composer autoloader</code>のままでよい。<br/>
Vagrant内でのautolodのパスを指定するので、<code>...</code>をクリック。</p>

<p><img src="/images/2017/09/phpunit_07.jpg" alt="" /></p>

<p>Scothboxは<code>/var/www</code>がホストと共有しているディレクトリになるので、そこから<code>vendor/autoload.php</code>を選択する。</p>

<p><img src="/images/2017/09/phpunit_08.jpg" alt="" /></p>

<p>選択すると、追加されているPHPUnitのバージョンが表示される。</p>

<p><img src="/images/2017/09/phpunit_09.jpg" alt="" /></p>

<p>これでInterpreterの設定は完了。</p>

<h2>Run/Debug Configurations</h2>

<p>Configurationsの設定を行う。</p>

<p>メニューから、<code>Run -&gt; Edit Configurations</code>を選択。</p>

<p><code>+</code>をクリックし、<code>PHPUnit</code>のConfigurationを追加する。</p>

<p><img src="/images/2017/09/phpunit_10.jpg" alt="" /></p>

<p>Nameは適当に書く。<br/>
Test scopeはテストしたいディレクトリを選択する。<br/>
Laravelのtestsディレクトリを指定しておく。（どこでもよい）<br/>
この設定の下部に、Errorと出ているのでFixをクリック。</p>

<p><img src="/images/2017/09/phpunit_11.jpg" alt="" /></p>

<p>PHPの設定ウインドウが開くので、<code>PHP language level</code>はVagrant環境に合わせて<code>7</code>を選択。<br/>
<code>CLI Interpreter</code>は設定したinterpreterを選択する。</p>

<p><img src="/images/2017/09/phpunit_12.jpg" alt="" /></p>

<p>OKで閉じる。</p>

<h2>実行</h2>

<p>右上のセレクトボックスが、先ほど作成したConfigurationが選択されている状態になっているはずなので、そのまま緑の三角をクリック。</p>

<p><img src="/images/2017/09/phpunit_13.jpg" alt="" /></p>

<p>すると、<code>tests</code>ディレクトリ以下のテストファイルが自動で起動し、テストが実行される。<br/>
デフォルトのサンプルテストは必ず成功するので、無事、テストが通ればOK。</p>

<p><img src="/images/2017/09/phpunit_14.jpg" alt="" /></p>

<p><code>ExampleTest.php</code>の<code>assertTrue</code>を<code>false</code>にしてみて失敗させてみる。</p>

<p>```
public function testBasicTest()
{</p>

<pre><code>$this-&gt;assertTrue(false);
</code></pre>

<p>}
```</p>

<p>ファイルを選択して右クリックすれば、そのファイルのみをテスト実行する事も可能。<br/>
失敗すると以下のようになる。</p>

<p><img src="/images/2017/09/phpunit_15.jpg" alt="" /></p>

<p>これで無事、成功と失敗の動作が確認できた。</p>

<h1>参考</h1>

<ul>
<li><a href="https://confluence.jetbrains.com/display/PhpStorm/Running+PHPUnit+tests+over+SSH+on+a+remote+server+with+PhpStorm">Running PHPUnit tests over SSH on a remote server with PhpStorm &ndash; PhpStorm &ndash; Confluence</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Laravel]キューのdelayとsleepオプション]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/22/laravel-queue-delay-sleep/"/>
    <updated>2017-09-22T15:05:42+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/22/laravel-queue-delay-sleep</id>
    <content type="html"><![CDATA[<p>Laravelにてキューを実行させる際に、delayとsleepオプションの関係がちょっと変だったのでメモ。</p>

<!-- more -->


<h1>sleep</h1>

<p><code>
--sleep[=SLEEP]      Number of seconds to sleep when no job is available [default: "3"]
</code></p>

<p>ジョブがない場合に次のジョブを取得するまでにスリープする秒数の設定。</p>

<h1>delay</h1>

<p><code>
--delay[=DELAY]      The number of seconds to delay failed jobs [default: "0"]
</code></p>

<p>ジョブが失敗した場合に再試行するまでの遅延時間。</p>

<h1>delayとsleep</h1>

<p>両方設定した場合の動作が少し変な気がするのでそれぞれ試してみた。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> delay </th>
<th align="left"> sleep </th>
<th align="left"> 失敗時遅延 </th>
<th align="left"> 待機 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> なし </td>
<td align="left"> 30 </td>
<td align="left"> 0 </td>
<td align="left"> 30 </td>
</tr>
<tr>
<td></td>
<td align="left"> 30 </td>
<td align="left"> なし </td>
<td align="left"> 30 </td>
<td align="left"> 0 </td>
</tr>
<tr>
<td></td>
<td align="left"> 5 </td>
<td align="left"> 30 </td>
<td align="left"> 30 </td>
<td align="left"> 30 </td>
</tr>
<tr>
<td></td>
<td align="left"> 30 </td>
<td align="left"> 5 </td>
<td align="left"> 30 </td>
<td align="left"> 5 </td>
</tr>
</tbody>
</table>


<p>実行コマンドは以下。</p>

<p><code>
$ php artisan queue:listen --sleep=xx --delay=xx
</code></p>

<p>結果は、3行目の<code>delay=5 sleep=30</code>の時だけ意図した動作と違っていた。<br/>
本来ならば<code>delay=5</code>なので失敗時の再試行までの遅延は5秒のはずなのに、sleepに設定している30秒が適用されているようだった。</p>

<h1>結論</h1>

<ul>
<li>delay > sleep の場合は意図通り動作する</li>
<li>delay &lt; sleep の場合はsleepに設定した時間がdelayにも適用される</li>
</ul>


<p>これはバグだろうか…。<br/>
本体のコードをちょっとだけ追ってみたけどよくわからなかったのでもし誰かわかればお願いします。</p>

<p><a href="https://github.com/laravel/framework">laravel/framework</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Laravel] キューのsleepとtimeoutの関係]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/22/laravel-queue-sleep-timeout/"/>
    <updated>2017-09-22T12:16:53+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/22/laravel-queue-sleep-timeout</id>
    <content type="html"><![CDATA[<p>Laravelのキューを実際に使ってみた際にちょっと変な挙動だと思ったメモ。</p>

<!-- more -->


<h1>sleep</h1>

<p>キューを実行するコマンドのオプションに<code>sleep</code>というものがある。<br/>
コマンドのヘルプの説明は以下。</p>

<p><code>
--sleep[=SLEEP]      Number of seconds to sleep when no job is available [default: "3"]
</code></p>

<p>ジョブがない場合に次のジョブを取得するまでにスリープする秒数の設定、とのこと。<br/>
例えばこれをゼロにすると、常にジョブを取得するためのポーリングが実行され続けるため、ジョブの保存先をキューイングサービスなどにしている場合に、ものすごい数のキュー取得リクエストが飛んでしまう。<br/>
なのでsleepを設定してやれば(ジョブがなくなった時に)、ポーリング間隔を空ける事が出来るので負荷が減ったりする。</p>

<h1>timeout</h1>

<p>処理の<code>timeout</code>オプション。</p>

<p><code>
--timeout[=TIMEOUT]  The number of seconds a child process can run [default: "60"]
</code></p>

<p>処理に指定した時間以上の時間がかかった場合はタイムアウトとする設定。デフォルトは60秒。</p>

<h1>sleepとtimeoutの関係</h1>

<p>sleepの時間を長く設定すると、タイムアウトエラーが発生してしまう。<br/>
例えば以下。</p>

<p><code>
php artisan queue:listen --sleep=120 --timeout=60
</code></p>

<p>というのも、次のキュー取得を実行するまでのスリープ時間もタイムアウトの対象の時間に含まれてしまう、よう。<br/>
なので必ずsleep時間よりもtimeoutの時間を多く設定してやらないといけない。<br/>
上記の場合だと<code>sleep</code>を120秒にしてるので、<code>timeout</code>を(少なくとも)120秒より大きく設定しないといけない。</p>

<p><code>
php artisan queue:listen --sleep=120 --timeout=125
</code></p>

<p>これだと無事、動作する。<br/>
(処理内容に5秒以上かかると合計が125秒を越えてしまうのでタイムアウトになるが）</p>

<h1>疑問</h1>

<p>単にポーリングの待ち時間のはずなのに実行時間のタイムアウトの対象に含まれるのはおかしいのでは？という疑問はやはり出ていたようで、Githubのissueでやりとりがされていた。</p>

<p><a href="https://github.com/laravel/framework/issues/6206">queue:listen&#39;s sleep duration contributing towards timeout · Issue #6206 · laravel/framework</a></p>

<p>内容を読んでいくと、そもそものプロセスの処理に組み込まれてしまっているため、根本的な修正は難しく、timeoutの時間をsleep時間を足して設定してやる、とかしか無理じゃない？みたいなやり取りになっている。</p>

<p>そしてその後、5.1の時にtimeout時間をsleep時間よりも短く設定出来ないようにする制限が組み込まれたようだが、巨大な処理を行う場合にtimeoutをなしにするためにゼロ秒にセットしたいのに出来ない、という意見が出て結局削除されている。</p>

<p>結果、制約も入らず対処もされていないようなので、現状は前述のように、timeout時間をsleep時間より必ず大きく設定してやらないといけない、ということになっているよう。</p>

<h1>余談</h1>

<p>キューのサンプルを作っている時に事象に遭遇したのだけど、そのキューのサンプルはGitHubにあげてる。<br/>
HerokuButtonで起動できるようにしたりしてみたので、よかったらお試しあれ。</p>

<p><a href="https://github.com/k-usk/laravel-queue-sample">https://github.com/k-usk/laravel-queue-sample</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[heroku]PostgresとRedisの環境設定]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/21/heroku-postgres-redis/"/>
    <updated>2017-09-21T15:16:32+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/21/heroku-postgres-redis</id>
    <content type="html"><![CDATA[<p>LaravelをHerokuで使用する際に、Heroku PostgresとHeroku Redisの接続情報を環境変数から取得する設定のメモ。</p>

<!-- more -->


<h1>概要</h1>

<p>改めて。<br/>
Herokuでは標準のadd-onとして<a href="https://elements.heroku.com/addons/heroku-postgresql">Heroku Postgres</a>と<a href="https://elements.heroku.com/addons/heroku-redis">Heroku Redis</a>が用意されている。<br/>
クレジットカードさえ登録していれば無料で使えるので便利。</p>

<p>この接続情報はアドオンを登録した際に自動的に以下のような変数で登録がされる。</p>

<p><strong>Postgres</strong><br/>
<code>DATABASE_URL</code> = <code>postgres://username:password@hostname.amazonaws.com:5432/database</code></p>

<p><strong>Redis</strong><br/>
<code>REDIS_URL</code> = <code>redis://h:password@hostname.amazonaws.com:port_no</code></p>

<p>各種情報がURL形式で組み込まれているのだが、間違ってもこれを自分でバラしてそれぞれ個別に環境変数に入れる、などとしてはいけない。<br/>
というのも、この接続情報はPostgresやRedisにメンテナンスが入った際に前の接続情報は破棄され、新しい情報が同じ環境変数で設定されるため、<br/>
自前でバラして作ってしまうとその変更した情報に対応できなくなり、接続エラーとなってしまう。</p>

<p>よって、必ず自動でセットされる、<code>DATABASE_URL</code>や<code>REDIS_URL</code>を使うこと。<br/>
これはHerokuを使う際には常識として覚えておくこと。</p>

<h1>取得</h1>

<p>というわけで、それぞれの値を取得したURLからパースしてLaravel用に環境変数にセットする。<br/>
以下のように環境変数があればそれをパースして環境変数としてセットしてやるようにするのがスマートっぽい。<br/>
これだとローカルでは個別に<code>.env</code>ファイルで設定した値を使用してやることが出来る。</p>

<p><code>/config/database.php</code> の冒頭に書く。</p>

<p>```
//Postgres
if (getenv(&lsquo;DATABASE_URL&rsquo;)) {</p>

<pre><code>$url = parse_url(getenv('DATABASE_URL'));
putenv('DB_HOST='.$url['host']);
putenv('DB_PORT='.$url['port']);
putenv('DB_DATABASE='.substr($url["path"], 1));
putenv('DB_USERNAME='.$url["user"]);
putenv('DB_PASSWORD='.$url['pass']);
</code></pre>

<p>}</p>

<p>//Redis
if (getenv(&lsquo;REDIS_URL&rsquo;)) {</p>

<pre><code>$url = parse_url(getenv('REDIS_URL'));
putenv('REDIS_HOST='.$url['host']);
putenv('REDIS_PORT='.$url['port']);
putenv('REDIS_PASSWORD='.$url['pass']);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
