<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apex | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/apex/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2016-07-04T16:33:18+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[salesforce] エラーが出てもエラーレコード以外は更新させる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/05/13/database-upsert/"/>
    <updated>2016-05-13T17:26:24+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/05/13/database-upsert</id>
    <content type="html"><![CDATA[<p>salesforceでインサート・アップデートする場合、ガバナ制限の関係から都度DMLを発行せずにある程度まとめてやる事が多い。<br/>
その際に、一件でもエラーが出てしまうと他もまきこまれてロールバックされてしまうので、エラー以外は更新させる方法。</p>

<!-- more -->


<h1>通常の方法</h1>

<p>通常の方法、というか、簡易な方法としては、以下のようにインサートする。</p>

<p>```
List<Lead> lists = new List<Lead>();
for(xx){</p>

<pre><code>//Leadを作ってaddする処理
</code></pre>

<p>}
insert lists;
```</p>

<p><code>for</code>文の中で<code>insert</code>せずに、リストにまとめておいて外で一回だけ<code>insert</code>する。<br/>
これで、DMLは一回だけ発行したことになるので、節約が可能。<br/>
ループの中ではSOQL、DMLはしない。これがapexの鉄則。</p>

<p>しかしこれだと例えば全部で200件インサートする予定があって、そのうち150件目に不備がありエラーが出た場合、
そこで処理がストップし、それまでにインサートした149件もすべてロールバックされインサート自体がなかったことになる。
要件によってはこの方がいい場合もあるが、エラーが出たレコード以外は全てインサートしたい場合もある。</p>

<h1>Database Class</h1>

<p>そんな時は、<code>Database</code>クラスを使う。<br/>
使い方は、<code>Database.insert()</code>とするだけ。</p>

<p>このメソッドの第1引数に、インサートするオブジェクトのリストを、
第２引数に、エラー時の挙動を入れる。</p>

<ul>
<li>trueの場合はエラー時には全てロールバック(上記の単純な<code>insert</code>と同じ)(デフォルト)</li>
<li>falseの場合はエラーレコード以外はインサートする</li>
</ul>


<p>上記の例を書き換えると、以下のようになる。</p>

<p>```
List<Lead> lists = new List<Lead>();
for(xx){</p>

<pre><code>//Leadを作ってaddする処理
</code></pre>

<p>}
Database.insert(lists, false);
```</p>

<p>これでエラーのレコード以外はインサートさせる事が出来た。<br/>
<code>updata</code>、<code>upsert</code>、<code>delete</code> についても同じ。</p>

<p><a href="https://developer.salesforce.com/docs/atlas.ja-jp.200.0.apexcode.meta/apexcode/apex_methods_system_database.htm">Database クラス</a></p>

<h1>Upsert</h1>

<p>upsertも上記と方法は同じだが、upsertでは外部IDの指定が可能になるが、その方法が少し簡易バージョンとは違った。</p>

<p>例えば、<code>Lead</code>オブジェクトの、カスタム項目、<code>UserID__c</code>を外部IDとして指定する場合。<br/>
簡易バージョンの場合は以下のようになる。</p>

<p><code>
List&lt;Lead&gt; lists = new List&lt;Lead&gt;();
//処理中略
upsert lists UserID__c;
</code></p>

<p>上記、<code>Database</code>を使ったパターンだと、ドキュメントには以下のように書かれている。</p>

<p><code>
upsert(recordToUpsert, externalIdField, allOrNone)
</code></p>

<p>この第二引数の<code>externalIdField</code>が外部IDの指定箇所になるが、型は、<code>Schema.SObjectField</code>となっていて、
そのまま <code>Database.upsert(lists, UserID__c, false)</code>とやるとエラーが出る。</p>

<p>なので以下のようにして指定したい項目の<code>Schema.SObjectField</code>を取得して指定してやる必要がある。</p>

<p><code>
List&lt;Lead&gt; lists = new List&lt;Lead&gt;();
//処理中略
Schema.DescribeFieldResult F = Lead. UserID__c.getDescribe();
Schema.sObjectField T = F.getSObjectField();
Database.upsert(lists, T, false);
</code></p>

<p>これで外部IDを指定したアップサートが可能となる。</p>

<p><a href="https://developer.salesforce.com/docs/atlas.ja-jp.200.0.apexcode.meta/apexcode/apex_class_Schema_SObjectField.htm">SObjectField クラス</a></p>

<h1>エラーハンドリング</h1>

<p>さて、DMLでエラーが発生した場合、その内容を取得するには、<code>try..catch</code>で例外を拾っていた。</p>

<p>```
try{</p>

<pre><code>insert lists;
</code></pre>

<p>}catch(DmlException e){</p>

<pre><code>System.debug(e.getMessage());
System.debug(e.getStackTraceString());
</code></pre>

<p>}
```</p>

<p><a href="https://developer.salesforce.com/docs/atlas.ja-jp.200.0.apexcode.meta/apexcode/apex_classes_exception_methods.htm">Exception クラスおよび組み込み例外</a></p>

<p>しかし、<code>Database</code>を使ってinsertなどをした場合は別の方法で取得する。<br/>
というか、エラーだけでなく、結果を一件ずつ取得することが出来るため、それらからエラー分を取得する、という形になる。</p>

<p><code>SaveResult</code>クラスを使用する。</p>

<p><code>
List&lt;Database.SaveResult&gt; res_lists = Database.insert(lists, false);
</code></p>

<p>取得した結果から、成功、失敗を取得し、内容を取得したりする。</p>

<p>```
List&lt;Database.SaveResult> res_lists = Database.insert(lists, false);
for (Database.SaveResult res : res_lists) {</p>

<pre><code>if(res.isSuccess()){
    //成功時
}else{
    //失敗時
    for(Database.Error err : res.getErrors()) {
        System.debug(err.getStatusCode());
        System.debug(err.getMessage());
    }
}
</code></pre>

<p>}
```</p>

<p>例えば出力内容は以下のような感じ。</p>

<p><code>
DEBUG|REQUIRED_FIELD_MISSING
値を入力してください: [LastName]
</code></p>

<p>この <code>SaveResult</code> は、インサート時の結果を取得するためのクラスで、
インサート、アップサート、アップサート、デリート、それぞれのクラスが別々に用意されている。</p>

<ul>
<li>insert &ndash; SaveResult</li>
<li>update &ndash; UndeleteResult</li>
<li>upsert &ndash; UpsertResult</li>
<li>delete &ndash; DeleteResult</li>
</ul>


<p>詳しくは、Apex 開発者ガイド、を参照。<br/>
(直接のリンクがなぜか貼れなかった）</p>

<p><a href="https://developer.salesforce.com/docs/atlas.ja-jp.apexcode.meta/apexcode/apex_namespace_Database.htm">Apex開発者ガイド &ndash; リファレンス &ndash; Database名前空間</a></p>

<h1>まとめ</h1>

<p>以上で一通り想定していた動作をさせることができた。<br/>
エラー時に他をロールバックするかどうかとかは、結構忘れがちになるけれど、結構難しい問題。<br/>
仕様策定時にきちんと考慮していきたい。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[カスタム設定を作成して取得してみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/02/01/custom-setting/"/>
    <updated>2016-02-01T15:15:19+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/02/01/custom-setting</id>
    <content type="html"><![CDATA[<p>カスタム設定、というカスタムオブジェクトの一種でSOQLいらずでもっと手軽に扱える <code>カスタム設定</code> とうものを知ったので、<br/>
作り方から使い方を調べてみた。</p>

<!-- more -->


<blockquote><p>カスタム設定はカスタムオブジェクトと類似しており、アプリケーション開発者は、カスタムデータセットの作成の他に、組織、プロファイル、または特定のユーザに対しカスタムデータを作成して関連付けることができます。<br/>
<a href="https://help.salesforce.com/HTViewHelpDoc?id=cs_about.htm&amp;language=ja">https://help.salesforce.com/HTViewHelpDoc?id=cs_about.htm&amp;language=ja</a></p></blockquote>

<p>今回は全体で使用する、環境変数、としてカスタム設定を作成してみた。</p>

<h2>作成</h2>

<p>[開発] → [カスタム設定] にアクセス。<br/>
まずは新規でカスタム設定、を作る。<br/>
オブジェクトのようなもの。</p>

<p><img src="/images/2016/01/custom_setting02.jpg" alt="" /></p>

<p>今回は以下のように作成した。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> 表示ラベル </td>
<td align="left"> 環境変数</td>
</tr>
<tr>
<td></td>
<td align="left"> オブジェクト名 </td>
<td align="left"> EnvironmentVars</td>
</tr>
<tr>
<td></td>
<td align="left"> 設定種別 </td>
<td align="left"> リスト</td>
</tr>
<tr>
<td></td>
<td align="left"> 表示 </td>
<td align="left"> 公開</td>
</tr>
<tr>
<td></td>
<td align="left"> 説明 </td>
<td align="left"> </td>
</tr>
</tbody>
</table>


<p><img src="/images/2016/01/custom_setting03.jpg" alt="" /></p>

<p>設定種別は、リスト、と、階層、があり、<br/>
階層、は、ユーザーやプロファイルごとに同じ項目で違う値を設定したり出来るよう。<br/>
どのユーザーが使用しているかによって変数の値を変更できるようになるので、<br/>
そういうことを実現したい時に便利っぽい。 <br/>
今回は全員同じにしたいので、リスト、にしておいた。</p>

<p>また、表示、は、公開・保護、とある。<br/>
公開、だとSOAP APIでも取得できるようになったり、とオープンな状態？になるよう。<br/>
特に秘匿する内容でもないので、公開、にしておいた。</p>

<p>次に作成したカスタム設定内にカスタム項目を追加する。<br/>
作成したカスタム設定から、新規、をクリック。</p>

<p><img src="/images/2016/01/custom_setting04.jpg" alt="" /></p>

<p>通常の項目作成と同じ流れで、型を選択し、内容を埋めていく。<br/>
今回は以下のように作成した。<br/>
目的としては、SitesのURLを環境変数として持っておくためのもの。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> 型 </td>
<td align="left"> テキスト</td>
</tr>
<tr>
<td></td>
<td align="left"> 項目の表示ラベル </td>
<td align="left"> Sites</td>
</tr>
<tr>
<td></td>
<td align="left"> 文字数 </td>
<td align="left"> 255</td>
</tr>
<tr>
<td></td>
<td align="left"> 項目名 </td>
<td align="left"> Sites</td>
</tr>
<tr>
<td></td>
<td align="left"> 説明、など </td>
<td align="left"> </td>
</tr>
</tbody>
</table>


<p><img src="/images/2016/01/custom_setting05.jpg" alt="" /></p>

<p>ここまででオブジェクトと項目が作成出来たので、実際にデータを入れていく。<br/>
作成したカスタム設定の<code>Manege</code>をクリック。</p>

<p><img src="/images/2016/01/custom_setting06.jpg" alt="" /></p>

<p>リストが表示されるので、新規、をクリック。</p>

<p><img src="/images/2016/01/custom_setting07.jpg" alt="" /></p>

<p>内容を記入して保存。</p>

<p><img src="/images/2016/01/custom_setting08.jpg" alt="" /></p>

<h2>取得</h2>

<p>作成したデータをApexで取得する。</p>

<p>前述の通り、取得の際にはSOQLを発行する必要がなく、以下のようにメソッドレベルで取得可能。</p>

<p>```
Map&lt;String, EnvironmentVars<strong>c> settingMap = EnvironmentVars</strong>c.getAll();</p>

<p>for (String key : settingMap.keySet()) {</p>

<pre><code>EnvironmentVars__c env = settingMap.get(key);
System.debug('**DEBUG** ' key + ' / ' + env.SitesURL__c);
</code></pre>

<p>}
```</p>

<h2>まとめ</h2>

<p>SOQLを発行しないので、ガバナ的にも優しく、内容はキャッシュされるので動作も高速。<br/>
環境変数のように決まった値であれば便利に使えるかもしれない。</p>

<h2>参考</h2>

<p><a href="https://help.salesforce.com/HTViewHelpDoc?id=cs_accessing.htm&amp;language=ja">カスタム設定へのアクセス</a><br/>
<a href="https://odekakeshimasyo.io/salesforce-apex-customsetting.html">Salesforce Apex カスタム設定 | odekakeshimasyo.io</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ApexでJSONをパースする]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/12/08/json-apex-parse/"/>
    <updated>2015-12-08T19:12:05+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/12/08/json-apex-parse</id>
    <content type="html"><![CDATA[<p>Apex RestAPIなんかを作成している際に、インプットをJSONにしたい場合があります。<br/>
その際に受け取ったJSONをApexでパースして使用する方法がややこしかったのでメモ。</p>

<!-- more -->


<h2>基本</h2>

<p>基本としては、以下の記事が詳しいです。<br/>
<a href="http://www.teamspirit.co.jp/blog/staff/2011/10/winter12json2.html">Winter&rsquo;12のJSONサポートを使いこなす(2) | チームスピリット</a></p>

<p>ここにもある通り、例えば、<code>{a:xx, b:xxx}</code>などのJSONがある場合は、予めapex側でそのJSONの内容専用のクラスを用意してやる必要がある、とのこと。<br/>
何もなしでいきなりパースしていくことが出来ない。</p>

<p>そのためにクラスを用意してオブジェクトにして……が非常にめんどくさい。</p>

<h2>変換ツール</h2>

<p>そんなめんどくさいJSONのクラス作成を一発で変換してくれるwebツールが以下。</p>

<p><a href="http://json2apex.herokuapp.com/">JSON2Apex</a></p>

<p>例の通り、例えば以下の様なJSONを入力してapexを作成すると、以下のようなコードが生成される。</p>

<p>```
public class JSON2Apex {</p>

<pre><code>public class User {
    public String name;
    public String twitter;
}

public User user;


public static JSON2Apex parse(String json) {
    return (JSON2Apex) System.JSON.deserialize(json, JSON2Apex.class);
}
</code></pre>

<p>}
```</p>

<p>そしてなんと一緒にテストコードまで出力してくれる。</p>

<p>```
@IsTest
public class JSON2Apex_Test {</p>

<pre><code>static testMethod void testParse() {
    String json = '{ ¥"user¥" : { ¥"name¥" : ¥"Simon Fell¥", ¥"twitter¥" : ¥"@superfell¥" } }';
    JSON2Apex obj = JSON2Apex.parse(json);
    System.assert(obj != null);
}
</code></pre>

<p>}
```</p>

<p>これをコピペするなりしてapexクラスとして作成すればOK。</p>

<h2>配列のJSON</h2>

<p>以下の様な配列になっているJSONをパースしたい場合。</p>

<p>```
{&ldquo;data&rdquo;:[</p>

<pre><code>{
    "userid":1,
    "name":"hoge"
},
{   "userid":2,
    "name":"fuga"
}
</code></pre>

<p>]}<br/>
```</p>

<p>これも上記ツールにかけると以下の様なクラスが生成される。<br/>
(テストクラスは割愛)</p>

<p>```
public class JSON2Apex {</p>

<pre><code>public List&lt;Data&gt; data;

public class Data {
    public Integer userid;
    public String name;
}


public static JSON2Apex parse(String json) {
    return (JSON2Apex) System.JSON.deserialize(json, JSON2Apex.class);
}
</code></pre>

<p>}
```</p>

<p>これを利用して<code>userid</code>を順番に取得したい場合は以下のようにすればいい。<br/>
(json_strには上記のJSONが入っているものとする)</p>

<p>```
JSON2Apex_Thread obj = JSON2Apex_Thread.parse(json_str);
for(JSON2Apex.Data val : obj.data){</p>

<pre><code>System.debug(val. userid);
</code></pre>

<p>}
```</p>

<h2>まとめ</h2>

<p>いちいちJSONの内容に合わせてクラスを作成しないといけないのは非常にめんどくさい。<br/>
<code>JSON.deserialize</code>の他にも、<code>JSON.createParser()</code>もあるが、これも同じくクラスの作成は必要。<br/>
型が厳密なだけにいちいち指定が必要になるのかもしれない。</p>

<h2>参考</h2>

<p><a href="http://salesforce.stackexchange.com/questions/5427/json-deserialize-array-of-objects">apex &ndash; JSON.deserialize Array of Objects &ndash; Salesforce Stack Exchange</a><br/>
<a href="https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/apex_class_System_JsonParser.htm">JSONParser Class | Force.com Apex Code Developer&#x27;s Guide | Salesforce Developers</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[apex]バッチ実行時にカウントデータを引き継ぐ]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/08/05/apex-batch-data/"/>
    <updated>2015-08-05T11:26:58+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/08/05/apex-batch-data</id>
    <content type="html"><![CDATA[<p>apexでバッチを走らせる場合は、デフォルトでの200件ごとに処理を走らせる場合が多いけれれど、<br/>
その時に処理の中でカウントアップしたデータを次の処理に引き継ぎたかった。</p>

<!-- more -->


<p>結論から言うと、 <code>Database.Stateful</code> を使うと、データの内容を保持した状態でバッチが走らせられた。</p>

<p>具体的には以下。</p>

<p>```
public with sharing class Hogehoge_Batch implements Database.Batchable<sObject>, Database.Stateful{</p>

<pre><code>private Integer count {get; set;}

public Hogehoge_Batch(Boolean isLastBatch){
    this.count = 0;
}

public Database.QueryLocator start(Database.BatchableContext BC){
    String query = 'select id from Lead';
     return Database.getQueryLocator(query);
}

public void execute(Database.BatchableContext BC, List&lt;Lead&gt; scope){
    for(Lead user : scope){ 
        user.count__c = this.count;
        this.count++;
    }
    update scope;
}

public void finish(Database.BatchableContext BC){
}
</code></pre>

<p>}
```</p>

<p>クラス定義の1行目の最後にくっついてる。<br/>
これがないと<code>count</code>は毎回リセットされてしまう。</p>

<h2>参考</h2>

<p><a href="http://tyoshikawa1106.hatenablog.com/entry/2015/02/15/182505">SFDC：【大量データ処理】Apex Batchで一括更新処理を確認してみました &ndash; tyoshikawa1106のブログ</a><br/>
<a href="http://salesforceapexcodecorner.blogspot.jp/2011/08/state-management-in-batch-apex-in.html">State Management In Batch Apex in Salesforce</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]apexでレコードをフォローさせる]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/07/02/record-follow/"/>
    <updated>2015-07-02T09:54:50+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/07/02/record-follow</id>
    <content type="html"><![CDATA[<p>レコードを作った段階で自動的にフォローさせたかったので調べてみた。</p>

<!-- more -->


<h2>チャター</h2>

<p>デフォルトでは一部のレコードを除いてレコードのフォロー機能はオフになっている。<br/>
オンにするには、<code>フィード追跡</code>で有効にする。</p>

<p><code>設定 -&gt; カスタマイズ -&gt; Chatter -&gt; フィード追跡</code>を選択。<br/>
有効にしたいオブジェクトを選んで、<code>フィード追跡の有効化</code>にチェックを入れて保存。</p>

<p><img src="/images/2015/07/feed_follow01.jpg" alt="" /></p>

<p>すると、設定したレコード詳細の上部にフォローの表示とチャターコメントが出現する。<br/>
フォローしたい場合はここをクリックしてフォロー出来る。</p>

<p><img src="/images/2015/07/feed_follow02.jpg" alt="" /></p>

<p>フォローすると以下のような表示に変わる。</p>

<p><img src="/images/2015/07/feed_follow03.jpg" alt="" /></p>

<h2>apexでのフォロー</h2>

<p>フォローは、<code>EntitySubscription</code>なるオブジェクトで管理されている。<br/>
現在のフォロー関係一覧を取得するSOQLは以下。</p>

<pre><code>SELECT Id, ParentId, SubscriberId FROM EntitySubscription
</code></pre>

<p><code>ParentId</code>が、フォロー対象のユーザーやオブジェクトのレコードID。<br/>
<code>SubscriberId</code>が、フォローするユーザーのID、となる。</p>

<p>なので、このオブジェクトにフォロー対象とフォローするIDを入れてインサートしてやればよい。</p>

<p>例）</p>

<p><code>
EntitySubscription follow = new EntitySubscription();
follow.ParentId = 'ID'; //対象のレコード
follow.SubscriberId = 'ID'; //ユーザーのID
insert follow;
</code></p>

<p>トリガーで実装する場合は、レコードのIDが必要になるので、<code>after insert</code>で実行すること。</p>

<h2>参考</h2>

<p><a href="http://vaindespair.blogspot.jp/2011/01/blog-post.html">memo: Force.com&#12288;&#65306;&#12288;行動を作成したとき&#12289;自動的にフォローするようにしたい</a></p>

<p>チャター関係は以下のPDFにまとまっていた。<br/>
<a href="http://developerforcejp.s3.amazonaws.com/books/cheatsheets/Chatter-cheatsheet_Ja.pdf">http://developerforcejp.s3.amazonaws.com/books/cheatsheets/Chatter-cheatsheet_Ja.pdf</a></p>
]]></content>
  </entry>
  
</feed>
