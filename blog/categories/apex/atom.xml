<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apex | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/apex/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2015-04-14T18:35:43+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[apex]トリガーのインサートエラーのテストコードを書く]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/04/14/apex-test-trigger/"/>
    <updated>2015-04-14T17:31:36+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/04/14/apex-test-trigger</id>
    <content type="html"><![CDATA[<p>言われてみれば当たり前なんですが、メモ。</p>

<!-- more -->


<p>レコードがインサートされた際にデータ内容をチェックして、間違っていればエラーを返す、というトリガーを作成した。<br/>
要するに、自前のバリデーションチェックみたいなもの。<br/>
このテストコードを書いた際に、そのエラー部分も通るように作ってしまうと、テストコード自体がエラーになってしまってチェック出来なかった。</p>

<p>で、解決策としては単純で、<code>try〜catch</code>を使う。</p>

<p>以下、例。</p>

<h3>apex</h3>

<p>```
trigger SampleLeadTrigger on Lead (before insert) {</p>

<pre><code>for(Lead obj : Trigger.New){
    if(obj.LastName == 'test'){
        obj.addError('testという名前は使えません');
        continue;
    }
}
</code></pre>

<p>}
```</p>

<p>姓に、<code>test</code>という文字列の使用をエラーとするトリガーです。</p>

<h3>テストコード</h3>

<p>以下にようにそのままテストコードを書いてみます。</p>

<p>```
@isTest
private class Test_SampleLeadTrigger {</p>

<pre><code>static testMethod void excute(){
    Lead test_obj = new Lead();
    test_obj.Company = 'hoge co.';
    test_obj.LastName = 'test';

    insert test_obj;
}
</code></pre>

<p>}
```</p>

<p>すると、以下のようなエラーが出てしまい、テストコードが実行できません。</p>

<blockquote><p>18:14:44:833 FATAL_ERROR System.DmlException: Insert failed. First exception on row 0; first error: FIELD_CUSTOM_VALIDATION_EXCEPTION, testという名前は使えません: []</p></blockquote>

<p>なので、<code>insert</code>する部分を<code>try-catch</code>で例外をキャッチするようにします。</p>

<p>```
@isTest
private class Test_SampleLeadTrigger {</p>

<pre><code>static testMethod void excute(){
    Lead test_obj = new Lead();
    test_obj.Company = 'hoge co.';
    test_obj.LastName = 'test';

    try{
        insert test_obj;
    }catch(Exception e){

    }
}
</code></pre>

<p>}
```</p>

<p>これでエラーで止まらなくなるので実行は出来るようになります。<br/>
catchの部分は今回で言えば、<code>DmlException</code>なので、それでもよいですが、より広いエラーで、<code>Exception</code>にしています。<br/>
この辺はあまり深く追求してません。。</p>

<p>で、これだとテストは通りますが、テストの意味はあまりないと思うので、意図したエラーが返ってくるかを確認するために、以下のように変更します。</p>

<p><code>try-catch</code>部分</p>

<p>```
try{</p>

<pre><code>insert test_obj;
</code></pre>

<p>}catch(Exception e){</p>

<pre><code>Boolean expectedExceptionThrown =  e.getMessage().contains('testという名前は使えません') ? true : false;
System.AssertEquals(expectedExceptionThrown, true);
</code></pre>

<p>}
```</p>

<p>これで指定したエラーが返ってきたかどうかがチェックできます。<br/>
もし指定したエラー以外のものが返ってきた場合は以下のようなエラーが出てテストコードが実行できなくなってしまうので間違いに気付くことが出来ます。</p>

<blockquote><p>System.AssertException: Assertion Failed: Expected: false, Actual: true</p></blockquote>

<p>（<code>e.getMessage()</code>は、 System.DmlException:〜の文言を含んだ内容となるので、<code>contains</code>関数で指定の文字列が<strong>含まれている</strong>かどうかをチェックしている。）</p>

<h3>参考</h3>

<p><a href="https://developer.salesforce.com/forums/ForumsMain?id=906F00000008xGuIAI">How do I test for an exception(&lsquo;addError&rsquo;) in a Trigger ? &ndash; Salesforce Developer Community</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[apex]Date型のフォーマット]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/04/10/format-date/"/>
    <updated>2015-04-10T10:55:07+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/04/10/format-date</id>
    <content type="html"><![CDATA[<p>何回かググっているので、備忘録。</p>

<!-- more -->


<p>Date型のフォーマットは一応用意されているが、フォーマット内容を指定が出来ないよう。</p>

<p><code>
Date d = Date.newInstance(2015, 4, 10);
System.debug(d); //2015-04-10 00:00:00
String d_str = d.format();
System.debug(d_str); //2015/04/10
</code></p>

<p><code>format('yyyy-MM-dd')</code>とか書くと怒られる。<br/>
<a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_methods_system_date.htm#apex_System_Date_format">Date Class &ndash; format()</a></p>

<p>代わりにDatetime型の場合はフォーマットを指定して出力が可能。<br/>
なので、Date型のものをフォーマット指定して出力したい場合は、一度Datetime型に変換してやる必要がある。</p>

<p>apexのDatetime型の扱いには注意が必要で、そのまま変換してDatetime型のまま使用しているとタイムゾーンが標準時になって９時間戻ってしまう。<br/>
ただしそれをフォーマットして文字列にするとまた元に戻る。
指定するならする、しないならしない、で統一しているとややこしくならなくてすみそう。</p>

<p><code>
Date d = Date.newInstance(2015, 4, 10);
System.debug(d);  //2015-04-10 00:00:00
Datetime dt = Datetime.newInstance(d.year(), d.month(), d.day());
System.debug(dt);  //2015-04-09 15:00:00
String dt_str = dt.format('yyyy-MM-dd');
System.debug(dt_str);  //2015-04-10
</code></p>

<h3>参考</h3>

<p><a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_methods_system_date.htm#apex_System_Date_format">Date Class &ndash; format()</a><br/>
<a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_methods_system_datetime.htm#apex_System_Datetime_format_2">Datetime Class &ndash; format(string)</a><br/>
<a href="http://stackoverflow.com/questions/11834873/salesforce-apex-validating-date-for-format-and-value">validation &ndash; Salesforce Apex: Validating date for format and value &ndash; Stack Overflow</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]Apex REST作成時のtips]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/03/27/apex-rest-tips/"/>
    <updated>2015-03-27T19:45:44+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/03/27/apex-rest-tips</id>
    <content type="html"><![CDATA[<p>最近よくApexRESTを作成していて、<br/>
その中でちょっとしたtipsというかメモをメモっておきます。</p>

<!-- more -->


<h2>エンドポイント</h2>

<p>エンドポイントの指定には以下のように書きます。</p>

<pre><code>@RestResource(urlMapping='/User/Login')
</code></pre>

<p>この時に、<code>*</code>を使う事も出来ます。</p>

<pre><code>@RestResource(urlMapping='/User/*')
</code></pre>

<p>なので、ここにユーザーIDを入れたりして、そのIDを取得することで、<br/>
よりREST APIらしい(?)挙動でAPIを作成する事が出来ます。<br/>
apex側で送信されたIDを取得するには、以下のように<code>/</code>で区切って取得します。</p>

<pre><code>String accountId = req.requestURI.substring(req.requestURI.lastIndexOf('/')+1);
</code></pre>

<p>公式のドキュメントに正にこのままの内容が載っていました。</p>

<p><a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_rest_code_sample_basic.htm">Apex REST Basic Code Sample</a></p>

<h2>JSON</h2>

<p>返却するJSONの形式ですが、クラスの入れ子や、<code>List</code>を活用することで<br/>
かなり自由度高く作成出来ます。</p>

<p>例えば、以下のようなJSONを返すとします。</p>

<p>```
&ldquo;success&rdquo;:1,
&ldquo;User&rdquo; : {</p>

<pre><code>"user_id": xxx,
"hobby":[
    {"name":"映画", "level":"3"},
    {"name":"サッカー", "level":"1"}
]
</code></pre>

<p>},
&ldquo;request_time&rdquo;: &ldquo;2015-3-27 12:33&rdquo;
```</p>

<p>この場合、以下のようにクラスを複数作り、入れ子構造を作る事で作成出来ます。</p>

<p>```
global class UserData{</p>

<pre><code>global String user_id;
global HobbyData hobby
</code></pre>

<p>}
global class HobbyData{</p>

<pre><code>global String name;
global String level;
</code></pre>

<p>}
global class resultData{</p>

<pre><code>global Integer success;
global UserData User;
global String request_time;
</code></pre>

<p>}
```</p>

<p>作成するときは以下のような感じで。</p>

<p>```
List<HobbyData> hobbies = new List<HobbyData>();
HobbyData hobby1 = new HobbyData();
hobby1.name = &lsquo;映画&rsquo;;
hobby1.level = &lsquo;3&rsquo;;
hobbies.add(hobby1);
HobbyData hobby2 = new HobbyData();
hobby2.name = &lsquo;サッカー&rsquo;;
hobby2.level = &lsquo;1&rsquo;;
hobbies.add(hobby2);</p>

<p>UserData user = new UserData();
user.user_id = &lsquo;xxx&rsquo;;
user.hobby = hobbies;</p>

<p>resultData result = new resultData();
result.success = 1;
result.User = user;
result.request_time = &lsquo;2015-3-27 12:33&rsquo;;</p>

<p>return result;
```</p>

<p>地道な作業にはなりますが、これでわりかし綺麗なJSONが返せました。<br/>
もっと簡単な方法があったらまた書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apexのテストで変数部分にテストが通ってくれない時]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/12/02/apex-json-class-test/"/>
    <updated>2014-12-02T18:41:35+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/12/02/apex-json-class-test</id>
    <content type="html"><![CDATA[<p>きっと基本を理解してないんだと思いますが、単純な話でした。</p>

<!-- more -->


<p>JsonをGETで引き渡して、それをApexクラスにしてapex内で使用するべく、<br/>
apex2Jsonとして以下のようなクラスを作成していた。</p>

<pre><code>public class Json2Apex{
    public String user_id;
    public String dummy;

    public static Json2Apex parse(String json){
        return (Json2Apex) System.JSON.deserialize(json, Json2Apex.class);
    }
}
</code></pre>

<p>ちゃんとJSONには、<code>user_id</code>と<code>dummy</code>の値を持たせて変換させ、<br/>
その変数にもきっちりアクセスした状態でも、テストを走らせてみると、<br/>
<code>parse</code>メソッド部分しか通ってない。<br/>
全体の行数が少ないので、パーセンテージとしては、<strong>50%</strong>。<br/>
これでは他のリリースに影響が大なので、調べてみると、単純な事で、<br/>
<code>{get; set;}</code>をつけろ、ってだけだった。<br/>
以下のようにつける。</p>

<pre><code>public String user_id{get; set;}
public String dummy{get; set;}
</code></pre>

<p>これだけでテストコードも変更することなく通り、無事、100%を達成できました。</p>

<p>参考：<a href="http://salesforce.stackexchange.com/questions/10018/testing-apex-classes-created-by-jsontoapex">http://salesforce.stackexchange.com/questions/10018/testing-apex-classes-created-by-jsontoapex</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文字列をDatetime型に変換する時の注意点]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/12/01/apex-datetime-gmt/"/>
    <updated>2014-12-01T12:53:59+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/12/01/apex-datetime-gmt</id>
    <content type="html"><![CDATA[<p>apexにて、文字列からDatetime型に変更した際の注意点。</p>

<!-- more -->


<p>例えば、日本で作業してる場合は、<code>GMT+9</code>となり、標準時より9時間プラス、となる。<br/>
文字列からdatetime型に変更する際にはいくつか方法があるが、<code>valueOf</code>が簡単。<br/>
しかし例えば以下のようにすると意図しない時間が帰って来てしまう</p>

<pre><code>String test_str = '2014-12-1 05:30:18';
Datetime test_dt = Datetime.valueOf(test_str);
System.debug(test_dt);

//出力
// 2014-11-30 20:30:18
</code></pre>

<p>特に顕著な例だけど、月が変わってしまっている。<br/>
なぜかというと、Datetime型に変換する際に、(なぜか)GMTが考慮されて、標準時に戻して出力されるよう。<br/>
日本は+9時間なので、標準時は-9時間。<br/>
なので、指定した時間よりも９時間マイナスされた日時が返却される仕様。<br/>
このため、日付が変わり、その結果、月も変わってしまったという現象が起こる。<br/>
それを回避するにはちゃんとメソッドが用意されていて、<code>valueOfGmt</code>を使う。<br/>
これだと、設定しているGMTを使って(要するに入力された時間そのまま)、Datetimeを作成してくれる。</p>

<pre><code>String test_str = '2014-12-1 05:30:18';
Datetime test_dt = Datetime.valueOfGmt(test_str);
System.debug(test_dt);

//出力
// 2014-12-1 05:30:18
</code></pre>

<p>月まで変わると結構クリティカルだと思うので、要注意。</p>
]]></content>
  </entry>
  
</feed>
