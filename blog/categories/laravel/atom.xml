<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: laravel | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/laravel/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-08-17T15:37:09+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LaravelでCORSに対応する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/06/19/larave-cors/"/>
    <updated>2017-06-19T11:45:01+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/06/19/larave-cors</id>
    <content type="html"><![CDATA[<p>Laravelでクロスオリジン、CORS (Cross-Origin Resource Sharing) に対応する方法。<br/>
対応用のLaravelライブラリがあるのでそれを利用する。</p>

<!-- more -->


<p>JSからajaxなどで通信する場合、ドメインをまたいだ通信の場合(クロスオリジン)はセキュリティ上禁止されている。<br/>
ので、それを通信を受けるサーバーサイドで許可してやる。</p>

<h1>barryvdh/laravel-cors</h1>

<p>ライブラリがあるので、そちらを利用する。</p>

<h2>インストール</h2>

<p>Composerで導入する。</p>

<p><code>
$ composer require barryvdh/laravel-cors
</code></p>

<h2>セットアップ</h2>

<p><code>config/app.php</code>の <code>providers</code>の配列に以下を追加。</p>

<p><code>
Barryvdh\Cors\ServiceProvider::class,
</code></p>

<p><code>app/Http/Kernel.php</code> の <code>$middleware</code> に以下を追加。</p>

<p>```
protected $middleware = [</p>

<pre><code>// ...
\Barryvdh\Cors\HandleCors::class,
</code></pre>

<p>];
```</p>

<p>上記は全体に対応する場合。<br/>
もし、APIのみに許可したい場合は以下のようにする。</p>

<p>```
protected $middlewareGroups = [</p>

<pre><code>'web' =&gt; [
   // ...
],

'api' =&gt; [
    // ...
    \Barryvdh\Cors\HandleCors::class,
],
</code></pre>

<p>];
```</p>

<h2>設定ファイル</h2>

<p>設定ファイルを以下のコマンドで作成する。</p>

<p><code>
$ php artisan vendor:publish --provider="Barryvdh\Cors\ServiceProvider"
</code></p>

<p>以下の内容で作成される。</p>

<p>```
return [</p>

<pre><code> /*
 |--------------------------------------------------------------------------
 | Laravel CORS
 |--------------------------------------------------------------------------
 |
 | allowedOrigins, allowedHeaders and allowedMethods can be set to array('*')
 | to accept any value.
 |
 */
'supportsCredentials' =&gt; false,
'allowedOrigins' =&gt; ['*'],
'allowedHeaders' =&gt; ['Content-Type', 'X-Requested-With'],
'allowedMethods' =&gt; ['*'], // ex: ['GET', 'POST', 'PUT',  'DELETE']
'exposedHeaders' =&gt; [],
'maxAge' =&gt; 0,
</code></pre>

<p>]
```</p>

<ul>
<li><code>supportsCredentials</code> : クッキーやBasic認証の許可設定</li>
<li><code>allowedOrigins</code> : 許可するドメイン</li>
<li><code>allowedHeaders</code> : 許可するヘッダー</li>
<li><code>allowedMethods</code> : 許可するメソッド</li>
<li><code>exposedHeaders</code> : レスポンスに含める内容があれば</li>
</ul>


<p>それぞれ、 <code>*</code> とすれば全て許可する設定となる。<br/>
(<code>maxAge</code>はよくわからない…）</p>

<p>これで完了。</p>

<h1>CURLで確認</h1>

<p>curlで設定されているかどうかを確認する。</p>

<p><code>
$ curl -X GET -I -H "Origin: http://sample.jp" https://your-domain.com/your/api
</code></p>

<ul>
<li><code>-I</code> : Headerのみ取得し出力</li>
<li><code>-X</code> : アクションメソッドの指定</li>
<li><code>-H</code> : ヘッダの指定</li>
</ul>


<p>ヘッダの <code>Origin</code> に送信元のURLを指定する。<br/>
許可されているドメインの場合は、 <code>200</code> が返ってくるが、<br/>
許可されていない場合は、 <code>403</code> が返ってくる。</p>

<p>OKの場合のレスポンス</p>

<p><code>
HTTP/1.1 200 OK
Connection: keep-alive
Date: Mon, 19 Jun 2017 02:17:21 GMT
Server: Apache
Cache-Control: no-cache, private
Access-Control-Allow-Origin: http://sample.jp
Vary: Origin
Transfer-Encoding: chunked
Content-Type: application/json
Via: 1.1 vegur
</code></p>

<h1>参考</h1>

<ul>
<li><a href="http://qiita.com/bmf_san/items/a90255bf645890d96d0b">LaravelでCORS対応 &ndash; Qiita</a></li>
<li><a href="https://github.com/barryvdh/laravel-cors">barryvdh/laravel-cors: Adds CORS (Cross-Origin Resource Sharing) headers support in your Laravel application</a></li>
<li><a href="http://qiita.com/polikeiji/items/c8b79554015d75c073f8">curlでCORS設定を確認する &ndash; Qiita</a></li>
<li><a href="https://stackoverflow.com/questions/12173990/how-can-you-debug-a-cors-request-with-curl">How can you debug a CORS request with cURL? &ndash; Stack Overflow</a></li>
<li><a href="http://blog.toshimaru.net/s3-cloudfront-cors-setting/">AWS S3 + CloudFront のCORS設定手順 &ndash; Hack Your Design!</a></li>
<li><a href="http://www.minimalab.com/blog/2014/12/08/curl-option/">Curl の個人的によく使うオプションまとめ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravelで標準出力にエラーログを出力する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/06/16/larave-std-error/"/>
    <updated>2017-06-16T16:01:28+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/06/16/larave-std-error</id>
    <content type="html"><![CDATA[<p>HerokuでWebサイトを作る場合、ログの出力はPapertrailを入れることが多い、というか必ず利用しています。<br/>
Papertrailでは標準出力に出力したログは漏れなく拾ってくれるので、Laravelも標準出力にエラーログを出力するようにする方法を毎回ググルので備忘録。</p>

<!-- more -->


<h1>設定</h1>

<p>以下の記述を、<code>bootstrap/app.php</code> に追加します。</p>

<p>```
$app->configureMonologUsing(function ($monolog) {</p>

<pre><code>$monolog-&gt;pushHandler(new \Monolog\Handler\StreamHandler('php://stderr'));
</code></pre>

<p>});
```</p>

<h1>出力</h1>

<p>以下のようにすると出力可能です。</p>

<p><code>
Log::error('TEST LOG');
</code></p>

<h1>結果</h1>

<p>すると、以下のように出力されます。</p>

<p><code>
[2017-06-16 04:02:16] dev.ERROR: TEST LOG [] []
</code></p>

<p><code>dev.ERROR</code>の<code>dev</code>の部分は、環境変数の<code>APP_ENV</code>で設定している文字列が出ます。<br/>
なので、<code>dev.ERROR</code>とかでひっかけてPapertrailでアラートを設定してやれば自分で出力したエラーログで通知とかが出せたりします。</p>

<h1>参考</h1>

<p>以下、参考にしました。ありがとうございます。</p>

<ul>
<li><a href="http://qiita.com/iakio/items/86086e046f73826c9bef">Laravelのログを標準エラーに出力する &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Laravel]フォームのバリデーションをRequestクラスに分離する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/11/18/larave-request/"/>
    <updated>2016-11-18T17:46:52+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/11/18/larave-request</id>
    <content type="html"><![CDATA[<p>LaraveのバリデーションチェックをRequestクラスの別ファイルにまとめる方法。<br/>
すでに各所で解説が書かれているだろうけれど、自分なりに把握出来たのでメモ。</p>

<!-- more -->


<h1>作成</h1>

<h2>生成</h2>

<p><code>
$ php artisan make:request HogeRequest
</code></p>

<p>これで、<code>app/Http/Requests/</code>以下に生成される。</p>

<p>デフォルトで生成される内容は以下。</p>

<p>```
&lt;?php</p>

<p>namespace App\Http\Requests;</p>

<p>use App\Http\Requests\Request;</p>

<p>class HogeRequest extends Request
{</p>

<pre><code>/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    return false;
}

/**
 * Get the validation rules that apply to the request.
 *
 * @return array
 */
public function rules()
{
    return [
        //
    ];
}
</code></pre>

<p>}
```</p>

<h2>認証</h2>

<p>一つ目のメソッド、<code>authorize</code>はデフォルトでは<code>false</code>となっている。<br/>
これは、このフォームを送信出来るユーザの認証を判定する箇所で、デフォルトの<code>false</code>だと全てのユーザが弾かれてしまう。<br/>
なのでこれは<code>true</code>に変更する。</p>

<h2>バリデーションルール</h2>

<p>肝心のバリデーションルールは、<code>rules()</code>メソッド内の戻り値として書く。<br/>
配列にコントローラーに書いていた時と同じように書く。</p>

<p>例）</p>

<p>```
public function rules()
{</p>

<pre><code>return [
    'LastName' =&gt; 'required',
    'FirstName' =&gt; 'required',
    'Email' =&gt; 'required|email',
];
</code></pre>

<p>}
```</p>

<h2>項目の名前 (日本語化)</h2>

<p>バリデーションルールに引っかかった際に返されるエラーメッセージはデフォルトでは英語になっている。<br/>
これを日本語にするには、言語ファイルを用意してやるとよい。<br/>
<code>resouces/lang/ja/</code>以下に、<code>validation.php</code>を置いてやる。<br/>
以下が、デフォルトの英語ファイルを日本語訳してくれているもの。<br/>
<a href="https://gist.github.com/syokunin/b37725686b5baf09255b">https://gist.github.com/syokunin/b37725686b5baf09255b</a></p>

<p>しかしこのままだと、項目名についてはnameで指定したもののママになってしまう。<br/>
これをカスタムで日本語化するには、さきほど追加した、<code>validation.php</code>の<code>attributes</code>で指定してやる。</p>

<p>例）</p>

<p>```
&lsquo;attributes&rsquo; => [</p>

<pre><code>'title' =&gt; 'タイトル',
'body' =&gt; '本文',
'published_at' =&gt; '公開日',
</code></pre>

<p>],
```</p>

<ul>
<li><a href="https://laravel10.wordpress.com/2015/03/11/%E5%88%9D%E3%82%81%E3%81%A6%E3%81%AElaravel-5-19-%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8C%96/">初めてのLaravel 5.1 : (19) エラーメッセージの日本語化 &#8211; ララ帳</a></li>
</ul>


<p>ここでの設定は全体での適用となるので、一括指定出来る反面、切り分けが出来ない。<br/>
これを各フォーム個別の設定としてやるために、先ほどの、Requestクラスに追加してやることが可能。</p>

<p>例）</p>

<p>```
public function attributes()
{</p>

<pre><code>return [
    'name'    =&gt; 'お名前',
    'email'   =&gt; 'メールアドレス',
    'subject' =&gt; '件名',
    'content' =&gt; '内容',
];
</code></pre>

<p>}
```</p>

<ul>
<li><a href="http://qiita.com/ponko2/items/fd7ac38b964e10f16f52#%E3%81%8A%E5%95%8F%E3%81%84%E5%90%88%E3%82%8F%E3%81%9B%E7%94%BB%E9%9D%A2%E3%81%AErequest">Laravel 5で確認画面付き問い合わせフォームを作る &ndash; Qiita</a></li>
</ul>


<h2>戻り先</h2>

<p>デフォルトの状態では、バリデーションエラーがあった場合は一つ前のページへ自動的に遷移する。<br/>
入力 → 確認 という遷移なら、確認に遷移してきた時点でエラーが出ると、一つ前の入力ページへ飛ぶ。</p>

<p>しかし、確認画面を挟むようなフォームの場合、確認画面から完了画面の際にもバリデーションチェックが必要となる。<br/>
これがデフォルトのままだと、<br/>
確認 → 完了 という遷移となり、エラーが出ると一つ前の確認画面に戻ってしまう。<br/>
ここでは入力画面に戻って欲しい。</p>

<p>その場合、Requestクラスで戻り先を指定してやる事が出来る。</p>

<p><code>
protected $redirect = 'hoge_input';
</code></p>

<p>変数名で指定の仕方を変えてやることが可能。</p>

<ul>
<li><code>redirect</code> &ndash; URIでの指定</li>
<li><code>redirectRoute</code> &ndash; 名前付きルートの名前での指定</li>
<li><code>redirectAction</code> &ndash; コントローラーのアクションでの指定</li>
</ul>


<p>[参考]</p>

<ul>
<li><a href="http://n2utech.hatenablog.jp/entry/2015/11/13/154754">【メモ】 Laravel 5.1 において FormRequest でエラーが発生した際の戻し先を変更する &ndash; n2utech</a></li>
<li><a href="https://github.com/laravel/framework/blob/5.1/src/Illuminate/Foundation/Http/FormRequest.php#L34-L53">framework/FormRequest.php at 5.1 · laravel/framework · GitHub</a></li>
</ul>


<h1>完成</h1>

<p>最終的に以下のような形とした。</p>

<p>```
&lt;?php</p>

<p>namespace App\Http\Requests;</p>

<p>use App\Http\Requests\Request;</p>

<p>class HogeRequest extends Request
{</p>

<pre><code>/**
 * 戻り先
 *
 * @var string
 */
protected $redirect = 'hoge_input';

/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    return true;
}

/**
 * バリデーションルール
 *
 * @return array
 */
public function rules()
{
    return [
        'LastName' =&gt; 'required',
        'FirstName' =&gt; 'required',
        'Email' =&gt; 'required|email',
    ];
}

/**
 * エラー時に表示する項目名
 *
 * @return array
 */
public function attributes()
{
    return [
        'LastName' =&gt; '姓',
        'FirstName' =&gt; '名',
        'Email' =&gt; 'メールアドレス',
    ];
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SalesforceのREST API接続用のLaravelパッケージを使ってみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel/"/>
    <updated>2016-11-17T14:00:34+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/11/17/forrest-sfapi-laravel</id>
    <content type="html"><![CDATA[<p>Salesforce接続用のLaravel5パッケージ、<code>omniphx/forrest</code>を使ってみた。</p>

<!-- more -->


<h1>セットアップ</h1>

<p>Composerに追加。</p>

<p><code>
$ composer require "omniphx/forrest":"2.*"
</code></p>

<p><code>config/app.php</code>に以下を追加</p>

<p>```
&lsquo;providers&rsquo; => [
  // &hellip;
  Omniphx\Forrest\Providers\Laravel\ForrestServiceProvider::class,
  // &hellip;
],</p>

<p>&hellip;</p>

<p>&lsquo;aliases&rsquo; => [
  // &hellip;</p>

<pre><code>'Forrest' =&gt; Omniphx\Forrest\Providers\Laravel\Facades\Forrest::class
</code></pre>

<p>  // &hellip;
],
```
以下で設定ファイルを生成させる。</p>

<p><code>
$ php artisan vendor:publish
</code></p>

<h1>設定ファイル</h1>

<p>SFへの接続方法は２つから選択可能。</p>

<ul>
<li>Web Server authentication flow &ndash; 個別のSFアカウントでのログイン</li>
<li>Username-Password authentication flow &ndash; 接続用のアカウントを使用したログイン</li>
</ul>


<p>通常は、Username-Password authentication を利用する事が多い。</p>

<p><code>config/forrest.php</code>で以下を書き換え。</p>

<p><code>
//11行目
'authentication' =&gt; 'WebServer',
↓↓
'authentication' =&gt; 'UserPassword',
</code></p>

<p>あとは、<code>.env</code>ファイルでユーザ名やパスワード、アプリのキーなどを設定する。</p>

<p><code>
CONSUMER_KEY=xxx
CONSUMER_SECRET=xxx
LOGIN_URL=https://login.salesforce.com/
USERNAME=xxx
PASSWORD=xxx
</code></p>

<p><code>LOGIN_URL</code>を <code>https://test.salesforce.com/</code>としておくと常にsandboxへの接続となる。</p>

<h1>利用</h1>

<h2>ログイン</h2>

<p>以下でログイン。</p>

<p><code>
use Omniphx\Forrest\Providers\Laravel\Facades\Forrest;
...
Forrest::authenticate();
</code></p>

<p>(PHPStormの補完が効かない…）</p>

<h2>クエリの発行</h2>

<p><code>
Forrest::query('SELECT Id FROM Account');
</code></p>

<h2>レコードの作成など</h2>

<p>```
$body = [&lsquo;Name&rsquo; => &lsquo;New Account&rsquo;];
Forrest::sobjects(&lsquo;Account&rsquo;,[</p>

<pre><code>'method' =&gt; 'post',
'body'   =&gt; $body]);
</code></pre>

<p>```</p>

<p><code>sobjects</code>で第一引数にオブジェクトを指定し、第二引数に送信する内容を指定する。<br/>
送信内容は配列でキーを指定してやればよい。<br/>
<code>method</code>はそれぞれ以下。</p>

<ul>
<li>post &ndash; 作成</li>
<li>put &ndash; 更新</li>
<li>patch &ndash; アップサート</li>
<li>delete &ndash; 削除</li>
</ul>


<p>削除の場合は以下のようにREST形式でSFIDを指定してやる。</p>

<p><code>
Forrest::sobjects('Account/001i000000xxx', ['method' =&gt; 'delete']);
</code></p>

<h2>トークンの操作</h2>

<ul>
<li>リフレッシュ &ndash; <code>refresh()</code></li>
<li>廃止 &ndash; <code>revoke()</code></li>
</ul>


<h2>カスタムエンドポイント</h2>

<p>以下の様のして送信する。</p>

<p>```
Forrest::custom(&lsquo;/myEndpoint&rsquo;, [</p>

<pre><code>'method' =&gt; 'post',
'body' =&gt; ['foo' =&gt; 'bar'],
'parameters' =&gt; ['flim' =&gt; 'flam']]);
</code></pre>

<p>```</p>

<p>その他は、GitHubのReadme参照。</p>

<h1>参考</h1>

<ul>
<li><a href="https://github.com/omniphx/forrest">omniphx/forrest: Salesforce.com REST API Client for Laravel 5</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel HomesteadのPostgreSQLにPosticoから接続する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/06/09/homestead-postgres-via-homestead/"/>
    <updated>2016-06-09T14:56:23+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/06/09/homestead-postgres-via-homestead</id>
    <content type="html"><![CDATA[<p>まとまって情報がなかったのでメモ。</p>

<!-- more -->


<h1>SSH</h1>

<p>ssh接続する際のユーザー名・パスワードは、デフォルトでは、<code>vagrant/vagrant</code>のよう。
ユーザー名はホスト名とは別で、vagrantを立ち上げた状態で以下のコマンドで確認出来た。</p>

<p><code>
$ vagrant ssh-config
Host default
  HostName 127.0.0.1
  User vagrant
  Port 2222
  UserKnownHostsFile /dev/null
  StrictHostKeyChecking no
  PasswordAuthentication no
  IdentityFile /Users/USER_NAME/Vagrant/app_folder/.vagrant/machines/default/virtualbox/private_key
  IdentitiesOnly yes
  LogLevel FATAL
  ForwardAgent yes
</code></p>

<p>この中の、<code>User vagrant</code>という部分。</p>

<p>SSH Hostは、<code>Homestead.yaml</code>で指定したip。
デフォルトは、<code>192.168.10.10</code>だと思う。</p>

<p><code>
ip: "192.168.10.10"
</code></p>

<h1>Postgres</h1>

<p>Postgresはデフォルトでは以下の設定になっている。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left">ホスト名 </td>
<td align="left"> localhost </td>
</tr>
<tr>
<td></td>
<td align="left"> DB名 </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> ユーザー名 </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> パスワード </td>
<td align="left"> secret </td>
</tr>
</tbody>
</table>


<h1>Postico</h1>

<p>Posticoから接続する際には、Optionsから、<code>Connect via SSH</code>を選択してSSH接続設定をしておく。</p>

<table>
<thead>
<tr>
<th></th>
<th align="left"> 項目 </th>
<th align="left"> 内容 </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td align="left"> Nickname </td>
<td align="left"> (なんでも) </td>
</tr>
<tr>
<td></td>
<td align="left"> Host </td>
<td align="left"> localhost (デフォルト) </td>
</tr>
<tr>
<td></td>
<td align="left"> Port </td>
<td align="left"> 5432 (デフォルト) </td>
</tr>
<tr>
<td></td>
<td align="left"> User </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> Password </td>
<td align="left"> secret </td>
</tr>
<tr>
<td></td>
<td align="left"> Database </td>
<td align="left"> homestead </td>
</tr>
<tr>
<td></td>
<td align="left"> SSH Host </td>
<td align="left"> 192.168.10.10 </td>
</tr>
<tr>
<td></td>
<td align="left"> Port </td>
<td align="left"> 22 (デフォルト) </td>
</tr>
<tr>
<td></td>
<td align="left"> User </td>
<td align="left"> vagrant </td>
</tr>
<tr>
<td></td>
<td align="left"> Password </td>
<td align="left"> vagrant </td>
</tr>
<tr>
<td></td>
<td align="left"> Private Key </td>
<td align="left"> なし </td>
</tr>
</tbody>
</table>


<p><img src="/images/2016/06/postico_homestead.jpg" alt="" /></p>

<p>これで接続出来た。</p>

<h1>参考</h1>

<ul>
<li><a href="https://laravel.com/docs/5.1/homestead">Laravel Homestead</a></li>
<li><a href="http://qiita.com/megane42/items/1d8ae7444d8c1b10bbd7">Vagrant で作った VM にやってはいけない2つのこと &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
