<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: laravel | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/laravel/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2017-09-22T12:38:56+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Laravel] キューのsleepとtimeoutの関係]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/22/laravel-queue-sleep-timeout/"/>
    <updated>2017-09-22T12:16:53+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/22/laravel-queue-sleep-timeout</id>
    <content type="html"><![CDATA[<p>Laravelのキューを実際に使ってみた際にちょっと変な挙動だと思ったメモ。</p>

<!-- more -->


<h1>sleep</h1>

<p>キューを実行するコマンドのオプションに<code>sleep</code>というものがある。<br/>
コマンドのヘルプの説明は以下。</p>

<p><code>
--sleep[=SLEEP]      Number of seconds to sleep when no job is available [default: "3"]
</code></p>

<p>ジョブがない場合に次のジョブを取得するまでにスリープする秒数の設定、とのこと。<br/>
例えばこれをゼロにすると、常にジョブを取得するためのポーリングが実行され続けるため、ジョブの保存先をキューイングサービスなどにしている場合に、ものすごい数のキュー取得リクエストが飛んでしまう。<br/>
なのでsleepを設定してやれば(ジョブがなくなった時に)、ポーリング間隔を空ける事が出来るので負荷が減ったりする。</p>

<h1>timeout</h1>

<p>処理の<code>timeout</code>オプション。</p>

<p><code>
--timeout[=TIMEOUT]  The number of seconds a child process can run [default: "60"]
</code></p>

<p>処理に指定した時間以上の時間がかかった場合はタイムアウトとする設定。デフォルトは60秒。</p>

<h1>sleepとtimeoutの関係</h1>

<p>sleepの時間を長く設定すると、タイムアウトエラーが発生してしまう。<br/>
例えば以下。</p>

<p><code>
php artisan queue:listen --sleep=120 --timeout=60
</code></p>

<p>というのも、次のキュー取得を実行するまでのスリープ時間もタイムアウトの対象の時間に含まれてしまう、よう。<br/>
なので必ずsleep時間よりもtimeoutの時間を多く設定してやらないといけない。<br/>
上記の場合だと<code>sleep</code>を120秒にしてるので、<code>timeout</code>を(少なくとも)120秒より大きく設定しないといけない。</p>

<p><code>
php artisan queue:listen --sleep=120 --timeout=125
</code></p>

<p>これだと無事、動作する。<br/>
(処理内容に5秒以上かかると合計が125秒を越えてしまうのでタイムアウトになるが）</p>

<h1>疑問</h1>

<p>単にポーリングの待ち時間のはずなのに実行時間のタイムアウトの対象に含まれるのはおかしいのでは？という疑問はやはり出ていたようで、Githubのissueでやりとりがされていた。</p>

<p><a href="https://github.com/laravel/framework/issues/6206">queue:listen&#39;s sleep duration contributing towards timeout · Issue #6206 · laravel/framework</a></p>

<p>内容を読んでいくと、そもそものプロセスの処理に組み込まれてしまっているため、根本的な修正は難しく、timeoutの時間をsleep時間を足して設定してやる、とかしか無理じゃない？みたいなやり取りになっている。</p>

<p>そしてその後、5.1の時にtimeout時間をsleep時間よりも短く設定出来ないようにする制限が組み込まれたようだが、巨大な処理を行う場合にtimeoutをなしにするためにゼロ秒にセットしたいのに出来ない、という意見が出て結局削除されている。</p>

<p>結果、制約も入らず対処もされていないようなので、現状は前述のように、timeout時間をsleep時間より必ず大きく設定してやらないといけない、ということになっているよう。</p>

<h1>余談</h1>

<p>キューのサンプルを作っている時に事象に遭遇したのだけど、そのキューのサンプルはGitHubにあげてる。<br/>
HerokuButtonで起動できるようにしたりしてみたので、よかったらお試しあれ。</p>

<p><a href="https://github.com/k-usk/laravel-queue-sample">https://github.com/k-usk/laravel-queue-sample</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[heroku]PostgresとRedisの環境設定]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/09/21/heroku-postgres-redis/"/>
    <updated>2017-09-21T15:16:32+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/09/21/heroku-postgres-redis</id>
    <content type="html"><![CDATA[<p>LaravelをHerokuで使用する際に、Heroku PostgresとHeroku Redisの接続情報を環境変数から取得する設定のメモ。</p>

<!-- more -->


<h1>概要</h1>

<p>改めて。<br/>
Herokuでは標準のadd-onとして<a href="https://elements.heroku.com/addons/heroku-postgresql">Heroku Postgres</a>と<a href="https://elements.heroku.com/addons/heroku-redis">Heroku Redis</a>が用意されている。<br/>
クレジットカードさえ登録していれば無料で使えるので便利。</p>

<p>この接続情報はアドオンを登録した際に自動的に以下のような変数で登録がされる。</p>

<p><strong>Postgres</strong><br/>
<code>DATABASE_URL</code> = <code>postgres://username:password@hostname.amazonaws.com:5432/database</code></p>

<p><strong>Redis</strong><br/>
<code>REDIS_URL</code> = <code>redis://h:password@hostname.amazonaws.com:port_no</code></p>

<p>各種情報がURL形式で組み込まれているのだが、間違ってもこれを自分でバラしてそれぞれ個別に環境変数に入れる、などとしてはいけない。<br/>
というのも、この接続情報はPostgresやRedisにメンテナンスが入った際に前の接続情報は破棄され、新しい情報が同じ環境変数で設定されるため、<br/>
自前でバラして作ってしまうとその変更した情報に対応できなくなり、接続エラーとなってしまう。</p>

<p>よって、必ず自動でセットされる、<code>DATABASE_URL</code>や<code>REDIS_URL</code>を使うこと。<br/>
これはHerokuを使う際には常識として覚えておくこと。</p>

<h1>取得</h1>

<p>というわけで、それぞれの値を取得したURLからパースしてLaravel用に環境変数にセットする。<br/>
以下のように環境変数があればそれをパースして環境変数としてセットしてやるようにするのがスマートっぽい。<br/>
これだとローカルでは個別に<code>.env</code>ファイルで設定した値を使用してやることが出来る。</p>

<p><code>/config/database.php</code> の冒頭に書く。</p>

<p>```
//Postgres
if (getenv(&lsquo;DATABASE_URL&rsquo;)) {</p>

<pre><code>$url = parse_url(getenv('DATABASE_URL'));
putenv('DB_HOST='.$url['host']);
putenv('DB_PORT='.$url['port']);
putenv('DB_DATABASE='.substr($url["path"], 1));
putenv('DB_USERNAME='.$url["user"]);
putenv('DB_PASSWORD='.$url['pass']);
</code></pre>

<p>}</p>

<p>//Redis
if (getenv(&lsquo;REDIS_URL&rsquo;)) {</p>

<pre><code>$url = parse_url(getenv('REDIS_URL'));
putenv('REDIS_HOST='.$url['host']);
putenv('REDIS_PORT='.$url['port']);
putenv('REDIS_PASSWORD='.$url['pass']);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LaravelでCORSに対応する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/06/19/larave-cors/"/>
    <updated>2017-06-19T11:45:01+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/06/19/larave-cors</id>
    <content type="html"><![CDATA[<p>Laravelでクロスオリジン、CORS (Cross-Origin Resource Sharing) に対応する方法。<br/>
対応用のLaravelライブラリがあるのでそれを利用する。</p>

<!-- more -->


<p>JSからajaxなどで通信する場合、ドメインをまたいだ通信の場合(クロスオリジン)はセキュリティ上禁止されている。<br/>
ので、それを通信を受けるサーバーサイドで許可してやる。</p>

<h1>barryvdh/laravel-cors</h1>

<p>ライブラリがあるので、そちらを利用する。</p>

<h2>インストール</h2>

<p>Composerで導入する。</p>

<p><code>
$ composer require barryvdh/laravel-cors
</code></p>

<h2>セットアップ</h2>

<p><code>config/app.php</code>の <code>providers</code>の配列に以下を追加。</p>

<p><code>
Barryvdh\Cors\ServiceProvider::class,
</code></p>

<p><code>app/Http/Kernel.php</code> の <code>$middleware</code> に以下を追加。</p>

<p>```
protected $middleware = [</p>

<pre><code>// ...
\Barryvdh\Cors\HandleCors::class,
</code></pre>

<p>];
```</p>

<p>上記は全体に対応する場合。<br/>
もし、APIのみに許可したい場合は以下のようにする。</p>

<p>```
protected $middlewareGroups = [</p>

<pre><code>'web' =&gt; [
   // ...
],

'api' =&gt; [
    // ...
    \Barryvdh\Cors\HandleCors::class,
],
</code></pre>

<p>];
```</p>

<h2>設定ファイル</h2>

<p>設定ファイルを以下のコマンドで作成する。</p>

<p><code>
$ php artisan vendor:publish --provider="Barryvdh\Cors\ServiceProvider"
</code></p>

<p>以下の内容で作成される。</p>

<p>```
return [</p>

<pre><code> /*
 |--------------------------------------------------------------------------
 | Laravel CORS
 |--------------------------------------------------------------------------
 |
 | allowedOrigins, allowedHeaders and allowedMethods can be set to array('*')
 | to accept any value.
 |
 */
'supportsCredentials' =&gt; false,
'allowedOrigins' =&gt; ['*'],
'allowedHeaders' =&gt; ['Content-Type', 'X-Requested-With'],
'allowedMethods' =&gt; ['*'], // ex: ['GET', 'POST', 'PUT',  'DELETE']
'exposedHeaders' =&gt; [],
'maxAge' =&gt; 0,
</code></pre>

<p>]
```</p>

<ul>
<li><code>supportsCredentials</code> : クッキーやBasic認証の許可設定</li>
<li><code>allowedOrigins</code> : 許可するドメイン</li>
<li><code>allowedHeaders</code> : 許可するヘッダー</li>
<li><code>allowedMethods</code> : 許可するメソッド</li>
<li><code>exposedHeaders</code> : レスポンスに含める内容があれば</li>
</ul>


<p>それぞれ、 <code>*</code> とすれば全て許可する設定となる。<br/>
(<code>maxAge</code>はよくわからない…）</p>

<p>これで完了。</p>

<h1>CURLで確認</h1>

<p>curlで設定されているかどうかを確認する。</p>

<p><code>
$ curl -X GET -I -H "Origin: http://sample.jp" https://your-domain.com/your/api
</code></p>

<ul>
<li><code>-I</code> : Headerのみ取得し出力</li>
<li><code>-X</code> : アクションメソッドの指定</li>
<li><code>-H</code> : ヘッダの指定</li>
</ul>


<p>ヘッダの <code>Origin</code> に送信元のURLを指定する。<br/>
許可されているドメインの場合は、 <code>200</code> が返ってくるが、<br/>
許可されていない場合は、 <code>403</code> が返ってくる。</p>

<p>OKの場合のレスポンス</p>

<p><code>
HTTP/1.1 200 OK
Connection: keep-alive
Date: Mon, 19 Jun 2017 02:17:21 GMT
Server: Apache
Cache-Control: no-cache, private
Access-Control-Allow-Origin: http://sample.jp
Vary: Origin
Transfer-Encoding: chunked
Content-Type: application/json
Via: 1.1 vegur
</code></p>

<h1>参考</h1>

<ul>
<li><a href="http://qiita.com/bmf_san/items/a90255bf645890d96d0b">LaravelでCORS対応 &ndash; Qiita</a></li>
<li><a href="https://github.com/barryvdh/laravel-cors">barryvdh/laravel-cors: Adds CORS (Cross-Origin Resource Sharing) headers support in your Laravel application</a></li>
<li><a href="http://qiita.com/polikeiji/items/c8b79554015d75c073f8">curlでCORS設定を確認する &ndash; Qiita</a></li>
<li><a href="https://stackoverflow.com/questions/12173990/how-can-you-debug-a-cors-request-with-curl">How can you debug a CORS request with cURL? &ndash; Stack Overflow</a></li>
<li><a href="http://blog.toshimaru.net/s3-cloudfront-cors-setting/">AWS S3 + CloudFront のCORS設定手順 &ndash; Hack Your Design!</a></li>
<li><a href="http://www.minimalab.com/blog/2014/12/08/curl-option/">Curl の個人的によく使うオプションまとめ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravelで標準出力にエラーログを出力する]]></title>
    <link href="http://kayakuguri.github.io/blog/2017/06/16/larave-std-error/"/>
    <updated>2017-06-16T16:01:28+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2017/06/16/larave-std-error</id>
    <content type="html"><![CDATA[<p>HerokuでWebサイトを作る場合、ログの出力はPapertrailを入れることが多い、というか必ず利用しています。<br/>
Papertrailでは標準出力に出力したログは漏れなく拾ってくれるので、Laravelも標準出力にエラーログを出力するようにする方法を毎回ググルので備忘録。</p>

<!-- more -->


<h1>設定</h1>

<p>以下の記述を、<code>bootstrap/app.php</code> に追加します。</p>

<p>```
$app->configureMonologUsing(function ($monolog) {</p>

<pre><code>$monolog-&gt;pushHandler(new \Monolog\Handler\StreamHandler('php://stderr'));
</code></pre>

<p>});
```</p>

<h1>出力</h1>

<p>以下のようにすると出力可能です。</p>

<p><code>
Log::error('TEST LOG');
</code></p>

<h1>結果</h1>

<p>すると、以下のように出力されます。</p>

<p><code>
[2017-06-16 04:02:16] dev.ERROR: TEST LOG [] []
</code></p>

<p><code>dev.ERROR</code>の<code>dev</code>の部分は、環境変数の<code>APP_ENV</code>で設定している文字列が出ます。<br/>
なので、<code>dev.ERROR</code>とかでひっかけてPapertrailでアラートを設定してやれば自分で出力したエラーログで通知とかが出せたりします。</p>

<h1>参考</h1>

<p>以下、参考にしました。ありがとうございます。</p>

<ul>
<li><a href="http://qiita.com/iakio/items/86086e046f73826c9bef">Laravelのログを標準エラーに出力する &ndash; Qiita</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Laravel]フォームのバリデーションをRequestクラスに分離する]]></title>
    <link href="http://kayakuguri.github.io/blog/2016/11/18/larave-request/"/>
    <updated>2016-11-18T17:46:52+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2016/11/18/larave-request</id>
    <content type="html"><![CDATA[<p>LaraveのバリデーションチェックをRequestクラスの別ファイルにまとめる方法。<br/>
すでに各所で解説が書かれているだろうけれど、自分なりに把握出来たのでメモ。</p>

<!-- more -->


<h1>作成</h1>

<h2>生成</h2>

<p><code>
$ php artisan make:request HogeRequest
</code></p>

<p>これで、<code>app/Http/Requests/</code>以下に生成される。</p>

<p>デフォルトで生成される内容は以下。</p>

<p>```
&lt;?php</p>

<p>namespace App\Http\Requests;</p>

<p>use App\Http\Requests\Request;</p>

<p>class HogeRequest extends Request
{</p>

<pre><code>/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    return false;
}

/**
 * Get the validation rules that apply to the request.
 *
 * @return array
 */
public function rules()
{
    return [
        //
    ];
}
</code></pre>

<p>}
```</p>

<h2>認証</h2>

<p>一つ目のメソッド、<code>authorize</code>はデフォルトでは<code>false</code>となっている。<br/>
これは、このフォームを送信出来るユーザの認証を判定する箇所で、デフォルトの<code>false</code>だと全てのユーザが弾かれてしまう。<br/>
なのでこれは<code>true</code>に変更する。</p>

<h2>バリデーションルール</h2>

<p>肝心のバリデーションルールは、<code>rules()</code>メソッド内の戻り値として書く。<br/>
配列にコントローラーに書いていた時と同じように書く。</p>

<p>例）</p>

<p>```
public function rules()
{</p>

<pre><code>return [
    'LastName' =&gt; 'required',
    'FirstName' =&gt; 'required',
    'Email' =&gt; 'required|email',
];
</code></pre>

<p>}
```</p>

<h2>項目の名前 (日本語化)</h2>

<p>バリデーションルールに引っかかった際に返されるエラーメッセージはデフォルトでは英語になっている。<br/>
これを日本語にするには、言語ファイルを用意してやるとよい。<br/>
<code>resouces/lang/ja/</code>以下に、<code>validation.php</code>を置いてやる。<br/>
以下が、デフォルトの英語ファイルを日本語訳してくれているもの。<br/>
<a href="https://gist.github.com/syokunin/b37725686b5baf09255b">https://gist.github.com/syokunin/b37725686b5baf09255b</a></p>

<p>しかしこのままだと、項目名についてはnameで指定したもののママになってしまう。<br/>
これをカスタムで日本語化するには、さきほど追加した、<code>validation.php</code>の<code>attributes</code>で指定してやる。</p>

<p>例）</p>

<p>```
&lsquo;attributes&rsquo; => [</p>

<pre><code>'title' =&gt; 'タイトル',
'body' =&gt; '本文',
'published_at' =&gt; '公開日',
</code></pre>

<p>],
```</p>

<ul>
<li><a href="https://laravel10.wordpress.com/2015/03/11/%E5%88%9D%E3%82%81%E3%81%A6%E3%81%AElaravel-5-19-%E3%82%A8%E3%83%A9%E3%83%BC%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E6%97%A5%E6%9C%AC%E8%AA%9E%E5%8C%96/">初めてのLaravel 5.1 : (19) エラーメッセージの日本語化 &#8211; ララ帳</a></li>
</ul>


<p>ここでの設定は全体での適用となるので、一括指定出来る反面、切り分けが出来ない。<br/>
これを各フォーム個別の設定としてやるために、先ほどの、Requestクラスに追加してやることが可能。</p>

<p>例）</p>

<p>```
public function attributes()
{</p>

<pre><code>return [
    'name'    =&gt; 'お名前',
    'email'   =&gt; 'メールアドレス',
    'subject' =&gt; '件名',
    'content' =&gt; '内容',
];
</code></pre>

<p>}
```</p>

<ul>
<li><a href="http://qiita.com/ponko2/items/fd7ac38b964e10f16f52#%E3%81%8A%E5%95%8F%E3%81%84%E5%90%88%E3%82%8F%E3%81%9B%E7%94%BB%E9%9D%A2%E3%81%AErequest">Laravel 5で確認画面付き問い合わせフォームを作る &ndash; Qiita</a></li>
</ul>


<h2>戻り先</h2>

<p>デフォルトの状態では、バリデーションエラーがあった場合は一つ前のページへ自動的に遷移する。<br/>
入力 → 確認 という遷移なら、確認に遷移してきた時点でエラーが出ると、一つ前の入力ページへ飛ぶ。</p>

<p>しかし、確認画面を挟むようなフォームの場合、確認画面から完了画面の際にもバリデーションチェックが必要となる。<br/>
これがデフォルトのままだと、<br/>
確認 → 完了 という遷移となり、エラーが出ると一つ前の確認画面に戻ってしまう。<br/>
ここでは入力画面に戻って欲しい。</p>

<p>その場合、Requestクラスで戻り先を指定してやる事が出来る。</p>

<p><code>
protected $redirect = 'hoge_input';
</code></p>

<p>変数名で指定の仕方を変えてやることが可能。</p>

<ul>
<li><code>redirect</code> &ndash; URIでの指定</li>
<li><code>redirectRoute</code> &ndash; 名前付きルートの名前での指定</li>
<li><code>redirectAction</code> &ndash; コントローラーのアクションでの指定</li>
</ul>


<p>[参考]</p>

<ul>
<li><a href="http://n2utech.hatenablog.jp/entry/2015/11/13/154754">【メモ】 Laravel 5.1 において FormRequest でエラーが発生した際の戻し先を変更する &ndash; n2utech</a></li>
<li><a href="https://github.com/laravel/framework/blob/5.1/src/Illuminate/Foundation/Http/FormRequest.php#L34-L53">framework/FormRequest.php at 5.1 · laravel/framework · GitHub</a></li>
</ul>


<h1>完成</h1>

<p>最終的に以下のような形とした。</p>

<p>```
&lt;?php</p>

<p>namespace App\Http\Requests;</p>

<p>use App\Http\Requests\Request;</p>

<p>class HogeRequest extends Request
{</p>

<pre><code>/**
 * 戻り先
 *
 * @var string
 */
protected $redirect = 'hoge_input';

/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    return true;
}

/**
 * バリデーションルール
 *
 * @return array
 */
public function rules()
{
    return [
        'LastName' =&gt; 'required',
        'FirstName' =&gt; 'required',
        'Email' =&gt; 'required|email',
    ];
}

/**
 * エラー時に表示する項目名
 *
 * @return array
 */
public function attributes()
{
    return [
        'LastName' =&gt; '姓',
        'FirstName' =&gt; '名',
        'Email' =&gt; 'メールアドレス',
    ];
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
