<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apex | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/apex/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2015-04-01T19:31:01+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[salesforce]Apex REST作成時のtips]]></title>
    <link href="http://kayakuguri.github.io/blog/2015/03/27/apex-rest-tips/"/>
    <updated>2015-03-27T19:45:44+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2015/03/27/apex-rest-tips</id>
    <content type="html"><![CDATA[<p>最近よくApexRESTを作成していて、<br/>
その中でちょっとしたtipsというかメモをメモっておきます。</p>

<!-- more -->


<h2>エンドポイント</h2>

<p>エンドポイントの指定には以下のように書きます。</p>

<pre><code>@RestResource(urlMapping='/User/Login')
</code></pre>

<p>この時に、<code>*</code>を使う事も出来ます。</p>

<pre><code>@RestResource(urlMapping='/User/*')
</code></pre>

<p>なので、ここにユーザーIDを入れたりして、そのIDを取得することで、<br/>
よりREST APIらしい(?)挙動でAPIを作成する事が出来ます。<br/>
apex側で送信されたIDを取得するには、以下のように<code>/</code>で区切って取得します。</p>

<pre><code>String accountId = req.requestURI.substring(req.requestURI.lastIndexOf('/')+1);
</code></pre>

<p>公式のドキュメントに正にこのままの内容が載っていました。</p>

<p><a href="https://www.salesforce.com/us/developer/docs/apexcode/Content/apex_rest_code_sample_basic.htm">Apex REST Basic Code Sample</a></p>

<h2>JSON</h2>

<p>返却するJSONの形式ですが、クラスの入れ子や、<code>List</code>を活用することで<br/>
かなり自由度高く作成出来ます。</p>

<p>例えば、以下のようなJSONを返すとします。</p>

<p>```
&ldquo;success&rdquo;:1,
&ldquo;User&rdquo; : {</p>

<pre><code>"user_id": xxx,
"hobby":[
    {"name":"映画", "level":"3"},
    {"name":"サッカー", "level":"1"}
]
</code></pre>

<p>},
&ldquo;request_time&rdquo;: &ldquo;2015-3-27 12:33&rdquo;
```</p>

<p>この場合、以下のようにクラスを複数作り、入れ子構造を作る事で作成出来ます。</p>

<p>```
global class UserData{</p>

<pre><code>global String user_id;
global HobbyData hobby
</code></pre>

<p>}
global class HobbyData{</p>

<pre><code>global String name;
global String level;
</code></pre>

<p>}
global class resultData{</p>

<pre><code>global Integer success;
global UserData User;
global String request_time;
</code></pre>

<p>}
```</p>

<p>作成するときは以下のような感じで。</p>

<p>```
List<HobbyData> hobbies = new List<HobbyData>();
HobbyData hobby1 = new HobbyData();
hobby1.name = &lsquo;映画&rsquo;;
hobby1.level = &lsquo;3&rsquo;;
hobbies.add(hobby1);
HobbyData hobby2 = new HobbyData();
hobby2.name = &lsquo;サッカー&rsquo;;
hobby2.level = &lsquo;1&rsquo;;
hobbies.add(hobby2);</p>

<p>UserData user = new UserData();
user.user_id = &lsquo;xxx&rsquo;;
user.hobby = hobbies;</p>

<p>resultData result = new resultData();
result.success = 1;
result.User = user;
result.request_time = &lsquo;2015-3-27 12:33&rsquo;;</p>

<p>return result;
```</p>

<p>地道な作業にはなりますが、これでわりかし綺麗なJSONが返せました。<br/>
もっと簡単な方法があったらまた書きます。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apexのテストで変数部分にテストが通ってくれない時]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/12/02/apex-json-class-test/"/>
    <updated>2014-12-02T18:41:35+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/12/02/apex-json-class-test</id>
    <content type="html"><![CDATA[<p>きっと基本を理解してないんだと思いますが、単純な話でした。</p>

<!-- more -->


<p>JsonをGETで引き渡して、それをApexクラスにしてapex内で使用するべく、<br/>
apex2Jsonとして以下のようなクラスを作成していた。</p>

<pre><code>public class Json2Apex{
    public String user_id;
    public String dummy;

    public static Json2Apex parse(String json){
        return (Json2Apex) System.JSON.deserialize(json, Json2Apex.class);
    }
}
</code></pre>

<p>ちゃんとJSONには、<code>user_id</code>と<code>dummy</code>の値を持たせて変換させ、<br/>
その変数にもきっちりアクセスした状態でも、テストを走らせてみると、<br/>
<code>parse</code>メソッド部分しか通ってない。<br/>
全体の行数が少ないので、パーセンテージとしては、<strong>50%</strong>。<br/>
これでは他のリリースに影響が大なので、調べてみると、単純な事で、<br/>
<code>{get; set;}</code>をつけろ、ってだけだった。<br/>
以下のようにつける。</p>

<pre><code>public String user_id{get; set;}
public String dummy{get; set;}
</code></pre>

<p>これだけでテストコードも変更することなく通り、無事、100%を達成できました。</p>

<p>参考：<a href="http://salesforce.stackexchange.com/questions/10018/testing-apex-classes-created-by-jsontoapex">http://salesforce.stackexchange.com/questions/10018/testing-apex-classes-created-by-jsontoapex</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文字列をDatetime型に変換する時の注意点]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/12/01/apex-datetime-gmt/"/>
    <updated>2014-12-01T12:53:59+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/12/01/apex-datetime-gmt</id>
    <content type="html"><![CDATA[<p>apexにて、文字列からDatetime型に変更した際の注意点。</p>

<!-- more -->


<p>例えば、日本で作業してる場合は、<code>GMT+9</code>となり、標準時より9時間プラス、となる。<br/>
文字列からdatetime型に変更する際にはいくつか方法があるが、<code>valueOf</code>が簡単。<br/>
しかし例えば以下のようにすると意図しない時間が帰って来てしまう</p>

<pre><code>String test_str = '2014-12-1 05:30:18';
Datetime test_dt = Datetime.valueOf(test_str);
System.debug(test_dt);

//出力
// 2014-11-30 20:30:18
</code></pre>

<p>特に顕著な例だけど、月が変わってしまっている。<br/>
なぜかというと、Datetime型に変換する際に、(なぜか)GMTが考慮されて、標準時に戻して出力されるよう。<br/>
日本は+9時間なので、標準時は-9時間。<br/>
なので、指定した時間よりも９時間マイナスされた日時が返却される仕様。<br/>
このため、日付が変わり、その結果、月も変わってしまったという現象が起こる。<br/>
それを回避するにはちゃんとメソッドが用意されていて、<code>valueOfGmt</code>を使う。<br/>
これだと、設定しているGMTを使って(要するに入力された時間そのまま)、Datetimeを作成してくれる。</p>

<pre><code>String test_str = '2014-12-1 05:30:18';
Datetime test_dt = Datetime.valueOfGmt(test_str);
System.debug(test_dt);

//出力
// 2014-12-1 05:30:18
</code></pre>

<p>月まで変わると結構クリティカルだと思うので、要注意。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[salesforce]apex Rest APIでPOSTでデータを送信する]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/10/27/apex-rest-post/"/>
    <updated>2014-10-27T18:49:51+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/10/27/apex-rest-post</id>
    <content type="html"><![CDATA[<p>getでは送信したデータはすぐに取得できたのですが、<br/>
postでの送信方法とデータ取得方法がわからずに迷走しまいした。<br/>
結論は、送信側の話、だったのですが。</p>

<!-- more -->


<p>GETの場合は以下のコードで取得可能でした。<br/>
簡単。</p>

<p>送信データ</p>

<pre><code>?userid=123&amp;name=hoge
</code></pre>

<p>apex</p>

<pre><code>@RestResource(urlMapping='/GetDataSample/test')

global with sharing class GetDataSampleAPI {
    @HttpGet
    global static String doGet(){
        RestRequest req = RestContext.request;
        String userid = req.params.get('userid');
        String name = req.params.get('hoge');
    }
}
</code></pre>

<p>実は、POSTの場合も、apexのコードは全く同じで取得する事が出来ました。<br/>
以下、取得出来たコードです。</p>

<pre><code>@RestResource(urlMapping='/GetDataSample/test')

global with sharing class GetDataSampleAPI {
    @HttpPost
    global static String doPost(){
        RestRequest req = RestContext.request;
        String userid = req.params.get('userid');
        String name = req.params.get('hoge');
    }
}
</code></pre>

<p>ただし、送信する際にヘッダーを正しく指定してやったり、送信形式に注意してやる必要がありました。<br/>
PHPのcurlで実装していたのですが、大いに迷走していたのは、salesforce側の話ではなく、<br/>
PHPでの送信方法の問題でしたとさ…。</p>

<p>送信出来たコード<br/>
(<a href="https://github.com/nkjm/Force.com-OAuth-Toolkit-for-PHP">このライブラリ</a>を使用して送信する前提)</p>

<pre><code>$url = "$oauth-&gt;instance_url/services/apexrest/GetDataSample/test";
$curl = curl_init($url);

$POST_DATA = array(
    'userid' =&gt; '123',
    'hoge' =&gt; 'fugafuga'
);

curl_setopt($curl, CURLOPT_POST, TRUE);
curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($POST_DATA));
curl_setopt($curl, CURLOPT_HEADER, false);
curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
curl_setopt($curl, CURLOPT_HTTPHEADER, array('Content-type: application/x-www-form-urlencoded;charset=UTF-8', "Authorization: OAuth " . $oauth-&gt;access_token));

$output= curl_exec($curl);
curl_close($curl);
</code></pre>

<p>ポイントは以下の２つです。</p>

<p>１）<br/>
<code>Content-type</code>を、<code>application/x-www-form-urlencoded</code>という、POSTでデータを送信する際の標準タイプを指定しています。<br/>
通常はデフォルトでこれなのですが、salesforceのAPIにPOSTする場合は明示的に指定してやる必要があるようです。(たぶん)<br/>
ちなみに、apex restは、<code>multipart/form-data</code>タイプはサポートしていないようです。</p>

<p>２）<br/>
１のタイプで指定してやると、送信するデータは<code>userid=123&amp;hoge=fugafuga</code>のように、GETと同じ形で取得できるようになるようです。<br/>
なので送信する際にそのような形に変換してやる必要があるようで、それが以下の記述となります。</p>

<pre><code>curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($POST_DATA));
</code></pre>

<h3>参考</h3>

<p><a href="http://qiita.com/khirose/items/870ffec6ce4562f54c9d">PHP小ネタ &ndash; PHPのcurlでPOST &ndash; Qiita</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[apexで割り算をしたら整数になった]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/10/21/apex-decimal/"/>
    <updated>2014-10-21T16:44:39+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/10/21/apex-decimal</id>
    <content type="html"><![CDATA[<p>タイトル通り、apex上で割り算をしたら整数になってしまったんですね。<br/>
単純に型付け言語による仕様だったのですが、ちょっとハマったのでメモ。</p>

<!-- more -->


<p>最初、記述したのが以下のコード</p>

<pre><code>Decimal a = 1 / 2;
System.debug(a);  //0
</code></pre>

<p>これだと、<code>0</code>が出力されます。<br/>
<code>Decimal</code>は小数まで表示できる型なのになんで？？？<br/>
と思ったんですが、計算している、<code>1</code>とか<code>2</code>が、<code>Integer</code>型、ってことなんですね。<br/>
なので、これを<code>Decimal</code>型にしてやると計算できます。</p>

<pre><code>Decimal a = Decimal.valueOf(1) / Decimal.valueOf(2);
System.debug(a);  //0.5
</code></pre>

<p>しかし数字を書きたいだけなのにいちいちキャストするのはめんどう。<br/>
なので、以下でも大丈夫。</p>

<pre><code>Decimal a = 1.0 / 2.0;
System.debug(a);  //0.5
</code></pre>

<p>小数点をつけると<code>Decimal</code>型になるようです。</p>

<p>ちなみにやりたかったことは、<code>Datetime</code>型の現在時間を日本時間(GMT+9)で表示することです。</p>

<pre><code>Datetime.now() + (9.0/24.0)
</code></pre>

<p><code>Datetime</code>型の足し算は1日単位で行われるため、24で割ると時間になります。<br/>
しかし、小数点にしないと<code>0</code>になってしまい計算できませんでした。<br/>
<code>format</code>をつかってフォーマットしてしまうと文字列になってしまうため、足し算で対応しています。</p>

<p>・<code>format</code>を使った場合</p>

<pre><code>Datetime.now().format('yyyy-MM-dd hh:mm', 'JST');
</code></pre>

<p><a href="https://sites.google.com/site/odekakeshimasyo/salesforceapexdatetime">Salesforce Apex 日付 時間 &ndash; おでかけしましょ</a></p>
]]></content>
  </entry>
  
</feed>
