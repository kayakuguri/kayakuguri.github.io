<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: heroku | KayaMemo]]></title>
  <link href="http://kayakuguri.github.io/blog/categories/heroku/atom.xml" rel="self"/>
  <link href="http://kayakuguri.github.io/"/>
  <updated>2014-11-13T17:46:41+09:00</updated>
  <id>http://kayakuguri.github.io/</id>
  <author>
    <name><![CDATA[萱潜]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[heroku]herokuでのSSL設定とカスタムサブドメインの適用方法]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/09/30/heroku-ssl-subdomain/"/>
    <updated>2014-09-30T19:24:37+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/09/30/heroku-ssl-subdomain</id>
    <content type="html"><![CDATA[<p>herokuでのSSL設定とカスタムサブドメインの設定をさっくりと調べてみた。</p>

<!-- more -->


<h2>SSL</h2>

<h3>手順</h3>

<ol>
<li>プライベートキーを作成</li>
<li>CSRを作成</li>
<li>CSRを契約の際に業者に提出</li>
<li>証明書が発行される</li>
<li>証明書 + 中間証明書 + プライベートキーをherokuに設定</li>
</ol>


<p>1はローカルPC上にて作成<br/>
2の作成方法は以下、など。
<a href="https://jp.globalsign.com/support/ssl/list.php?cat=csr">https://jp.globalsign.com/support/ssl/list.php?cat=csr</a><br/>
5のみ、heroku上。</p>

<h3>herokuでの操作</h3>

<p>SSLのアドオン($20/mo)<br/>
<a href="https://addons.heroku.com/ssl">https://addons.heroku.com/ssl</a></p>

<p>アドオンの追加</p>

<pre><code>$ heroku addons:add ssl:endpoint
</code></pre>

<p>サーバー証明書と中間証明書を合体させる</p>

<pre><code>$ cat chain_ca.pem &gt;&gt; server.crt
</code></pre>

<p>プライベートキーのパスフレーズが解除されていない場合は解除する。</p>

<pre><code>$ openssl rsa -in site.key -out server.key
Enter pass phrase for site.key:
writing RSA key
</code></pre>

<p>で、合体させた証明書とキーをアップする。</p>

<pre><code>$ heroku certs:add server.crt server.key
</code></pre>

<p>アップロード結果で返ってくるURLが証明書が適応されたURLとなる。<br/>
<code>hokkaido-1212.herokussl.com</code><br/>
この状態でアクセスすると、<code>No such app</code>と出るがこれで正しい。</p>

<h3>参考</h3>

<p><a href="http://qiita.com/yu1ch1/items/290efb666209354e8fb3">herokuのssl証明書を更新する</a><br/>
<a href="http://interu.hatenablog.com/entry/2012/07/25/184812">HerokuでカスタムドメインのSSL endpointを利用する方法</a><br/>
<a href="http://d.hatena.ne.jp/install-memo/20110906/1315291837">SSL証明書のKEYファイル・CSRファイル・CRTファイルのチェック方法</a></p>

<h2>サブドメイン</h2>

<h3>herokuでの操作</h3>

<p>herokuのアプリのSettings内にある、<br/>
Domains、から設定したいドメインを指定する。</p>

<p><img src="/images/2014/09/Settings___Heroku.jpg" alt="Settings___Heroku" /></p>

<p>契約しているドメイン業者のCNAMEに、適用したいアプリのURLを指定する。<br/>
例：<code>hoge.herokuapp.com</code></p>

<h3>SSLの場合</h3>

<p>SSLをカスタムドメインで使用したい場合は、上記SSLの項で設定した、<br/>
<code>hokkaido-1212.herokussl.com</code>のドメインをCNAMEに指定する。</p>

<p>反映後、設定の確認は以下で出来る。</p>

<pre><code>$ heroku certs
Endpoint                     Common Name(s)            Expires               Trusted
---------------------------  ------------------------  --------------------  -------
hokkaido-1212.herokussl.com  secure.example.co.jp  2015-06-24 23:59 UTC  True
</code></pre>

<p>詳細は、<code>heroku certs:info</code>で確認できる。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[heroku]QuotaGuard Staticを使ってHerokuでのIP固定を試してみる]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/09/26/static-ip-heroku/"/>
    <updated>2014-09-26T17:59:42+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/09/26/static-ip-heroku</id>
    <content type="html"><![CDATA[<p>herokuでのIP固定といえば、<a href="https://addons.heroku.com/proximo">Proximo</a>の方が有名っぽいけど、<br/>
QuotaGuard Staticというのでも同じく固定できるようなので試してみた。</p>

<!-- more -->


<p><img src="/images/2014/09/quotaguard1.jpg" alt="QuotaGuard Static add-on" /></p>

<p><a href="https://addons.heroku.com/quotaguardstatic">QuotaGuard Static</a></p>

<p>アプリへのセットアップをコマンドラインからする場合は以下。<br/>
無料プランがあるので、それで試してみる。</p>

<pre><code>$ heroku addons:add quotaguardstatic
</code></pre>

<p>以下のように結果が返ってくる。<br/>
その中にIPアドレスも含まれる。</p>

<pre><code>Adding quotaguardstatic on static-ip-test... done, v4 (free)
Your static IPs are [54.88.136.216, 54.84.188.199]
Use `heroku addons:docs quotaguardstatic` to view documentation.
</code></pre>

<p>Proximoでも同じ仕組のようだけど、<br/>
入れたアドオンによって指定されたURLを介してアクセスすることで<br/>
固定IPを実現しているよ。<br/>
アドオンがプロキシの役目を果たす。<br/>
このプロキシ経由でのアクセス数に制限があり、その数で値段が変わる仕組み。</p>

<p>そのアクセス用のURLは環境変数に格納されている。</p>

<pre><code>$ heroku config
QUOTAGUARDSTATIC_URL: http://username:pass@us-east-1-static-brooks.quotaguard.com:9293
</code></pre>

<p>上記、<code>IPs</code>となっているのは、２つのIPのうちどちらかでアクセスされる、とのこと。<br/>
負荷分散のよう。<br/>
一応、公式の理由。</p>

<blockquote><p>We believe all apps should be built for scalability and high availability. Our commitment to this means we only provide load balanced, high availability services. Load balancing our nodes allows one node to fail or be brought down for maintenance with no impact to your application. Each IP you are given represents one proxy node that is running behind a load balancer.</p></blockquote>

<p>IPアドレスはアドオンのダッシュボードからも確認できる。<br/>
以下、ダッシュボードを開くコマンド</p>

<pre><code>$ heroku addons:open quotaguardstatic
</code></pre>

<p>公式にPHPでの動作サンプルが載っていたのでそのまま使用して試してみた。<br/>
以下、転載。</p>

<p><a href="https://devcenter.heroku.com/articles/quotaguardstatic#using-with-php">PHPのサンプル</a></p>

<pre><code>&lt;?php

function lookup(){
  $quotaguard_env = getenv("QUOTAGUARDSTATIC_URL");
  $quotaguard = parse_url($quotaguard_env);

  $proxyUrl       = $quotaguard['host'].":".$quotaguard['port'];
  $proxyAuth       = $quotaguard['user'].":".$quotaguard['pass'];

  $url = "http://ip.jsontest.com/";

  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($ch, CURLOPT_PROXY, $proxyUrl);
  curl_setopt($ch, CURLOPT_PROXYAUTH, CURLAUTH_BASIC);
  curl_setopt($ch, CURLOPT_PROXYUSERPWD, $proxyAuth);
  $response = curl_exec($ch);
  return $response;
}

$res = lookup();
print_r($res);

?&gt;
</code></pre>

<p>ここでアクセスしている<code>http://ip.jsontest.com/</code>のURLは、接続元のIPアドレスをJsonで返してくれるサービスのよう。</p>

<p>アクセスすると、以下のようなJSONが返ってきた。</p>

<pre><code>{"ip": "54.84.188.199"}
</code></pre>

<p>リロードすると以下のものとランダムに切り替わっているのが確認できる。</p>

<pre><code>{"ip": "54.88.136.216"}
</code></pre>

<p>管理画面を確認すると、アクセス数と残りアクセス数がわかる。<br/>
アクセス数は、１月の制限のよう。<br/>
無料の場合は250/月。</p>

<p><img src="/images/2014/09/quotaguard2.jpg" alt="管理画面" /></p>

<p>冒頭のProximoと比較すべく、料金表を抜き出してみた。</p>

<p><strong>QuotaGuard Static</strong></p>

<table>
<thead>
<tr>
<th>プラン </th>
<th> 値段(月) </th>
<th> アクセス数(月) </th>
<th> 帯域幅</th>
</tr>
</thead>
<tbody>
<tr>
<td>Starter </td>
<td> 無料 </td>
<td> 250 </td>
<td> 100MB</td>
</tr>
<tr>
<td>Spike </td>
<td> $5 </td>
<td> 500 </td>
<td> 250MB</td>
</tr>
<tr>
<td>Micro </td>
<td> $19 </td>
<td> 10,000 </td>
<td> 1GB</td>
</tr>
<tr>
<td>Medium </td>
<td> $49 </td>
<td> 50,000 </td>
<td> 10GB</td>
</tr>
<tr>
<td>Large </td>
<td> $89 </td>
<td> 1000,000 </td>
<td> 50GB</td>
</tr>
<tr>
<td>Enterprise </td>
<td> $219 </td>
<td> 1,000,000 </td>
<td> 1TB</td>
</tr>
<tr>
<td>Premium </td>
<td> $399 </td>
<td> 5,000,000 </td>
<td> 無制限</td>
</tr>
</tbody>
</table>


<p><strong>Proximo</strong></p>

<table>
<thead>
<tr>
<th>プラン </th>
<th> 値段(月) </th>
<th> アクセス数(月) </th>
<th> 帯域幅</th>
</tr>
</thead>
<tbody>
<tr>
<td>Development </td>
<td> $5 </td>
<td> 1,000 </td>
<td> 500MB</td>
</tr>
<tr>
<td>Starter </td>
<td> $25 </td>
<td> 20,000 </td>
<td> 2GB</td>
</tr>
<tr>
<td>Professional </td>
<td> $75 </td>
<td> 200,000 </td>
<td> 100GB</td>
</tr>
<tr>
<td>Dedicated </td>
<td> $250 </td>
<td> 1,000,000 </td>
<td> 1TB</td>
</tr>
<tr>
<td>Elite </td>
<td> $500 </td>
<td> 5,000,000 </td>
<td> 5TB</td>
</tr>
<tr>
<td>Enterprise </td>
<td> $1250 </td>
<td> 無制限 </td>
<td> 無制限</td>
</tr>
</tbody>
</table>


<p>QuotaGuardは無料があるのがやはりお手軽。<br/>
しかし、安いうちはProximoの方がお得。<br/>
増えてくるとQuotaGuardの方がお得かも。<br/>
他の機能もあったりするので一概には言えないけれど。</p>

<h3>参考</h3>

<p><a href="https://devcenter.heroku.com/articles/quotaguardstatic">QuotaGuard Static 公式ドキュメント</a><br/>
<a href="https://devcenter.heroku.com/articles/proximo">Proximo 公式ドキュメント</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[エラー] bad line length character: Sysl]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/07/28/git-heroku-error/"/>
    <updated>2014-07-28T12:39:54+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/07/28/git-heroku-error</id>
    <content type="html"><![CDATA[<p>とあるタイミングでheroku上のgitからフェッチしようとすると、<br/>
タイトルのようなエラーが出た。</p>

<!-- more -->


<p>エラー内容。</p>

<pre><code>$ git fetch staging
Fetching repositoryfatal: protocol error: bad line length character: Sysl
</code></pre>

<p>環境は、herokuで、<a href="http://kayakuguri.github.io/blog/2014/07/02/heroku-staging/">ここで書いた</a>とおり、ローカルでブランチを切って、<br/>
それぞれのブランチでリモートのプッシュ先を変えて管理している。<br/>
ここでは、staging環境の分をフェッチしたかった。</p>

<p>heroku関連として全く同じ内容のエラーがStackOverFlowに投稿されていたが、<br/>
どうやら解決はしていないよう。</p>

<p><a href="http://stackoverflow.com/questions/23034100/git-error-bad-line-length-character-sysl">Git Error: bad line length character: Sysl</a></p>

<p>ググってみると、リモート先のサーバーにsshでログインする時に表示されるメッセージが悪いとか、<br/>
ssh関連で、<code>.bashrc</code>とか<code>.zshrc</code>とかの設定を見なおしたよ、というような内容が多い。</p>

<p><a href="http://d.hatena.ne.jp/kuromoyo/20120217/1329460576">protocol error: bad line length character と出たら &ndash; #9 Backyard</a><br/>
<a href="http://verytired.hateblo.jp/entry/2013/07/10/191324">gitのエラー解決方法 &ndash; Shut the fuck up and write some code</a><br/>
<a href="http://kimoi.hatenadiary.com/entry/20130701/1372693974">fatal: protocol error: bad line length character: # Us &ndash; きもい交換日記</a></p>

<p>しかしどれもピンと来ない。</p>

<p>とりあえず、master環境に切り替えてみよう(理由はない)と思い、変更してみると以下のエラー。</p>

<pre><code>$ git checkout master
fatal: This operation must be run in a work tree
</code></pre>

<p>ググると以下の情報が。<br/>
<a href="http://dqn.sakusakutto.jp/2012/09/git-bare-checkout-This-operation-must-be-run-in-a-work-tree.html">#git bareレポジトリでcheckoutしようとして&quot;This operation must be run in a work tree&quot;の対処法 &ndash; DQNEO起業日記</a></p>

<p>内容通り、以下のコマンドで切り替えは出来た。</p>

<pre><code>$ git symbolic-ref HEAD refs/heads/master
</code></pre>

<p>ただし、またstagingに戻そうとすると、上記のコマンドが必要になる。。</p>

<p>ターミナルだけでなく、gitはsourceTreeでも管理しているのだけれど、<br/>
そのソフト上では、ブランチの切り替えはダブルクリックだけで簡単に出来た。</p>

<p>そんな感じで、ブランチの切り替えをしていると、自動的にstaging環境でフェッチが行われていた。<br/>
流れとしてはこんな感じ。</p>

<blockquote><p>stagigブランチ<br/>
masterブランチに切り替え<br/>
stagingブランチに切り替え<br/>
自動的にフェッチが行われる<br/>
 (全てsourcetree上での作業)</p></blockquote>

<p>その後、ターミナル上でも<code>fetch</code>してみたが、何事もなく動作した。</p>

<pre><code>$ git fetch staging
Fetching repository, done.
</code></pre>

<hr />

<p>結局、原因は不明で、修正手順も不明、なのだけれど、<br/>
ちょっと情報が少なかったのでメモとして残しておく。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mailgun APIを使ってメールを送る Composer版]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/07/15/mailgunapi/"/>
    <updated>2014-07-15T14:13:12+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/07/15/mailgunapi</id>
    <content type="html"><![CDATA[<p>いくつか書いているmailgunを使用したメール送信の件ですが、<br/>
たぶん正しいと思われる方法がわかったのでメモしておきます。</p>

<!-- more -->


<h3>composerでインストール</h3>

<p><a href="https://github.com/mailgun/mailgun-php">mailgun/mailgun-php · GitHub</a></p>

<p>composerを使用して、ライブラリをインストールします。<br/>
Composerのインストールは以下などを参照に。<br/>
<a href="http://tech.basicinc.jp/php/2013/08/18/php_composer/">PHPのパッケージ管理Composerを使う</a></p>

<p>Windowsの場合は以下に書きました。<br/>
<a href="http://kayakuguri.github.io/blog/2014/07/15/win7-composer/">Windows7でComposerのインストール</a></p>

<p><code>composer.json</code>に以下のように記述。</p>

<pre><code>{
    "require": {
        "mailgun/mailgun-php": "~1.7.1"
    }
}
</code></pre>

<p>で、インストール。</p>

<pre><code>$ composer install
</code></pre>

<p>これでライブラリなどがダウンロードされ、mailgunの依存関係が出来上がります。</p>

<h3>Mailgun</h3>

<h4>インストール</h4>

<p>アドオンのインストール。</p>

<pre><code>$ heroku addons:add mailgun
</code></pre>

<h4>セットアップ</h4>

<p>PHPの冒頭で初期化して送信。<br/>
初期化するためにはAPIキーとドメインが必要。<br/>
これは環境変数に入っている。</p>

<pre><code>MAILGUN_API_KEY:       key-xxx
MAILGUN_SMTP_LOGIN:    postmaster@xxx.mailgun.org
MAILGUN_SMTP_PASSWORD: xxx
MAILGUN_SMTP_PORT:     587
MAILGUN_SMTP_SERVER:   smtp.mailgun.org
</code></pre>

<p>ドメインは、<code>MAILGUN_SMTP_LOGIN</code>の<code>@</code>より後ろ、になるので、それを使用する。</p>

<pre><code>require 'vendor/autoload.php';
use Mailgun\Mailgun;

$mgClient = new Mailgun(getenv('MAILGUN_API_KEY'));
$domain = getenv('MAILGUN_SMTP_LOGIN');
$domain = substr($domain, strpos($domain, '@') + 1);
</code></pre>

<h4>送信</h4>

<p>通常の送信は以下。</p>

<pre><code>$result = $mgClient-&gt;sendMessage($domain, array(
    'from'    =&gt; 'Excited User &lt;me@samples.mailgun.org&gt;',
    'to'      =&gt; 'Baz &lt;baz@example.com&gt;',
    'subject' =&gt; 'Hello',
    'text'    =&gt; 'Testing some Mailgun awesomness!'
));
</code></pre>

<h4>パラメータを個別に設定</h4>

<p>上記では送信時に一括で指定しているけれど、これを個別に設定するには、<br/>
<code>Message Builder</code>というものを使用します。<br/>
<a href="https://github.com/mailgun/mailgun-php/blob/master/src/Mailgun/Messages/README.md#usage---message-builder">Usage &ndash; Message Builder</a></p>

<p>上記のセットをバラすと以下のようになります。</p>

<pre><code>$msgBldr = $mgClient-&gt;MessageBuilder();
$msgBldr-&gt;setFromAddress('Excited User &lt;me@samples.mailgun.org&gt;');
$msgBldr-&gt;addToRecipient('Baz &lt;baz@example.com&gt;');
$msgBldr-&gt;setSubject('Hello');
$msgBldr-&gt;setTextBody('Testing some Mailgun awesomness!'); 
$result = $mgClient-&gt;post("{$domain}/messages", $msgBldr-&gt;getMessage(), $msgBldr-&gt;getFiles());
</code></pre>

<h4>キューにまとめて登録</h4>

<p>また、キューにまとめて登録する場合は、<code>Batch Message</code>を使用します。<br/>
<a href="https://github.com/mailgun/mailgun-php/blob/master/src/Mailgun/Messages/README.md#usage---batch-message">Usage &ndash; Batch Message</a></p>

<p>これを使用して、toを複数登録すると、それぞれのtoにバラバラに同じメールが送られます。</p>

<pre><code>$msgBldr = $mgClient-&gt;BatchMessage($domain);
$msgBldr-&gt;addToRecipient('test1 &lt;test1@example.com&gt;');
$msgBldr-&gt;addToRecipient('test2 &lt;test2@example.com&gt;');
// 他のパラメータ設定は同じ
$result = $msgBldr-&gt;finalize();
</code></pre>

<p><code>finalize</code>で、キューに登録されるようでした。</p>

<hr />

<p>今までのmailgun関連の記事はこちら</p>

<ul>
<li><a href="http://kayakuguri.github.io/blog/2014/02/17/send-mail-from-heroku-with-mailgun/">PHPでMailgunを使ってherokuでメール送信する</a></li>
<li><a href="http://kayakuguri.github.io/blog/2014/02/18/php-heroku-sendattachmail/">[PHP]herokuで添付ファイル付きメールを送る</a></li>
<li><a href="http://kayakuguri.github.io/blog/2014/02/19/attachment-use-mailgunapi/">[PHP][heroku]Mailgun APIを使って添付ファイルを送る</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Herokuでデプロイエラーが起きた]]></title>
    <link href="http://kayakuguri.github.io/blog/2014/07/09/heroku-r10/"/>
    <updated>2014-07-09T17:13:26+09:00</updated>
    <id>http://kayakuguri.github.io/blog/2014/07/09/heroku-r10</id>
    <content type="html"><![CDATA[<p>いつものようにさくっとpushすると、サイトにアクセス出来ない。。<br/>
とりあえず、<code>rollback</code>で戻しておいたが、原因を探った。</p>

<!-- more -->


<p>ログを見ると以下のようになっていた。</p>

<pre><code>heroku/web.1:  State changed from up to starting 
app/web.1:  Going down, terminating child processes... 
heroku/web.1:  Stopping all processes with SIGTERM 
heroku/web.1:  Process exited with status 0 
heroku/web.1:  State changed from starting to crashed
heroku/web.1:  State changed from crashed to starting 
heroku/web.1:  Error R10 (Boot timeout) -&gt; Web process failed to bind to $PORT within 60 seconds of launch 
heroku/web.1:  Stopping process with SIGKILL 
heroku/web.1:  Process exited with status 137 
</code></pre>

<p>どうやら、<code>R10 (Boot timeout)</code>なるエラーが発生しているよう。</p>

<p><a href="https://devcenter.heroku.com/articles/error-codes#r10-boot-timeout">R10 &ndash; Boot timeout</a></p>

<blockquote><p>A web process took longer than 60 seconds to bind to its assigned <code>$PORT</code>. When this happens, the dyno’s process is killed and the dyno is considered crashed. Crashed dynos are restarted according to the dyno manager’s restart policy.</p></blockquote>

<p>Webプロセスは、割り当てられた<code>$PORT</code>にバインドするために60秒以上かかった。これが発生すると、dynoのプロセスは強制終了され、dynoがクラッシュしたと考えられている。ダウンしたdynoは、dynoマネージャの再起動ポリシーに応じて再起動されます。</p>

<blockquote><p>This error is often caused by a process being unable to reach an external resource, such as a database, or the application doing too much work, such as parsing and evaluating numerous, large code dependencies, during startup.</p></blockquote>

<p>このエラーは、多くの場合、データベース、または起動時に、非常に多くの、大規模なコードの依存関係を解析し、評価するようなあまりにも多くの処理を行なっているアプリケーションなどの外部リソースに到達することができないというプロセスが原因で発生します。</p>

<blockquote><p>Common solutions are to access external resources asynchronously, so they don’t block startup, and to reduce the amount of application code or its dependencies.</p></blockquote>

<p>一般的な解決策は非同期に外部リソースにアクセスすることなので、起動をブロックしないように、アプリケーションコードまたはその依存関係の量を低減する事です。</p>

<p>サポートに問い合わせることで、この60秒制限を120秒にすることもできるそう。</p>

<hr />

<h3>Heroku::Forward</h3>

<p>R10エラーが起きる主な原因は存在しない外部リソースへのアクセスや、使用しているgemの量が増えている事が挙げられるらしい。<br/>
それを自動で整理？してくれるようなものが以下のよう。</p>

<p><a href="https://github.com/dblock/heroku-forward">dblock/heroku-forward · GitHub</a></p>

<p>しかしこれは<code>Ruby</code>。今回は<code>PHP</code>。</p>

<hr />

<h3>原因</h3>

<p>で、テストアプリを作って全く同じ構成にして検証してみたところ、<br/>
NewRelicが重くなってしまっているようだった。<br/>
試しにそれを外すとエラーが出なくなった。</p>

<hr />

<h3>対策</h3>

<p>NewRelicはアプリを起動し続けるためのpingとしての使用がメインだったので、<br/>
(ログなどが見られるのは嬉しかったが)<br/>
同じように定期的にpingを飛ばす方法を探してみた。</p>

<h4>Heroku Schedulerで叩き起こす</h4>

<p><a href="http://blog.mah-lab.com/2013/05/16/heroku-commons-16/">知っておきたい！Herokuを使う上では当たり前？の16の常識 | mah365</a></p>

<blockquote><p>1時間毎に<code>curl http://your-app-name.herokuapp.com/</code>というコマンドを叩くように設定すれば、起き続けます。</p></blockquote>

<p><a href="https://addons.heroku.com/scheduler">Heroku Scheduler</a><br/>
アドオンを追加</p>

<pre><code>$ heroku addons:add scheduler
</code></pre>

<p>この状態でデプロイが通るかを確認。→ OK。</p>

<p><img src="/images/2014/07/scheduler01.jpg" alt="Phpstrom diff" /></p>

<p>以下を追加</p>

<pre><code>curl http://your-app-name.herokuapp.com/
</code></pre>

<p>FREQUENCY(頻度)を、<code>Hourly</code>にして、save。</p>

<p><img src="/images/2014/07/scheduler02.jpg" alt="Phpstrom diff" /></p>

<p>これで1時間毎に指定のURLを叩いてくれる。</p>

<hr />

<h3>Dyno Hour</h3>

<p>Herokuの料金は、1Dynoで起動時間が月750時間までは無料。<br/>
通常であれば、1日 x 24時間 x 31日 = 744時間 で、無料範囲ない。<br/>
ただし、Heroku Schedulerで実行した時間もDynoの起動時間に含まれる。</p>

<p>単純にURLを叩くだけ、なら大丈夫かと思うけれど、<br/>
重めのバッチ処理をスケジューラーでこまめに起動していると請求が発生する可能性があるので注意。</p>
]]></content>
  </entry>
  
</feed>
